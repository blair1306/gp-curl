<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>urldata.h source code [codebrowser/lib/urldata.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="ConnectBits,Curl_async,Curl_easy,Curl_handler,Curl_http2_dep,DynamicStatic,Names,Progress,PureInfo,SingleRequest,UrlState,UserDefined,auth,connectdata,curl_ssl_session,digestdata,dupstring,dynamically_allocated_data,expect100,hostname,http_connect_state,ntlmdata,proxy_info,ssl_config_data,ssl_connect_data,ssl_general_config,ssl_primary_config,tempbuf,time_node,upgrade101 "/>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'codebrowser/lib/urldata.h'; var root_path = '../..'; var data_path = '../../../data';</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>codebrowser</a>/<a href='./'>lib</a>/<a href='urldata.h.html'>urldata.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><u>#<span data-ppcond="1">ifndef</span> <span class="macro" data-ref="_M/HEADER_CURL_URLDATA_H">HEADER_CURL_URLDATA_H</span></u></td></tr>
<tr><th id="2">2</th><td><u>#define <dfn class="macro" id="_M/HEADER_CURL_URLDATA_H" data-ref="_M/HEADER_CURL_URLDATA_H">HEADER_CURL_URLDATA_H</dfn></u></td></tr>
<tr><th id="3">3</th><td><i>/***************************************************************************</i></td></tr>
<tr><th id="4">4</th><td><i> *                                  _   _ ____  _</i></td></tr>
<tr><th id="5">5</th><td><i> *  Project                     ___| | | |  _ \| |</i></td></tr>
<tr><th id="6">6</th><td><i> *                             / __| | | | |_) | |</i></td></tr>
<tr><th id="7">7</th><td><i> *                            | (__| |_| |  _ &lt;| |___</i></td></tr>
<tr><th id="8">8</th><td><i> *                             \___|\___/|_| \_\_____|</i></td></tr>
<tr><th id="9">9</th><td><i> *</i></td></tr>
<tr><th id="10">10</th><td><i> * Copyright (C) 1998 - 2017, Daniel Stenberg, &lt;daniel@haxx.se&gt;, et al.</i></td></tr>
<tr><th id="11">11</th><td><i> *</i></td></tr>
<tr><th id="12">12</th><td><i> * This software is licensed as described in the file COPYING, which</i></td></tr>
<tr><th id="13">13</th><td><i> * you should have received as part of this distribution. The terms</i></td></tr>
<tr><th id="14">14</th><td><i> * are also available at <a href="https://curl.haxx.se/docs/copyright.html">https://curl.haxx.se/docs/copyright.html</a>.</i></td></tr>
<tr><th id="15">15</th><td><i> *</i></td></tr>
<tr><th id="16">16</th><td><i> * You may opt to use, copy, modify, merge, publish, distribute and/or sell</i></td></tr>
<tr><th id="17">17</th><td><i> * copies of the Software, and permit persons to whom the Software is</i></td></tr>
<tr><th id="18">18</th><td><i> * furnished to do so, under the terms of the COPYING file.</i></td></tr>
<tr><th id="19">19</th><td><i> *</i></td></tr>
<tr><th id="20">20</th><td><i> * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY</i></td></tr>
<tr><th id="21">21</th><td><i> * KIND, either express or implied.</i></td></tr>
<tr><th id="22">22</th><td><i> *</i></td></tr>
<tr><th id="23">23</th><td><i> ***************************************************************************/</i></td></tr>
<tr><th id="24">24</th><td></td></tr>
<tr><th id="25">25</th><td><i>/* This file is for lib internal stuff */</i></td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td><u>#include <a href="curl_setup.h.html">"curl_setup.h"</a></u></td></tr>
<tr><th id="28">28</th><td></td></tr>
<tr><th id="29">29</th><td><u>#define <dfn class="macro" id="_M/PORT_FTP" data-ref="_M/PORT_FTP">PORT_FTP</dfn> 21</u></td></tr>
<tr><th id="30">30</th><td><u>#define <dfn class="macro" id="_M/PORT_FTPS" data-ref="_M/PORT_FTPS">PORT_FTPS</dfn> 990</u></td></tr>
<tr><th id="31">31</th><td><u>#define <dfn class="macro" id="_M/PORT_TELNET" data-ref="_M/PORT_TELNET">PORT_TELNET</dfn> 23</u></td></tr>
<tr><th id="32">32</th><td><u>#define <dfn class="macro" id="_M/PORT_HTTP" data-ref="_M/PORT_HTTP">PORT_HTTP</dfn> 80</u></td></tr>
<tr><th id="33">33</th><td><u>#define <dfn class="macro" id="_M/PORT_HTTPS" data-ref="_M/PORT_HTTPS">PORT_HTTPS</dfn> 443</u></td></tr>
<tr><th id="34">34</th><td><u>#define <dfn class="macro" id="_M/PORT_DICT" data-ref="_M/PORT_DICT">PORT_DICT</dfn> 2628</u></td></tr>
<tr><th id="35">35</th><td><u>#define <dfn class="macro" id="_M/PORT_LDAP" data-ref="_M/PORT_LDAP">PORT_LDAP</dfn> 389</u></td></tr>
<tr><th id="36">36</th><td><u>#define <dfn class="macro" id="_M/PORT_LDAPS" data-ref="_M/PORT_LDAPS">PORT_LDAPS</dfn> 636</u></td></tr>
<tr><th id="37">37</th><td><u>#define <dfn class="macro" id="_M/PORT_TFTP" data-ref="_M/PORT_TFTP">PORT_TFTP</dfn> 69</u></td></tr>
<tr><th id="38">38</th><td><u>#define <dfn class="macro" id="_M/PORT_SSH" data-ref="_M/PORT_SSH">PORT_SSH</dfn> 22</u></td></tr>
<tr><th id="39">39</th><td><u>#define <dfn class="macro" id="_M/PORT_IMAP" data-ref="_M/PORT_IMAP">PORT_IMAP</dfn> 143</u></td></tr>
<tr><th id="40">40</th><td><u>#define <dfn class="macro" id="_M/PORT_IMAPS" data-ref="_M/PORT_IMAPS">PORT_IMAPS</dfn> 993</u></td></tr>
<tr><th id="41">41</th><td><u>#define <dfn class="macro" id="_M/PORT_POP3" data-ref="_M/PORT_POP3">PORT_POP3</dfn> 110</u></td></tr>
<tr><th id="42">42</th><td><u>#define <dfn class="macro" id="_M/PORT_POP3S" data-ref="_M/PORT_POP3S">PORT_POP3S</dfn> 995</u></td></tr>
<tr><th id="43">43</th><td><u>#define <dfn class="macro" id="_M/PORT_SMB" data-ref="_M/PORT_SMB">PORT_SMB</dfn> 445</u></td></tr>
<tr><th id="44">44</th><td><u>#define <dfn class="macro" id="_M/PORT_SMBS" data-ref="_M/PORT_SMBS">PORT_SMBS</dfn> 445</u></td></tr>
<tr><th id="45">45</th><td><u>#define <dfn class="macro" id="_M/PORT_SMTP" data-ref="_M/PORT_SMTP">PORT_SMTP</dfn> 25</u></td></tr>
<tr><th id="46">46</th><td><u>#define <dfn class="macro" id="_M/PORT_SMTPS" data-ref="_M/PORT_SMTPS">PORT_SMTPS</dfn> 465 /* sometimes called SSMTP */</u></td></tr>
<tr><th id="47">47</th><td><u>#define <dfn class="macro" id="_M/PORT_RTSP" data-ref="_M/PORT_RTSP">PORT_RTSP</dfn> 554</u></td></tr>
<tr><th id="48">48</th><td><u>#define <dfn class="macro" id="_M/PORT_RTMP" data-ref="_M/PORT_RTMP">PORT_RTMP</dfn> 1935</u></td></tr>
<tr><th id="49">49</th><td><u>#define <dfn class="macro" id="_M/PORT_RTMPT" data-ref="_M/PORT_RTMPT">PORT_RTMPT</dfn> PORT_HTTP</u></td></tr>
<tr><th id="50">50</th><td><u>#define <dfn class="macro" id="_M/PORT_RTMPS" data-ref="_M/PORT_RTMPS">PORT_RTMPS</dfn> PORT_HTTPS</u></td></tr>
<tr><th id="51">51</th><td><u>#define <dfn class="macro" id="_M/PORT_GOPHER" data-ref="_M/PORT_GOPHER">PORT_GOPHER</dfn> 70</u></td></tr>
<tr><th id="52">52</th><td></td></tr>
<tr><th id="53">53</th><td><u>#define <dfn class="macro" id="_M/DICT_MATCH" data-ref="_M/DICT_MATCH">DICT_MATCH</dfn> "/MATCH:"</u></td></tr>
<tr><th id="54">54</th><td><u>#define <dfn class="macro" id="_M/DICT_MATCH2" data-ref="_M/DICT_MATCH2">DICT_MATCH2</dfn> "/M:"</u></td></tr>
<tr><th id="55">55</th><td><u>#define <dfn class="macro" id="_M/DICT_MATCH3" data-ref="_M/DICT_MATCH3">DICT_MATCH3</dfn> "/FIND:"</u></td></tr>
<tr><th id="56">56</th><td><u>#define <dfn class="macro" id="_M/DICT_DEFINE" data-ref="_M/DICT_DEFINE">DICT_DEFINE</dfn> "/DEFINE:"</u></td></tr>
<tr><th id="57">57</th><td><u>#define <dfn class="macro" id="_M/DICT_DEFINE2" data-ref="_M/DICT_DEFINE2">DICT_DEFINE2</dfn> "/D:"</u></td></tr>
<tr><th id="58">58</th><td><u>#define <dfn class="macro" id="_M/DICT_DEFINE3" data-ref="_M/DICT_DEFINE3">DICT_DEFINE3</dfn> "/LOOKUP:"</u></td></tr>
<tr><th id="59">59</th><td></td></tr>
<tr><th id="60">60</th><td><u>#define <dfn class="macro" id="_M/CURL_DEFAULT_USER" data-ref="_M/CURL_DEFAULT_USER">CURL_DEFAULT_USER</dfn> "anonymous"</u></td></tr>
<tr><th id="61">61</th><td><u>#define <dfn class="macro" id="_M/CURL_DEFAULT_PASSWORD" data-ref="_M/CURL_DEFAULT_PASSWORD">CURL_DEFAULT_PASSWORD</dfn> "ftp@example.com"</u></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><i>/* Convenience defines for checking protocols or their SSL based version. Each</i></td></tr>
<tr><th id="64">64</th><td><i>   protocol handler should only ever have a single CURLPROTO_ in its protocol</i></td></tr>
<tr><th id="65">65</th><td><i>   field. */</i></td></tr>
<tr><th id="66">66</th><td><u>#define <dfn class="macro" id="_M/PROTO_FAMILY_HTTP" data-ref="_M/PROTO_FAMILY_HTTP">PROTO_FAMILY_HTTP</dfn> (CURLPROTO_HTTP|CURLPROTO_HTTPS)</u></td></tr>
<tr><th id="67">67</th><td><u>#define <dfn class="macro" id="_M/PROTO_FAMILY_FTP" data-ref="_M/PROTO_FAMILY_FTP">PROTO_FAMILY_FTP</dfn>  (CURLPROTO_FTP|CURLPROTO_FTPS)</u></td></tr>
<tr><th id="68">68</th><td><u>#define <dfn class="macro" id="_M/PROTO_FAMILY_POP3" data-ref="_M/PROTO_FAMILY_POP3">PROTO_FAMILY_POP3</dfn> (CURLPROTO_POP3|CURLPROTO_POP3S)</u></td></tr>
<tr><th id="69">69</th><td><u>#define <dfn class="macro" id="_M/PROTO_FAMILY_SMB" data-ref="_M/PROTO_FAMILY_SMB">PROTO_FAMILY_SMB</dfn>  (CURLPROTO_SMB|CURLPROTO_SMBS)</u></td></tr>
<tr><th id="70">70</th><td><u>#define <dfn class="macro" id="_M/PROTO_FAMILY_SMTP" data-ref="_M/PROTO_FAMILY_SMTP">PROTO_FAMILY_SMTP</dfn> (CURLPROTO_SMTP|CURLPROTO_SMTPS)</u></td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td><u>#define <dfn class="macro" id="_M/DEFAULT_CONNCACHE_SIZE" data-ref="_M/DEFAULT_CONNCACHE_SIZE">DEFAULT_CONNCACHE_SIZE</dfn> 5</u></td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><i>/* length of longest IPv6 address string including the trailing null */</i></td></tr>
<tr><th id="75">75</th><td><u>#define <dfn class="macro" id="_M/MAX_IPADR_LEN" data-ref="_M/MAX_IPADR_LEN">MAX_IPADR_LEN</dfn> sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")</u></td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td><i>/* Default FTP/IMAP etc response timeout in milliseconds.</i></td></tr>
<tr><th id="78">78</th><td><i>   Symbian OS panics when given a timeout much greater than 1/2 hour.</i></td></tr>
<tr><th id="79">79</th><td><i>*/</i></td></tr>
<tr><th id="80">80</th><td><u>#define <dfn class="macro" id="_M/RESP_TIMEOUT" data-ref="_M/RESP_TIMEOUT">RESP_TIMEOUT</dfn> (1800*1000)</u></td></tr>
<tr><th id="81">81</th><td></td></tr>
<tr><th id="82">82</th><td><u>#include <a href="cookie.h.html">"cookie.h"</a></u></td></tr>
<tr><th id="83">83</th><td><u>#include <a href="formdata.h.html">"formdata.h"</a></u></td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td><u>#<span data-ppcond="85">ifdef</span> <a class="macro" href="curl_config.h.html#429" data-ref="_M/HAVE_NETINET_IN_H">HAVE_NETINET_IN_H</a></u></td></tr>
<tr><th id="86">86</th><td><u>#include <a href="../../include/netinet/in.h.html">&lt;netinet/in.h&gt;</a></u></td></tr>
<tr><th id="87">87</th><td><u>#<span data-ppcond="85">endif</span></u></td></tr>
<tr><th id="88">88</th><td></td></tr>
<tr><th id="89">89</th><td><u>#include <a href="timeval.h.html">"timeval.h"</a></u></td></tr>
<tr><th id="90">90</th><td></td></tr>
<tr><th id="91">91</th><td><u>#<span data-ppcond="91">ifdef</span> <a class="macro" href="curl_config.h.html#756" data-ref="_M/HAVE_ZLIB_H">HAVE_ZLIB_H</a></u></td></tr>
<tr><th id="92">92</th><td><u>#include <a href="../../include/zlib.h.html">&lt;zlib.h&gt;</a>               /* for content-encoding */</u></td></tr>
<tr><th id="93">93</th><td><u>#<span data-ppcond="93">ifdef</span> <span class="macro" data-ref="_M/__SYMBIAN32__">__SYMBIAN32__</span></u></td></tr>
<tr><th id="94">94</th><td><i>/* zlib pollutes the namespace with this definition */</i></td></tr>
<tr><th id="95">95</th><td><u>#undef WIN32</u></td></tr>
<tr><th id="96">96</th><td><u>#<span data-ppcond="93">endif</span></u></td></tr>
<tr><th id="97">97</th><td><u>#<span data-ppcond="91">endif</span></u></td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td><u>#include <a href="../include/curl/curl.h.html">&lt;curl/curl.h&gt;</a></u></td></tr>
<tr><th id="100">100</th><td></td></tr>
<tr><th id="101">101</th><td><u>#include <a href="http_chunks.h.html">"http_chunks.h"</a> /* for the structs and enum stuff */</u></td></tr>
<tr><th id="102">102</th><td><u>#include <a href="hostip.h.html">"hostip.h"</a></u></td></tr>
<tr><th id="103">103</th><td><u>#include <a href="hash.h.html">"hash.h"</a></u></td></tr>
<tr><th id="104">104</th><td><u>#include <a href="splay.h.html">"splay.h"</a></u></td></tr>
<tr><th id="105">105</th><td></td></tr>
<tr><th id="106">106</th><td><u>#include <a href="mime.h.html">"mime.h"</a></u></td></tr>
<tr><th id="107">107</th><td><u>#include <a href="imap.h.html">"imap.h"</a></u></td></tr>
<tr><th id="108">108</th><td><u>#include <a href="pop3.h.html">"pop3.h"</a></u></td></tr>
<tr><th id="109">109</th><td><u>#include <a href="smtp.h.html">"smtp.h"</a></u></td></tr>
<tr><th id="110">110</th><td><u>#include <a href="ftp.h.html">"ftp.h"</a></u></td></tr>
<tr><th id="111">111</th><td><u>#include <a href="file.h.html">"file.h"</a></u></td></tr>
<tr><th id="112">112</th><td><u>#include <a href="ssh.h.html">"ssh.h"</a></u></td></tr>
<tr><th id="113">113</th><td><u>#include <a href="http.h.html">"http.h"</a></u></td></tr>
<tr><th id="114">114</th><td><u>#include <a href="rtsp.h.html">"rtsp.h"</a></u></td></tr>
<tr><th id="115">115</th><td><u>#include <a href="smb.h.html">"smb.h"</a></u></td></tr>
<tr><th id="116">116</th><td><u>#include <a href="wildcard.h.html">"wildcard.h"</a></u></td></tr>
<tr><th id="117">117</th><td><u>#include <a href="multihandle.h.html">"multihandle.h"</a></u></td></tr>
<tr><th id="118">118</th><td></td></tr>
<tr><th id="119">119</th><td><u>#<span data-ppcond="119">ifdef</span> <span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span></u></td></tr>
<tr><th id="120">120</th><td><u># ifdef HAVE_GSSGNU</u></td></tr>
<tr><th id="121">121</th><td><u>#  include &lt;gss.h&gt;</u></td></tr>
<tr><th id="122">122</th><td><u># elif defined HAVE_GSSMIT</u></td></tr>
<tr><th id="123">123</th><td><u>#  include &lt;gssapi/gssapi.h&gt;</u></td></tr>
<tr><th id="124">124</th><td><u>#  include &lt;gssapi/gssapi_generic.h&gt;</u></td></tr>
<tr><th id="125">125</th><td><u># else</u></td></tr>
<tr><th id="126">126</th><td><u>#  include &lt;gssapi.h&gt;</u></td></tr>
<tr><th id="127">127</th><td><u># endif</u></td></tr>
<tr><th id="128">128</th><td><u>#<span data-ppcond="119">endif</span></u></td></tr>
<tr><th id="129">129</th><td></td></tr>
<tr><th id="130">130</th><td><u>#<span data-ppcond="130">ifdef</span> <span class="macro" data-ref="_M/HAVE_LIBSSH2_H">HAVE_LIBSSH2_H</span></u></td></tr>
<tr><th id="131">131</th><td><u>#include &lt;libssh2.h&gt;</u></td></tr>
<tr><th id="132">132</th><td><u>#include &lt;libssh2_sftp.h&gt;</u></td></tr>
<tr><th id="133">133</th><td><u>#<span data-ppcond="130">endif</span> /* HAVE_LIBSSH2_H */</u></td></tr>
<tr><th id="134">134</th><td></td></tr>
<tr><th id="135">135</th><td><i>/* The upload buffer size, should not be smaller than CURL_MAX_WRITE_SIZE, as</i></td></tr>
<tr><th id="136">136</th><td><i>   it needs to hold a full buffer as could be sent in a write callback */</i></td></tr>
<tr><th id="137">137</th><td><u>#define <dfn class="macro" id="_M/UPLOAD_BUFSIZE" data-ref="_M/UPLOAD_BUFSIZE">UPLOAD_BUFSIZE</dfn> CURL_MAX_WRITE_SIZE</u></td></tr>
<tr><th id="138">138</th><td></td></tr>
<tr><th id="139">139</th><td><i>/* The "master buffer" is for HTTP pipelining */</i></td></tr>
<tr><th id="140">140</th><td><u>#define <dfn class="macro" id="_M/MASTERBUF_SIZE" data-ref="_M/MASTERBUF_SIZE">MASTERBUF_SIZE</dfn> 16384</u></td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td><i>/* Initial size of the buffer to store headers in, it'll be enlarged in case</i></td></tr>
<tr><th id="143">143</th><td><i>   of need. */</i></td></tr>
<tr><th id="144">144</th><td><u>#define <dfn class="macro" id="_M/HEADERSIZE" data-ref="_M/HEADERSIZE">HEADERSIZE</dfn> 256</u></td></tr>
<tr><th id="145">145</th><td></td></tr>
<tr><th id="146">146</th><td><u>#define <dfn class="macro" id="_M/CURLEASY_MAGIC_NUMBER" data-ref="_M/CURLEASY_MAGIC_NUMBER">CURLEASY_MAGIC_NUMBER</dfn> 0xc0dedbadU</u></td></tr>
<tr><th id="147">147</th><td><u>#define <dfn class="macro" id="_M/GOOD_EASY_HANDLE" data-ref="_M/GOOD_EASY_HANDLE">GOOD_EASY_HANDLE</dfn>(x) \</u></td></tr>
<tr><th id="148">148</th><td><u>  ((x) &amp;&amp; ((x)-&gt;magic == CURLEASY_MAGIC_NUMBER))</u></td></tr>
<tr><th id="149">149</th><td></td></tr>
<tr><th id="150">150</th><td><i>/* Some convenience macros to get the larger/smaller value out of two given.</i></td></tr>
<tr><th id="151">151</th><td><i>   We prefix with CURL to prevent name collisions. */</i></td></tr>
<tr><th id="152">152</th><td><u>#define <dfn class="macro" id="_M/CURLMAX" data-ref="_M/CURLMAX">CURLMAX</dfn>(x,y) ((x)&gt;(y)?(x):(y))</u></td></tr>
<tr><th id="153">153</th><td><u>#define <dfn class="macro" id="_M/CURLMIN" data-ref="_M/CURLMIN">CURLMIN</dfn>(x,y) ((x)&lt;(y)?(x):(y))</u></td></tr>
<tr><th id="154">154</th><td></td></tr>
<tr><th id="155">155</th><td><u>#<span data-ppcond="155">ifdef</span> <span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span></u></td></tr>
<tr><th id="156">156</th><td><i>/* Types needed for krb5-ftp connections */</i></td></tr>
<tr><th id="157">157</th><td><b>struct</b> krb5buffer {</td></tr>
<tr><th id="158">158</th><td>  <em>void</em> *data;</td></tr>
<tr><th id="159">159</th><td>  size_t size;</td></tr>
<tr><th id="160">160</th><td>  size_t index;</td></tr>
<tr><th id="161">161</th><td>  <em>int</em> eof_flag;</td></tr>
<tr><th id="162">162</th><td>};</td></tr>
<tr><th id="163">163</th><td></td></tr>
<tr><th id="164">164</th><td><b>enum</b> protection_level {</td></tr>
<tr><th id="165">165</th><td>  PROT_NONE, <i>/* first in list */</i></td></tr>
<tr><th id="166">166</th><td>  PROT_CLEAR,</td></tr>
<tr><th id="167">167</th><td>  PROT_SAFE,</td></tr>
<tr><th id="168">168</th><td>  PROT_CONFIDENTIAL,</td></tr>
<tr><th id="169">169</th><td>  PROT_PRIVATE,</td></tr>
<tr><th id="170">170</th><td>  PROT_CMD,</td></tr>
<tr><th id="171">171</th><td>  PROT_LAST <i>/* last in list */</i></td></tr>
<tr><th id="172">172</th><td>};</td></tr>
<tr><th id="173">173</th><td><u>#<span data-ppcond="155">endif</span></u></td></tr>
<tr><th id="174">174</th><td></td></tr>
<tr><th id="175">175</th><td><i>/* enum for the nonblocking SSL connection state machine */</i></td></tr>
<tr><th id="176">176</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="177">177</th><td>  <dfn class="enum" id="ssl_connect_1" title='ssl_connect_1' data-ref="ssl_connect_1">ssl_connect_1</dfn>,</td></tr>
<tr><th id="178">178</th><td>  <dfn class="enum" id="ssl_connect_2" title='ssl_connect_2' data-ref="ssl_connect_2">ssl_connect_2</dfn>,</td></tr>
<tr><th id="179">179</th><td>  <dfn class="enum" id="ssl_connect_2_reading" title='ssl_connect_2_reading' data-ref="ssl_connect_2_reading">ssl_connect_2_reading</dfn>,</td></tr>
<tr><th id="180">180</th><td>  <dfn class="enum" id="ssl_connect_2_writing" title='ssl_connect_2_writing' data-ref="ssl_connect_2_writing">ssl_connect_2_writing</dfn>,</td></tr>
<tr><th id="181">181</th><td>  <dfn class="enum" id="ssl_connect_3" title='ssl_connect_3' data-ref="ssl_connect_3">ssl_connect_3</dfn>,</td></tr>
<tr><th id="182">182</th><td>  <dfn class="enum" id="ssl_connect_done" title='ssl_connect_done' data-ref="ssl_connect_done">ssl_connect_done</dfn></td></tr>
<tr><th id="183">183</th><td>} <dfn class="typedef" id="ssl_connect_state" title='ssl_connect_state' data-type='enum ssl_connect_state' data-ref="ssl_connect_state">ssl_connect_state</dfn>;</td></tr>
<tr><th id="184">184</th><td></td></tr>
<tr><th id="185">185</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="186">186</th><td>  <dfn class="enum" id="ssl_connection_none" title='ssl_connection_none' data-ref="ssl_connection_none">ssl_connection_none</dfn>,</td></tr>
<tr><th id="187">187</th><td>  <dfn class="enum" id="ssl_connection_negotiating" title='ssl_connection_negotiating' data-ref="ssl_connection_negotiating">ssl_connection_negotiating</dfn>,</td></tr>
<tr><th id="188">188</th><td>  <dfn class="enum" id="ssl_connection_complete" title='ssl_connection_complete' data-ref="ssl_connection_complete">ssl_connection_complete</dfn></td></tr>
<tr><th id="189">189</th><td>} <dfn class="typedef" id="ssl_connection_state" title='ssl_connection_state' data-type='enum ssl_connection_state' data-ref="ssl_connection_state">ssl_connection_state</dfn>;</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><i>/* SSL backend-specific data; declared differently by each SSL backend */</i></td></tr>
<tr><th id="192">192</th><td><b>struct</b> <dfn class="type" id="ssl_backend_data" title='ssl_backend_data' data-ref="ssl_backend_data">ssl_backend_data</dfn>;</td></tr>
<tr><th id="193">193</th><td></td></tr>
<tr><th id="194">194</th><td><i>/* struct for data related to each SSL connection */</i></td></tr>
<tr><th id="195">195</th><td><b>struct</b> <dfn class="type def" id="ssl_connect_data" title='ssl_connect_data' data-ref="ssl_connect_data">ssl_connect_data</dfn> {</td></tr>
<tr><th id="196">196</th><td>  <i>/* Use ssl encrypted communications TRUE/FALSE, not necessarily using it atm</i></td></tr>
<tr><th id="197">197</th><td><i>     but at least asked to or meaning to use it. See 'state' for the exact</i></td></tr>
<tr><th id="198">198</th><td><i>     current state of the connection. */</i></td></tr>
<tr><th id="199">199</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_connect_data::use" title='ssl_connect_data::use' data-ref="ssl_connect_data::use">use</dfn>;</td></tr>
<tr><th id="200">200</th><td>  <a class="typedef" href="#ssl_connection_state" title='ssl_connection_state' data-type='enum ssl_connection_state' data-ref="ssl_connection_state">ssl_connection_state</a> <dfn class="decl" id="ssl_connect_data::state" title='ssl_connect_data::state' data-ref="ssl_connect_data::state">state</dfn>;</td></tr>
<tr><th id="201">201</th><td>  <a class="typedef" href="#ssl_connect_state" title='ssl_connect_state' data-type='enum ssl_connect_state' data-ref="ssl_connect_state">ssl_connect_state</a> <dfn class="decl" id="ssl_connect_data::connecting_state" title='ssl_connect_data::connecting_state' data-ref="ssl_connect_data::connecting_state">connecting_state</dfn>;</td></tr>
<tr><th id="202">202</th><td><u>#<span data-ppcond="202">if</span> defined(<a class="macro" href="curl_setup.h.html#613" data-ref="_M/USE_SSL">USE_SSL</a>)</u></td></tr>
<tr><th id="203">203</th><td>  <b>struct</b> <a class="type" href="#ssl_backend_data" title='ssl_backend_data' data-ref="ssl_backend_data">ssl_backend_data</a> *<dfn class="decl" id="ssl_connect_data::backend" title='ssl_connect_data::backend' data-ref="ssl_connect_data::backend">backend</dfn>;</td></tr>
<tr><th id="204">204</th><td><u>#<span data-ppcond="202">endif</span></u></td></tr>
<tr><th id="205">205</th><td>};</td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><b>struct</b> <dfn class="type def" id="ssl_primary_config" title='ssl_primary_config' data-ref="ssl_primary_config">ssl_primary_config</dfn> {</td></tr>
<tr><th id="208">208</th><td>  <em>long</em> <dfn class="decl" id="ssl_primary_config::version" title='ssl_primary_config::version' data-ref="ssl_primary_config::version">version</dfn>;          <i>/* what version the client wants to use */</i></td></tr>
<tr><th id="209">209</th><td>  <em>long</em> <dfn class="decl" id="ssl_primary_config::version_max" title='ssl_primary_config::version_max' data-ref="ssl_primary_config::version_max">version_max</dfn>;      <i>/* max supported version the client wants to use*/</i></td></tr>
<tr><th id="210">210</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_primary_config::verifypeer" title='ssl_primary_config::verifypeer' data-ref="ssl_primary_config::verifypeer">verifypeer</dfn>;       <i>/* set TRUE if this is desired */</i></td></tr>
<tr><th id="211">211</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_primary_config::verifyhost" title='ssl_primary_config::verifyhost' data-ref="ssl_primary_config::verifyhost">verifyhost</dfn>;       <i>/* set TRUE if CN/SAN must match hostname */</i></td></tr>
<tr><th id="212">212</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_primary_config::verifystatus" title='ssl_primary_config::verifystatus' data-ref="ssl_primary_config::verifystatus">verifystatus</dfn>;     <i>/* set TRUE if certificate status must be checked */</i></td></tr>
<tr><th id="213">213</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_primary_config::sessionid" title='ssl_primary_config::sessionid' data-ref="ssl_primary_config::sessionid">sessionid</dfn>;        <i>/* cache session IDs or not */</i></td></tr>
<tr><th id="214">214</th><td>  <em>char</em> *<dfn class="decl" id="ssl_primary_config::CApath" title='ssl_primary_config::CApath' data-ref="ssl_primary_config::CApath">CApath</dfn>;          <i>/* certificate dir (doesn't work on windows) */</i></td></tr>
<tr><th id="215">215</th><td>  <em>char</em> *<dfn class="decl" id="ssl_primary_config::CAfile" title='ssl_primary_config::CAfile' data-ref="ssl_primary_config::CAfile">CAfile</dfn>;          <i>/* certificate to verify peer against */</i></td></tr>
<tr><th id="216">216</th><td>  <em>char</em> *<dfn class="decl" id="ssl_primary_config::clientcert" title='ssl_primary_config::clientcert' data-ref="ssl_primary_config::clientcert">clientcert</dfn>;</td></tr>
<tr><th id="217">217</th><td>  <em>char</em> *<dfn class="decl" id="ssl_primary_config::random_file" title='ssl_primary_config::random_file' data-ref="ssl_primary_config::random_file">random_file</dfn>;     <i>/* path to file containing "random" data */</i></td></tr>
<tr><th id="218">218</th><td>  <em>char</em> *<dfn class="decl" id="ssl_primary_config::egdsocket" title='ssl_primary_config::egdsocket' data-ref="ssl_primary_config::egdsocket">egdsocket</dfn>;       <i>/* path to file containing the EGD daemon socket */</i></td></tr>
<tr><th id="219">219</th><td>  <em>char</em> *<dfn class="decl" id="ssl_primary_config::cipher_list" title='ssl_primary_config::cipher_list' data-ref="ssl_primary_config::cipher_list">cipher_list</dfn>;     <i>/* list of ciphers to use */</i></td></tr>
<tr><th id="220">220</th><td>};</td></tr>
<tr><th id="221">221</th><td></td></tr>
<tr><th id="222">222</th><td><b>struct</b> <dfn class="type def" id="ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</dfn> {</td></tr>
<tr><th id="223">223</th><td>  <b>struct</b> <a class="type" href="#ssl_primary_config" title='ssl_primary_config' data-ref="ssl_primary_config">ssl_primary_config</a> <dfn class="decl" id="ssl_config_data::primary" title='ssl_config_data::primary' data-ref="ssl_config_data::primary">primary</dfn>;</td></tr>
<tr><th id="224">224</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_config_data::enable_beast" title='ssl_config_data::enable_beast' data-ref="ssl_config_data::enable_beast">enable_beast</dfn>; <i>/* especially allow this flaw for interoperability's</i></td></tr>
<tr><th id="225">225</th><td><i>                        sake*/</i></td></tr>
<tr><th id="226">226</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_config_data::no_revoke" title='ssl_config_data::no_revoke' data-ref="ssl_config_data::no_revoke">no_revoke</dfn>;    <i>/* disable SSL certificate revocation checks */</i></td></tr>
<tr><th id="227">227</th><td>  <em>long</em> <dfn class="decl" id="ssl_config_data::certverifyresult" title='ssl_config_data::certverifyresult' data-ref="ssl_config_data::certverifyresult">certverifyresult</dfn>; <i>/* result from the certificate verification */</i></td></tr>
<tr><th id="228">228</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::CRLfile" title='ssl_config_data::CRLfile' data-ref="ssl_config_data::CRLfile">CRLfile</dfn>;   <i>/* CRL to check certificate revocation */</i></td></tr>
<tr><th id="229">229</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::issuercert" title='ssl_config_data::issuercert' data-ref="ssl_config_data::issuercert">issuercert</dfn>;<i>/* optional issuer certificate filename */</i></td></tr>
<tr><th id="230">230</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_ssl_ctx_callback" title='curl_ssl_ctx_callback' data-type='CURLcode (*)(CURL *, void *, void *)' data-ref="curl_ssl_ctx_callback">curl_ssl_ctx_callback</a> <dfn class="decl" id="ssl_config_data::fsslctx" title='ssl_config_data::fsslctx' data-ref="ssl_config_data::fsslctx">fsslctx</dfn>; <i>/* function to initialize ssl ctx */</i></td></tr>
<tr><th id="231">231</th><td>  <em>void</em> *<dfn class="decl" id="ssl_config_data::fsslctxp" title='ssl_config_data::fsslctxp' data-ref="ssl_config_data::fsslctxp">fsslctxp</dfn>;        <i>/* parameter for call back */</i></td></tr>
<tr><th id="232">232</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_config_data::certinfo" title='ssl_config_data::certinfo' data-ref="ssl_config_data::certinfo">certinfo</dfn>;         <i>/* gather lots of certificate info */</i></td></tr>
<tr><th id="233">233</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ssl_config_data::falsestart" title='ssl_config_data::falsestart' data-ref="ssl_config_data::falsestart">falsestart</dfn>;</td></tr>
<tr><th id="234">234</th><td></td></tr>
<tr><th id="235">235</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::cert" title='ssl_config_data::cert' data-ref="ssl_config_data::cert">cert</dfn>; <i>/* client certificate file name */</i></td></tr>
<tr><th id="236">236</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::cert_type" title='ssl_config_data::cert_type' data-ref="ssl_config_data::cert_type">cert_type</dfn>; <i>/* format for certificate (default: PEM)*/</i></td></tr>
<tr><th id="237">237</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::key" title='ssl_config_data::key' data-ref="ssl_config_data::key">key</dfn>; <i>/* private key file name */</i></td></tr>
<tr><th id="238">238</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::key_type" title='ssl_config_data::key_type' data-ref="ssl_config_data::key_type">key_type</dfn>; <i>/* format for private key (default: PEM) */</i></td></tr>
<tr><th id="239">239</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::key_passwd" title='ssl_config_data::key_passwd' data-ref="ssl_config_data::key_passwd">key_passwd</dfn>; <i>/* plain text private key password */</i></td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><u>#<span data-ppcond="241">ifdef</span> <span class="macro" data-ref="_M/USE_TLS_SRP">USE_TLS_SRP</span></u></td></tr>
<tr><th id="242">242</th><td>  <em>char</em> *username; <i>/* TLS username (for, e.g., SRP) */</i></td></tr>
<tr><th id="243">243</th><td>  <em>char</em> *password; <i>/* TLS password (for, e.g., SRP) */</i></td></tr>
<tr><th id="244">244</th><td>  <b>enum</b> CURL_TLSAUTH authtype; <i>/* TLS authentication type (default SRP) */</i></td></tr>
<tr><th id="245">245</th><td><u>#<span data-ppcond="241">endif</span></u></td></tr>
<tr><th id="246">246</th><td>};</td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td><b>struct</b> <dfn class="type def" id="ssl_general_config" title='ssl_general_config' data-ref="ssl_general_config">ssl_general_config</dfn> {</td></tr>
<tr><th id="249">249</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="ssl_general_config::max_ssl_sessions" title='ssl_general_config::max_ssl_sessions' data-ref="ssl_general_config::max_ssl_sessions">max_ssl_sessions</dfn>; <i>/* SSL session id cache size */</i></td></tr>
<tr><th id="250">250</th><td>};</td></tr>
<tr><th id="251">251</th><td></td></tr>
<tr><th id="252">252</th><td><i>/* information stored about one single SSL session */</i></td></tr>
<tr><th id="253">253</th><td><b>struct</b> <dfn class="type def" id="curl_ssl_session" title='curl_ssl_session' data-ref="curl_ssl_session">curl_ssl_session</dfn> {</td></tr>
<tr><th id="254">254</th><td>  <em>char</em> *<dfn class="decl" id="curl_ssl_session::name" title='curl_ssl_session::name' data-ref="curl_ssl_session::name">name</dfn>;       <i>/* host name for which this ID was used */</i></td></tr>
<tr><th id="255">255</th><td>  <em>char</em> *<dfn class="decl" id="curl_ssl_session::conn_to_host" title='curl_ssl_session::conn_to_host' data-ref="curl_ssl_session::conn_to_host">conn_to_host</dfn>; <i>/* host name for the connection (may be NULL) */</i></td></tr>
<tr><th id="256">256</th><td>  <em>const</em> <em>char</em> *<dfn class="decl" id="curl_ssl_session::scheme" title='curl_ssl_session::scheme' data-ref="curl_ssl_session::scheme">scheme</dfn>; <i>/* protocol scheme used */</i></td></tr>
<tr><th id="257">257</th><td>  <em>void</em> *<dfn class="decl" id="curl_ssl_session::sessionid" title='curl_ssl_session::sessionid' data-ref="curl_ssl_session::sessionid">sessionid</dfn>;  <i>/* as returned from the SSL layer */</i></td></tr>
<tr><th id="258">258</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="curl_ssl_session::idsize" title='curl_ssl_session::idsize' data-ref="curl_ssl_session::idsize">idsize</dfn>;    <i>/* if known, otherwise 0 */</i></td></tr>
<tr><th id="259">259</th><td>  <em>long</em> <dfn class="decl" id="curl_ssl_session::age" title='curl_ssl_session::age' data-ref="curl_ssl_session::age">age</dfn>;         <i>/* just a number, the higher the more recent */</i></td></tr>
<tr><th id="260">260</th><td>  <em>int</em> <dfn class="decl" id="curl_ssl_session::remote_port" title='curl_ssl_session::remote_port' data-ref="curl_ssl_session::remote_port">remote_port</dfn>;  <i>/* remote port */</i></td></tr>
<tr><th id="261">261</th><td>  <em>int</em> <dfn class="decl" id="curl_ssl_session::conn_to_port" title='curl_ssl_session::conn_to_port' data-ref="curl_ssl_session::conn_to_port">conn_to_port</dfn>; <i>/* remote port for the connection (may be -1) */</i></td></tr>
<tr><th id="262">262</th><td>  <b>struct</b> <a class="type" href="#ssl_primary_config" title='ssl_primary_config' data-ref="ssl_primary_config">ssl_primary_config</a> <dfn class="decl" id="curl_ssl_session::ssl_config" title='curl_ssl_session::ssl_config' data-ref="curl_ssl_session::ssl_config">ssl_config</dfn>; <i>/* setup for this session */</i></td></tr>
<tr><th id="263">263</th><td>};</td></tr>
<tr><th id="264">264</th><td></td></tr>
<tr><th id="265">265</th><td><u>#<span data-ppcond="265">ifdef</span> <span class="macro" data-ref="_M/USE_WINDOWS_SSPI">USE_WINDOWS_SSPI</span></u></td></tr>
<tr><th id="266">266</th><td><u>#include "curl_sspi.h"</u></td></tr>
<tr><th id="267">267</th><td><u>#<span data-ppcond="265">endif</span></u></td></tr>
<tr><th id="268">268</th><td></td></tr>
<tr><th id="269">269</th><td><i>/* Struct used for Digest challenge-response authentication */</i></td></tr>
<tr><th id="270">270</th><td><b>struct</b> <dfn class="type def" id="digestdata" title='digestdata' data-ref="digestdata">digestdata</dfn> {</td></tr>
<tr><th id="271">271</th><td><u>#<span data-ppcond="271">if</span> defined(<span class="macro" data-ref="_M/USE_WINDOWS_SSPI">USE_WINDOWS_SSPI</span>)</u></td></tr>
<tr><th id="272">272</th><td>  BYTE *input_token;</td></tr>
<tr><th id="273">273</th><td>  size_t input_token_len;</td></tr>
<tr><th id="274">274</th><td>  CtxtHandle *http_context;</td></tr>
<tr><th id="275">275</th><td>  <i>/* copy of user/passwd used to make the identity for http_context.</i></td></tr>
<tr><th id="276">276</th><td><i>     either may be NULL. */</i></td></tr>
<tr><th id="277">277</th><td>  <em>char</em> *user;</td></tr>
<tr><th id="278">278</th><td>  <em>char</em> *passwd;</td></tr>
<tr><th id="279">279</th><td><u>#<span data-ppcond="271">else</span></u></td></tr>
<tr><th id="280">280</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::nonce" title='digestdata::nonce' data-ref="digestdata::nonce">nonce</dfn>;</td></tr>
<tr><th id="281">281</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::cnonce" title='digestdata::cnonce' data-ref="digestdata::cnonce">cnonce</dfn>;</td></tr>
<tr><th id="282">282</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::realm" title='digestdata::realm' data-ref="digestdata::realm">realm</dfn>;</td></tr>
<tr><th id="283">283</th><td>  <em>int</em> <dfn class="decl" id="digestdata::algo" title='digestdata::algo' data-ref="digestdata::algo">algo</dfn>;</td></tr>
<tr><th id="284">284</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="digestdata::stale" title='digestdata::stale' data-ref="digestdata::stale">stale</dfn>; <i>/* set true for re-negotiation */</i></td></tr>
<tr><th id="285">285</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::opaque" title='digestdata::opaque' data-ref="digestdata::opaque">opaque</dfn>;</td></tr>
<tr><th id="286">286</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::qop" title='digestdata::qop' data-ref="digestdata::qop">qop</dfn>;</td></tr>
<tr><th id="287">287</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::algorithm" title='digestdata::algorithm' data-ref="digestdata::algorithm">algorithm</dfn>;</td></tr>
<tr><th id="288">288</th><td>  <em>int</em> <dfn class="decl" id="digestdata::nc" title='digestdata::nc' data-ref="digestdata::nc">nc</dfn>; <i>/* nounce count */</i></td></tr>
<tr><th id="289">289</th><td><u>#<span data-ppcond="271">endif</span></u></td></tr>
<tr><th id="290">290</th><td>};</td></tr>
<tr><th id="291">291</th><td></td></tr>
<tr><th id="292">292</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="293">293</th><td>  <dfn class="enum" id="NTLMSTATE_NONE" title='NTLMSTATE_NONE' data-ref="NTLMSTATE_NONE">NTLMSTATE_NONE</dfn>,</td></tr>
<tr><th id="294">294</th><td>  <dfn class="enum" id="NTLMSTATE_TYPE1" title='NTLMSTATE_TYPE1' data-ref="NTLMSTATE_TYPE1">NTLMSTATE_TYPE1</dfn>,</td></tr>
<tr><th id="295">295</th><td>  <dfn class="enum" id="NTLMSTATE_TYPE2" title='NTLMSTATE_TYPE2' data-ref="NTLMSTATE_TYPE2">NTLMSTATE_TYPE2</dfn>,</td></tr>
<tr><th id="296">296</th><td>  <dfn class="enum" id="NTLMSTATE_TYPE3" title='NTLMSTATE_TYPE3' data-ref="NTLMSTATE_TYPE3">NTLMSTATE_TYPE3</dfn>,</td></tr>
<tr><th id="297">297</th><td>  <dfn class="enum" id="NTLMSTATE_LAST" title='NTLMSTATE_LAST' data-ref="NTLMSTATE_LAST">NTLMSTATE_LAST</dfn></td></tr>
<tr><th id="298">298</th><td>} <dfn class="typedef" id="curlntlm" title='curlntlm' data-type='enum curlntlm' data-ref="curlntlm">curlntlm</dfn>;</td></tr>
<tr><th id="299">299</th><td></td></tr>
<tr><th id="300">300</th><td><u>#<span data-ppcond="300">if</span> defined(<span class="macro" data-ref="_M/CURL_DOES_CONVERSIONS">CURL_DOES_CONVERSIONS</span>) &amp;&amp; defined(<span class="macro" data-ref="_M/HAVE_ICONV">HAVE_ICONV</span>)</u></td></tr>
<tr><th id="301">301</th><td><u>#include &lt;iconv.h&gt;</u></td></tr>
<tr><th id="302">302</th><td><u>#<span data-ppcond="300">endif</span></u></td></tr>
<tr><th id="303">303</th><td></td></tr>
<tr><th id="304">304</th><td><i>/* Struct used for GSSAPI (Kerberos V5) authentication */</i></td></tr>
<tr><th id="305">305</th><td><u>#<span data-ppcond="305">if</span> defined(<span class="macro" data-ref="_M/USE_KERBEROS5">USE_KERBEROS5</span>)</u></td></tr>
<tr><th id="306">306</th><td><b>struct</b> kerberos5data {</td></tr>
<tr><th id="307">307</th><td><u>#if defined(USE_WINDOWS_SSPI)</u></td></tr>
<tr><th id="308">308</th><td>  CredHandle *credentials;</td></tr>
<tr><th id="309">309</th><td>  CtxtHandle *context;</td></tr>
<tr><th id="310">310</th><td>  TCHAR *spn;</td></tr>
<tr><th id="311">311</th><td>  SEC_WINNT_AUTH_IDENTITY identity;</td></tr>
<tr><th id="312">312</th><td>  SEC_WINNT_AUTH_IDENTITY *p_identity;</td></tr>
<tr><th id="313">313</th><td>  size_t token_max;</td></tr>
<tr><th id="314">314</th><td>  BYTE *output_token;</td></tr>
<tr><th id="315">315</th><td><u>#else</u></td></tr>
<tr><th id="316">316</th><td>  gss_ctx_id_t context;</td></tr>
<tr><th id="317">317</th><td>  gss_name_t spn;</td></tr>
<tr><th id="318">318</th><td><u>#endif</u></td></tr>
<tr><th id="319">319</th><td>};</td></tr>
<tr><th id="320">320</th><td><u>#<span data-ppcond="305">endif</span></u></td></tr>
<tr><th id="321">321</th><td></td></tr>
<tr><th id="322">322</th><td><i>/* Struct used for NTLM challenge-response authentication */</i></td></tr>
<tr><th id="323">323</th><td><u>#<span data-ppcond="323">if</span> defined(<a class="macro" href="curl_setup.h.html#635" data-ref="_M/USE_NTLM">USE_NTLM</a>)</u></td></tr>
<tr><th id="324">324</th><td><b>struct</b> <dfn class="type def" id="ntlmdata" title='ntlmdata' data-ref="ntlmdata">ntlmdata</dfn> {</td></tr>
<tr><th id="325">325</th><td>  <a class="typedef" href="#curlntlm" title='curlntlm' data-type='enum curlntlm' data-ref="curlntlm">curlntlm</a> <dfn class="decl" id="ntlmdata::state" title='ntlmdata::state' data-ref="ntlmdata::state">state</dfn>;</td></tr>
<tr><th id="326">326</th><td><u>#<span data-ppcond="326">ifdef</span> <span class="macro" data-ref="_M/USE_WINDOWS_SSPI">USE_WINDOWS_SSPI</span></u></td></tr>
<tr><th id="327">327</th><td>  CredHandle *credentials;</td></tr>
<tr><th id="328">328</th><td>  CtxtHandle *context;</td></tr>
<tr><th id="329">329</th><td>  SEC_WINNT_AUTH_IDENTITY identity;</td></tr>
<tr><th id="330">330</th><td>  SEC_WINNT_AUTH_IDENTITY *p_identity;</td></tr>
<tr><th id="331">331</th><td>  size_t token_max;</td></tr>
<tr><th id="332">332</th><td>  BYTE *output_token;</td></tr>
<tr><th id="333">333</th><td>  BYTE *input_token;</td></tr>
<tr><th id="334">334</th><td>  size_t input_token_len;</td></tr>
<tr><th id="335">335</th><td><u>#<span data-ppcond="326">else</span></u></td></tr>
<tr><th id="336">336</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="ntlmdata::flags" title='ntlmdata::flags' data-ref="ntlmdata::flags">flags</dfn>;</td></tr>
<tr><th id="337">337</th><td>  <em>unsigned</em> <em>char</em> <dfn class="decl" id="ntlmdata::nonce" title='ntlmdata::nonce' data-ref="ntlmdata::nonce">nonce</dfn>[<var>8</var>];</td></tr>
<tr><th id="338">338</th><td>  <em>void</em> *<dfn class="decl" id="ntlmdata::target_info" title='ntlmdata::target_info' data-ref="ntlmdata::target_info">target_info</dfn>; <i>/* TargetInfo received in the ntlm type-2 message */</i></td></tr>
<tr><th id="339">339</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="ntlmdata::target_info_len" title='ntlmdata::target_info_len' data-ref="ntlmdata::target_info_len">target_info_len</dfn>;</td></tr>
<tr><th id="340">340</th><td><u>#<span data-ppcond="326">endif</span></u></td></tr>
<tr><th id="341">341</th><td>};</td></tr>
<tr><th id="342">342</th><td><u>#<span data-ppcond="323">endif</span></u></td></tr>
<tr><th id="343">343</th><td></td></tr>
<tr><th id="344">344</th><td><u>#<span data-ppcond="344">ifdef</span> <span class="macro" data-ref="_M/USE_SPNEGO">USE_SPNEGO</span></u></td></tr>
<tr><th id="345">345</th><td><b>struct</b> negotiatedata {</td></tr>
<tr><th id="346">346</th><td>  <i>/* When doing Negotiate (SPNEGO) auth, we first need to send a token</i></td></tr>
<tr><th id="347">347</th><td><i>     and then validate the received one. */</i></td></tr>
<tr><th id="348">348</th><td>  <b>enum</b> { GSS_AUTHNONE, GSS_AUTHRECV, GSS_AUTHSENT } state;</td></tr>
<tr><th id="349">349</th><td><u>#ifdef HAVE_GSSAPI</u></td></tr>
<tr><th id="350">350</th><td>  OM_uint32 status;</td></tr>
<tr><th id="351">351</th><td>  gss_ctx_id_t context;</td></tr>
<tr><th id="352">352</th><td>  gss_name_t spn;</td></tr>
<tr><th id="353">353</th><td>  gss_buffer_desc output_token;</td></tr>
<tr><th id="354">354</th><td><u>#else</u></td></tr>
<tr><th id="355">355</th><td><u>#ifdef USE_WINDOWS_SSPI</u></td></tr>
<tr><th id="356">356</th><td>  DWORD status;</td></tr>
<tr><th id="357">357</th><td>  CredHandle *credentials;</td></tr>
<tr><th id="358">358</th><td>  CtxtHandle *context;</td></tr>
<tr><th id="359">359</th><td>  SEC_WINNT_AUTH_IDENTITY identity;</td></tr>
<tr><th id="360">360</th><td>  SEC_WINNT_AUTH_IDENTITY *p_identity;</td></tr>
<tr><th id="361">361</th><td>  TCHAR *spn;</td></tr>
<tr><th id="362">362</th><td>  size_t token_max;</td></tr>
<tr><th id="363">363</th><td>  BYTE *output_token;</td></tr>
<tr><th id="364">364</th><td>  size_t output_token_length;</td></tr>
<tr><th id="365">365</th><td><u>#endif</u></td></tr>
<tr><th id="366">366</th><td><u>#endif</u></td></tr>
<tr><th id="367">367</th><td>};</td></tr>
<tr><th id="368">368</th><td><u>#<span data-ppcond="344">endif</span></u></td></tr>
<tr><th id="369">369</th><td></td></tr>
<tr><th id="370">370</th><td></td></tr>
<tr><th id="371">371</th><td><i>/*</i></td></tr>
<tr><th id="372">372</th><td><i> * Boolean values that concerns this connection.</i></td></tr>
<tr><th id="373">373</th><td><i> */</i></td></tr>
<tr><th id="374">374</th><td><b>struct</b> <dfn class="type def" id="ConnectBits" title='ConnectBits' data-ref="ConnectBits">ConnectBits</dfn> {</td></tr>
<tr><th id="375">375</th><td>  <i>/* always modify bits.close with the connclose() and connkeep() macros! */</i></td></tr>
<tr><th id="376">376</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::close" title='ConnectBits::close' data-ref="ConnectBits::close">close</dfn>; <i>/* if set, we close the connection after this request */</i></td></tr>
<tr><th id="377">377</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::reuse" title='ConnectBits::reuse' data-ref="ConnectBits::reuse">reuse</dfn>; <i>/* if set, this is a re-used connection */</i></td></tr>
<tr><th id="378">378</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::conn_to_host" title='ConnectBits::conn_to_host' data-ref="ConnectBits::conn_to_host">conn_to_host</dfn>; <i>/* if set, this connection has a "connect to host"</i></td></tr>
<tr><th id="379">379</th><td><i>                        that overrides the host in the URL */</i></td></tr>
<tr><th id="380">380</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::conn_to_port" title='ConnectBits::conn_to_port' data-ref="ConnectBits::conn_to_port">conn_to_port</dfn>; <i>/* if set, this connection has a "connect to port"</i></td></tr>
<tr><th id="381">381</th><td><i>                        that overrides the port in the URL (remote port) */</i></td></tr>
<tr><th id="382">382</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::proxy" title='ConnectBits::proxy' data-ref="ConnectBits::proxy">proxy</dfn>; <i>/* if set, this transfer is done through a proxy - any type */</i></td></tr>
<tr><th id="383">383</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::httpproxy" title='ConnectBits::httpproxy' data-ref="ConnectBits::httpproxy">httpproxy</dfn>;    <i>/* if set, this transfer is done through a http proxy */</i></td></tr>
<tr><th id="384">384</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::socksproxy" title='ConnectBits::socksproxy' data-ref="ConnectBits::socksproxy">socksproxy</dfn>;   <i>/* if set, this transfer is done through a socks proxy */</i></td></tr>
<tr><th id="385">385</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::user_passwd" title='ConnectBits::user_passwd' data-ref="ConnectBits::user_passwd">user_passwd</dfn>;    <i>/* do we use user+password for this connection? */</i></td></tr>
<tr><th id="386">386</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::proxy_user_passwd" title='ConnectBits::proxy_user_passwd' data-ref="ConnectBits::proxy_user_passwd">proxy_user_passwd</dfn>; <i>/* user+password for the proxy? */</i></td></tr>
<tr><th id="387">387</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::ipv6_ip" title='ConnectBits::ipv6_ip' data-ref="ConnectBits::ipv6_ip">ipv6_ip</dfn>; <i>/* we communicate with a remote site specified with pure IPv6</i></td></tr>
<tr><th id="388">388</th><td><i>                   IP address */</i></td></tr>
<tr><th id="389">389</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::ipv6" title='ConnectBits::ipv6' data-ref="ConnectBits::ipv6">ipv6</dfn>;    <i>/* we communicate with a site using an IPv6 address */</i></td></tr>
<tr><th id="390">390</th><td></td></tr>
<tr><th id="391">391</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::do_more" title='ConnectBits::do_more' data-ref="ConnectBits::do_more">do_more</dfn>; <i>/* this is set TRUE if the -&gt;curl_do_more() function is</i></td></tr>
<tr><th id="392">392</th><td><i>                   supposed to be called, after -&gt;curl_do() */</i></td></tr>
<tr><th id="393">393</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::tcpconnect" title='ConnectBits::tcpconnect' data-ref="ConnectBits::tcpconnect">tcpconnect</dfn>[<var>2</var>]; <i>/* the TCP layer (or similar) is connected, this is set</i></td></tr>
<tr><th id="394">394</th><td><i>                         the first time on the first connect function call */</i></td></tr>
<tr><th id="395">395</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::protoconnstart" title='ConnectBits::protoconnstart' data-ref="ConnectBits::protoconnstart">protoconnstart</dfn>;<i>/* the protocol layer has STARTED its operation after</i></td></tr>
<tr><th id="396">396</th><td><i>                         the TCP layer connect */</i></td></tr>
<tr><th id="397">397</th><td></td></tr>
<tr><th id="398">398</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::retry" title='ConnectBits::retry' data-ref="ConnectBits::retry">retry</dfn>;         <i>/* this connection is about to get closed and then</i></td></tr>
<tr><th id="399">399</th><td><i>                         re-attempted at another connection. */</i></td></tr>
<tr><th id="400">400</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::tunnel_proxy" title='ConnectBits::tunnel_proxy' data-ref="ConnectBits::tunnel_proxy">tunnel_proxy</dfn>;  <i>/* if CONNECT is used to "tunnel" through the proxy.</i></td></tr>
<tr><th id="401">401</th><td><i>                         This is implicit when SSL-protocols are used through</i></td></tr>
<tr><th id="402">402</th><td><i>                         proxies, but can also be enabled explicitly by</i></td></tr>
<tr><th id="403">403</th><td><i>                         apps */</i></td></tr>
<tr><th id="404">404</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::authneg" title='ConnectBits::authneg' data-ref="ConnectBits::authneg">authneg</dfn>;       <i>/* TRUE when the auth phase has started, which means</i></td></tr>
<tr><th id="405">405</th><td><i>                         that we are creating a request with an auth header,</i></td></tr>
<tr><th id="406">406</th><td><i>                         but it is not the final request in the auth</i></td></tr>
<tr><th id="407">407</th><td><i>                         negotiation. */</i></td></tr>
<tr><th id="408">408</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::rewindaftersend" title='ConnectBits::rewindaftersend' data-ref="ConnectBits::rewindaftersend">rewindaftersend</dfn>;<i>/* TRUE when the sending couldn't be stopped even</i></td></tr>
<tr><th id="409">409</th><td><i>                          though it will be discarded. When the whole send</i></td></tr>
<tr><th id="410">410</th><td><i>                          operation is done, we must call the data rewind</i></td></tr>
<tr><th id="411">411</th><td><i>                          callback. */</i></td></tr>
<tr><th id="412">412</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::ftp_use_epsv" title='ConnectBits::ftp_use_epsv' data-ref="ConnectBits::ftp_use_epsv">ftp_use_epsv</dfn>;  <i>/* As set with CURLOPT_FTP_USE_EPSV, but if we find out</i></td></tr>
<tr><th id="413">413</th><td><i>                         EPSV doesn't work we disable it for the forthcoming</i></td></tr>
<tr><th id="414">414</th><td><i>                         requests */</i></td></tr>
<tr><th id="415">415</th><td></td></tr>
<tr><th id="416">416</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::ftp_use_eprt" title='ConnectBits::ftp_use_eprt' data-ref="ConnectBits::ftp_use_eprt">ftp_use_eprt</dfn>;  <i>/* As set with CURLOPT_FTP_USE_EPRT, but if we find out</i></td></tr>
<tr><th id="417">417</th><td><i>                         EPRT doesn't work we disable it for the forthcoming</i></td></tr>
<tr><th id="418">418</th><td><i>                         requests */</i></td></tr>
<tr><th id="419">419</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::ftp_use_data_ssl" title='ConnectBits::ftp_use_data_ssl' data-ref="ConnectBits::ftp_use_data_ssl">ftp_use_data_ssl</dfn>; <i>/* Enabled SSL for the data connection */</i></td></tr>
<tr><th id="420">420</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::netrc" title='ConnectBits::netrc' data-ref="ConnectBits::netrc">netrc</dfn>;         <i>/* name+password provided by netrc */</i></td></tr>
<tr><th id="421">421</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::userpwd_in_url" title='ConnectBits::userpwd_in_url' data-ref="ConnectBits::userpwd_in_url">userpwd_in_url</dfn>; <i>/* name+password found in url */</i></td></tr>
<tr><th id="422">422</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::stream_was_rewound" title='ConnectBits::stream_was_rewound' data-ref="ConnectBits::stream_was_rewound">stream_was_rewound</dfn>; <i>/* Indicates that the stream was rewound after a</i></td></tr>
<tr><th id="423">423</th><td><i>                              request read past the end of its response byte</i></td></tr>
<tr><th id="424">424</th><td><i>                              boundary */</i></td></tr>
<tr><th id="425">425</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::proxy_connect_closed" title='ConnectBits::proxy_connect_closed' data-ref="ConnectBits::proxy_connect_closed">proxy_connect_closed</dfn>; <i>/* set true if a proxy disconnected the</i></td></tr>
<tr><th id="426">426</th><td><i>                                connection in a CONNECT request with auth, so</i></td></tr>
<tr><th id="427">427</th><td><i>                                that libcurl should reconnect and continue. */</i></td></tr>
<tr><th id="428">428</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::bound" title='ConnectBits::bound' data-ref="ConnectBits::bound">bound</dfn>; <i>/* set true if bind() has already been done on this socket/</i></td></tr>
<tr><th id="429">429</th><td><i>                 connection */</i></td></tr>
<tr><th id="430">430</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::type_set" title='ConnectBits::type_set' data-ref="ConnectBits::type_set">type_set</dfn>;  <i>/* type= was used in the URL */</i></td></tr>
<tr><th id="431">431</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::multiplex" title='ConnectBits::multiplex' data-ref="ConnectBits::multiplex">multiplex</dfn>; <i>/* connection is multiplexed */</i></td></tr>
<tr><th id="432">432</th><td></td></tr>
<tr><th id="433">433</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::tcp_fastopen" title='ConnectBits::tcp_fastopen' data-ref="ConnectBits::tcp_fastopen">tcp_fastopen</dfn>; <i>/* use TCP Fast Open */</i></td></tr>
<tr><th id="434">434</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::tls_enable_npn" title='ConnectBits::tls_enable_npn' data-ref="ConnectBits::tls_enable_npn">tls_enable_npn</dfn>;  <i>/* TLS NPN extension? */</i></td></tr>
<tr><th id="435">435</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::tls_enable_alpn" title='ConnectBits::tls_enable_alpn' data-ref="ConnectBits::tls_enable_alpn">tls_enable_alpn</dfn>; <i>/* TLS ALPN extension? */</i></td></tr>
<tr><th id="436">436</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::proxy_ssl_connected" title='ConnectBits::proxy_ssl_connected' data-ref="ConnectBits::proxy_ssl_connected">proxy_ssl_connected</dfn>[<var>2</var>]; <i>/* TRUE when SSL initialization for HTTPS proxy</i></td></tr>
<tr><th id="437">437</th><td><i>                                  is complete */</i></td></tr>
<tr><th id="438">438</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="ConnectBits::socksproxy_connecting" title='ConnectBits::socksproxy_connecting' data-ref="ConnectBits::socksproxy_connecting">socksproxy_connecting</dfn>; <i>/* connecting through a socks proxy */</i></td></tr>
<tr><th id="439">439</th><td>};</td></tr>
<tr><th id="440">440</th><td></td></tr>
<tr><th id="441">441</th><td><b>struct</b> <dfn class="type def" id="hostname" title='hostname' data-ref="hostname">hostname</dfn> {</td></tr>
<tr><th id="442">442</th><td>  <em>char</em> *<dfn class="decl" id="hostname::rawalloc" title='hostname::rawalloc' data-ref="hostname::rawalloc">rawalloc</dfn>; <i>/* allocated "raw" version of the name */</i></td></tr>
<tr><th id="443">443</th><td>  <em>char</em> *<dfn class="decl" id="hostname::encalloc" title='hostname::encalloc' data-ref="hostname::encalloc">encalloc</dfn>; <i>/* allocated IDN-encoded version of the name */</i></td></tr>
<tr><th id="444">444</th><td>  <em>char</em> *<dfn class="decl" id="hostname::name" title='hostname::name' data-ref="hostname::name">name</dfn>;     <i>/* name to use internally, might be encoded, might be raw */</i></td></tr>
<tr><th id="445">445</th><td>  <em>const</em> <em>char</em> *<dfn class="decl" id="hostname::dispname" title='hostname::dispname' data-ref="hostname::dispname">dispname</dfn>; <i>/* name to display, as 'name' might be encoded */</i></td></tr>
<tr><th id="446">446</th><td>};</td></tr>
<tr><th id="447">447</th><td></td></tr>
<tr><th id="448">448</th><td><i>/*</i></td></tr>
<tr><th id="449">449</th><td><i> * Flags on the keepon member of the Curl_transfer_keeper</i></td></tr>
<tr><th id="450">450</th><td><i> */</i></td></tr>
<tr><th id="451">451</th><td></td></tr>
<tr><th id="452">452</th><td><u>#define <dfn class="macro" id="_M/KEEP_NONE" data-ref="_M/KEEP_NONE">KEEP_NONE</dfn>  0</u></td></tr>
<tr><th id="453">453</th><td><u>#define <dfn class="macro" id="_M/KEEP_RECV" data-ref="_M/KEEP_RECV">KEEP_RECV</dfn>  (1&lt;&lt;0)     /* there is or may be data to read */</u></td></tr>
<tr><th id="454">454</th><td><u>#define <dfn class="macro" id="_M/KEEP_SEND" data-ref="_M/KEEP_SEND">KEEP_SEND</dfn> (1&lt;&lt;1)     /* there is or may be data to write */</u></td></tr>
<tr><th id="455">455</th><td><u>#define <dfn class="macro" id="_M/KEEP_RECV_HOLD" data-ref="_M/KEEP_RECV_HOLD">KEEP_RECV_HOLD</dfn> (1&lt;&lt;2) /* when set, no reading should be done but there</u></td></tr>
<tr><th id="456">456</th><td><u>                                 might still be data to read */</u></td></tr>
<tr><th id="457">457</th><td><u>#define <dfn class="macro" id="_M/KEEP_SEND_HOLD" data-ref="_M/KEEP_SEND_HOLD">KEEP_SEND_HOLD</dfn> (1&lt;&lt;3) /* when set, no writing should be done but there</u></td></tr>
<tr><th id="458">458</th><td><u>                                  might still be data to write */</u></td></tr>
<tr><th id="459">459</th><td><u>#define <dfn class="macro" id="_M/KEEP_RECV_PAUSE" data-ref="_M/KEEP_RECV_PAUSE">KEEP_RECV_PAUSE</dfn> (1&lt;&lt;4) /* reading is paused */</u></td></tr>
<tr><th id="460">460</th><td><u>#define <dfn class="macro" id="_M/KEEP_SEND_PAUSE" data-ref="_M/KEEP_SEND_PAUSE">KEEP_SEND_PAUSE</dfn> (1&lt;&lt;5) /* writing is paused */</u></td></tr>
<tr><th id="461">461</th><td></td></tr>
<tr><th id="462">462</th><td><u>#define <dfn class="macro" id="_M/KEEP_RECVBITS" data-ref="_M/KEEP_RECVBITS">KEEP_RECVBITS</dfn> (KEEP_RECV | KEEP_RECV_HOLD | KEEP_RECV_PAUSE)</u></td></tr>
<tr><th id="463">463</th><td><u>#define <dfn class="macro" id="_M/KEEP_SENDBITS" data-ref="_M/KEEP_SENDBITS">KEEP_SENDBITS</dfn> (KEEP_SEND | KEEP_SEND_HOLD | KEEP_SEND_PAUSE)</u></td></tr>
<tr><th id="464">464</th><td></td></tr>
<tr><th id="465">465</th><td></td></tr>
<tr><th id="466">466</th><td><u>#<span data-ppcond="466">ifdef</span> <a class="macro" href="curl_config.h.html#399" data-ref="_M/HAVE_LIBZ">HAVE_LIBZ</a></u></td></tr>
<tr><th id="467">467</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="468">468</th><td>  <dfn class="enum" id="ZLIB_UNINIT" title='ZLIB_UNINIT' data-ref="ZLIB_UNINIT">ZLIB_UNINIT</dfn>,          <i>/* uninitialized */</i></td></tr>
<tr><th id="469">469</th><td>  <dfn class="enum" id="ZLIB_INIT" title='ZLIB_INIT' data-ref="ZLIB_INIT">ZLIB_INIT</dfn>,            <i>/* initialized */</i></td></tr>
<tr><th id="470">470</th><td>  <dfn class="enum" id="ZLIB_GZIP_HEADER" title='ZLIB_GZIP_HEADER' data-ref="ZLIB_GZIP_HEADER">ZLIB_GZIP_HEADER</dfn>,     <i>/* reading gzip header */</i></td></tr>
<tr><th id="471">471</th><td>  <dfn class="enum" id="ZLIB_GZIP_INFLATING" title='ZLIB_GZIP_INFLATING' data-ref="ZLIB_GZIP_INFLATING">ZLIB_GZIP_INFLATING</dfn>,  <i>/* inflating gzip stream */</i></td></tr>
<tr><th id="472">472</th><td>  <dfn class="enum" id="ZLIB_INIT_GZIP" title='ZLIB_INIT_GZIP' data-ref="ZLIB_INIT_GZIP">ZLIB_INIT_GZIP</dfn>        <i>/* initialized in transparent gzip mode */</i></td></tr>
<tr><th id="473">473</th><td>} <dfn class="typedef" id="zlibInitState" title='zlibInitState' data-type='enum zlibInitState' data-ref="zlibInitState">zlibInitState</dfn>;</td></tr>
<tr><th id="474">474</th><td><u>#<span data-ppcond="466">endif</span></u></td></tr>
<tr><th id="475">475</th><td></td></tr>
<tr><th id="476">476</th><td><u>#<span data-ppcond="476">ifdef</span> <a class="macro" href="curl_setup.h.html#534" data-ref="_M/CURLRES_ASYNCH">CURLRES_ASYNCH</a></u></td></tr>
<tr><th id="477">477</th><td><b>struct</b> <dfn class="type def" id="Curl_async" title='Curl_async' data-ref="Curl_async">Curl_async</dfn> {</td></tr>
<tr><th id="478">478</th><td>  <em>char</em> *<dfn class="decl" id="Curl_async::hostname" title='Curl_async::hostname' data-ref="Curl_async::hostname">hostname</dfn>;</td></tr>
<tr><th id="479">479</th><td>  <em>int</em> <dfn class="decl" id="Curl_async::port" title='Curl_async::port' data-ref="Curl_async::port">port</dfn>;</td></tr>
<tr><th id="480">480</th><td>  <b>struct</b> <a class="type" href="hostip.h.html#Curl_dns_entry" title='Curl_dns_entry' data-ref="Curl_dns_entry">Curl_dns_entry</a> *<dfn class="decl" id="Curl_async::dns" title='Curl_async::dns' data-ref="Curl_async::dns">dns</dfn>;</td></tr>
<tr><th id="481">481</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="Curl_async::done" title='Curl_async::done' data-ref="Curl_async::done">done</dfn>;  <i>/* set TRUE when the lookup is complete */</i></td></tr>
<tr><th id="482">482</th><td>  <em>int</em> <dfn class="decl" id="Curl_async::status" title='Curl_async::status' data-ref="Curl_async::status">status</dfn>; <i>/* if done is TRUE, this is the status from the callback */</i></td></tr>
<tr><th id="483">483</th><td>  <em>void</em> *<dfn class="decl" id="Curl_async::os_specific" title='Curl_async::os_specific' data-ref="Curl_async::os_specific">os_specific</dfn>;  <i>/* 'struct thread_data' for Windows */</i></td></tr>
<tr><th id="484">484</th><td>};</td></tr>
<tr><th id="485">485</th><td><u>#<span data-ppcond="476">endif</span></u></td></tr>
<tr><th id="486">486</th><td></td></tr>
<tr><th id="487">487</th><td><u>#define <dfn class="macro" id="_M/FIRSTSOCKET" data-ref="_M/FIRSTSOCKET">FIRSTSOCKET</dfn>     0</u></td></tr>
<tr><th id="488">488</th><td><u>#define <dfn class="macro" id="_M/SECONDARYSOCKET" data-ref="_M/SECONDARYSOCKET">SECONDARYSOCKET</dfn> 1</u></td></tr>
<tr><th id="489">489</th><td></td></tr>
<tr><th id="490">490</th><td><i>/* These function pointer types are here only to allow easier typecasting</i></td></tr>
<tr><th id="491">491</th><td><i>   within the source when we need to cast between data pointers (such as NULL)</i></td></tr>
<tr><th id="492">492</th><td><i>   and function pointers. */</i></td></tr>
<tr><th id="493">493</th><td><b>typedef</b> <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="typedef" id="Curl_do_more_func" title='Curl_do_more_func' data-type='CURLcode (*)(struct connectdata *, int *)' data-ref="Curl_do_more_func">Curl_do_more_func</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <em>int</em> *);</td></tr>
<tr><th id="494">494</th><td><b>typedef</b> <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="typedef" id="Curl_done_func" title='Curl_done_func' data-type='CURLcode (*)(struct connectdata *, CURLcode, _Bool)' data-ref="Curl_done_func">Curl_done_func</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a>, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span>);</td></tr>
<tr><th id="495">495</th><td></td></tr>
<tr><th id="496">496</th><td><b>enum</b> <dfn class="type def" id="expect100" title='expect100' data-ref="expect100">expect100</dfn> {</td></tr>
<tr><th id="497">497</th><td>  <dfn class="enum" id="expect100::EXP100_SEND_DATA" title='expect100::EXP100_SEND_DATA' data-ref="expect100::EXP100_SEND_DATA">EXP100_SEND_DATA</dfn>,           <i>/* enough waiting, just send the body now */</i></td></tr>
<tr><th id="498">498</th><td>  <dfn class="enum" id="expect100::EXP100_AWAITING_CONTINUE" title='expect100::EXP100_AWAITING_CONTINUE' data-ref="expect100::EXP100_AWAITING_CONTINUE">EXP100_AWAITING_CONTINUE</dfn>,   <i>/* waiting for the 100 Continue header */</i></td></tr>
<tr><th id="499">499</th><td>  <dfn class="enum" id="expect100::EXP100_SENDING_REQUEST" title='expect100::EXP100_SENDING_REQUEST' data-ref="expect100::EXP100_SENDING_REQUEST">EXP100_SENDING_REQUEST</dfn>,     <i>/* still sending the request but will wait for</i></td></tr>
<tr><th id="500">500</th><td><i>                                 the 100 header once done with the request */</i></td></tr>
<tr><th id="501">501</th><td>  <dfn class="enum" id="expect100::EXP100_FAILED" title='expect100::EXP100_FAILED' data-ref="expect100::EXP100_FAILED">EXP100_FAILED</dfn>               <i>/* used on 417 Expectation Failed */</i></td></tr>
<tr><th id="502">502</th><td>};</td></tr>
<tr><th id="503">503</th><td></td></tr>
<tr><th id="504">504</th><td><b>enum</b> <dfn class="type def" id="upgrade101" title='upgrade101' data-ref="upgrade101">upgrade101</dfn> {</td></tr>
<tr><th id="505">505</th><td>  <dfn class="enum" id="upgrade101::UPGR101_INIT" title='upgrade101::UPGR101_INIT' data-ref="upgrade101::UPGR101_INIT">UPGR101_INIT</dfn>,               <i>/* default state */</i></td></tr>
<tr><th id="506">506</th><td>  <dfn class="enum" id="upgrade101::UPGR101_REQUESTED" title='upgrade101::UPGR101_REQUESTED' data-ref="upgrade101::UPGR101_REQUESTED">UPGR101_REQUESTED</dfn>,          <i>/* upgrade requested */</i></td></tr>
<tr><th id="507">507</th><td>  <dfn class="enum" id="upgrade101::UPGR101_RECEIVED" title='upgrade101::UPGR101_RECEIVED' data-ref="upgrade101::UPGR101_RECEIVED">UPGR101_RECEIVED</dfn>,           <i>/* response received */</i></td></tr>
<tr><th id="508">508</th><td>  <dfn class="enum" id="upgrade101::UPGR101_WORKING" title='upgrade101::UPGR101_WORKING' data-ref="upgrade101::UPGR101_WORKING">UPGR101_WORKING</dfn>             <i>/* talking upgraded protocol */</i></td></tr>
<tr><th id="509">509</th><td>};</td></tr>
<tr><th id="510">510</th><td></td></tr>
<tr><th id="511">511</th><td><i>/*</i></td></tr>
<tr><th id="512">512</th><td><i> * Request specific data in the easy handle (Curl_easy).  Previously,</i></td></tr>
<tr><th id="513">513</th><td><i> * these members were on the connectdata struct but since a conn struct may</i></td></tr>
<tr><th id="514">514</th><td><i> * now be shared between different Curl_easys, we store connection-specific</i></td></tr>
<tr><th id="515">515</th><td><i> * data here. This struct only keeps stuff that's interesting for *this*</i></td></tr>
<tr><th id="516">516</th><td><i> * request, as it will be cleared between multiple ones</i></td></tr>
<tr><th id="517">517</th><td><i> */</i></td></tr>
<tr><th id="518">518</th><td><b>struct</b> <dfn class="type def" id="SingleRequest" title='SingleRequest' data-ref="SingleRequest">SingleRequest</dfn> {</td></tr>
<tr><th id="519">519</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="SingleRequest::size" title='SingleRequest::size' data-ref="SingleRequest::size">size</dfn>;        <i>/* -1 if unknown at this point */</i></td></tr>
<tr><th id="520">520</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> *<dfn class="decl" id="SingleRequest::bytecountp" title='SingleRequest::bytecountp' data-ref="SingleRequest::bytecountp">bytecountp</dfn>; <i>/* return number of bytes read or NULL */</i></td></tr>
<tr><th id="521">521</th><td></td></tr>
<tr><th id="522">522</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="SingleRequest::maxdownload" title='SingleRequest::maxdownload' data-ref="SingleRequest::maxdownload">maxdownload</dfn>; <i>/* in bytes, the maximum amount of data to fetch,</i></td></tr>
<tr><th id="523">523</th><td><i>                             -1 means unlimited */</i></td></tr>
<tr><th id="524">524</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> *<dfn class="decl" id="SingleRequest::writebytecountp" title='SingleRequest::writebytecountp' data-ref="SingleRequest::writebytecountp">writebytecountp</dfn>; <i>/* return number of bytes written or NULL */</i></td></tr>
<tr><th id="525">525</th><td></td></tr>
<tr><th id="526">526</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="SingleRequest::bytecount" title='SingleRequest::bytecount' data-ref="SingleRequest::bytecount">bytecount</dfn>;         <i>/* total number of bytes read */</i></td></tr>
<tr><th id="527">527</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="SingleRequest::writebytecount" title='SingleRequest::writebytecount' data-ref="SingleRequest::writebytecount">writebytecount</dfn>;    <i>/* number of bytes written */</i></td></tr>
<tr><th id="528">528</th><td></td></tr>
<tr><th id="529">529</th><td>  <em>long</em> <dfn class="decl" id="SingleRequest::headerbytecount" title='SingleRequest::headerbytecount' data-ref="SingleRequest::headerbytecount">headerbytecount</dfn>;         <i>/* only count received headers */</i></td></tr>
<tr><th id="530">530</th><td>  <em>long</em> <dfn class="decl" id="SingleRequest::deductheadercount" title='SingleRequest::deductheadercount' data-ref="SingleRequest::deductheadercount">deductheadercount</dfn>; <i>/* this amount of bytes doesn't count when we check</i></td></tr>
<tr><th id="531">531</th><td><i>                             if anything has been transferred at the end of a</i></td></tr>
<tr><th id="532">532</th><td><i>                             connection. We use this counter to make only a</i></td></tr>
<tr><th id="533">533</th><td><i>                             100 reply (without a following second response</i></td></tr>
<tr><th id="534">534</th><td><i>                             code) result in a CURLE_GOT_NOTHING error code */</i></td></tr>
<tr><th id="535">535</th><td></td></tr>
<tr><th id="536">536</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="SingleRequest::start" title='SingleRequest::start' data-ref="SingleRequest::start">start</dfn>;         <i>/* transfer started at this time */</i></td></tr>
<tr><th id="537">537</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="SingleRequest::now" title='SingleRequest::now' data-ref="SingleRequest::now">now</dfn>;           <i>/* current time */</i></td></tr>
<tr><th id="538">538</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::header" title='SingleRequest::header' data-ref="SingleRequest::header">header</dfn>;                  <i>/* incoming data has HTTP header */</i></td></tr>
<tr><th id="539">539</th><td>  <b>enum</b> {</td></tr>
<tr><th id="540">540</th><td>    <dfn class="enum" id="SingleRequest::HEADER_NORMAL" title='SingleRequest::HEADER_NORMAL' data-ref="SingleRequest::HEADER_NORMAL">HEADER_NORMAL</dfn>,              <i>/* no bad header at all */</i></td></tr>
<tr><th id="541">541</th><td>    <dfn class="enum" id="SingleRequest::HEADER_PARTHEADER" title='SingleRequest::HEADER_PARTHEADER' data-ref="SingleRequest::HEADER_PARTHEADER">HEADER_PARTHEADER</dfn>,          <i>/* part of the chunk is a bad header, the rest</i></td></tr>
<tr><th id="542">542</th><td><i>                                   is normal data */</i></td></tr>
<tr><th id="543">543</th><td>    <dfn class="enum" id="SingleRequest::HEADER_ALLBAD" title='SingleRequest::HEADER_ALLBAD' data-ref="SingleRequest::HEADER_ALLBAD">HEADER_ALLBAD</dfn>               <i>/* all was believed to be header */</i></td></tr>
<tr><th id="544">544</th><td>  } <dfn class="decl" id="SingleRequest::badheader" title='SingleRequest::badheader' data-ref="SingleRequest::badheader">badheader</dfn>;                  <i>/* the header was deemed bad and will be</i></td></tr>
<tr><th id="545">545</th><td><i>                                   written as body */</i></td></tr>
<tr><th id="546">546</th><td>  <em>int</em> <dfn class="decl" id="SingleRequest::headerline" title='SingleRequest::headerline' data-ref="SingleRequest::headerline">headerline</dfn>;               <i>/* counts header lines to better track the</i></td></tr>
<tr><th id="547">547</th><td><i>                                   first one */</i></td></tr>
<tr><th id="548">548</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::hbufp" title='SingleRequest::hbufp' data-ref="SingleRequest::hbufp">hbufp</dfn>;                  <i>/* points at *end* of header line */</i></td></tr>
<tr><th id="549">549</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="SingleRequest::hbuflen" title='SingleRequest::hbuflen' data-ref="SingleRequest::hbuflen">hbuflen</dfn>;</td></tr>
<tr><th id="550">550</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::str" title='SingleRequest::str' data-ref="SingleRequest::str">str</dfn>;                    <i>/* within buf */</i></td></tr>
<tr><th id="551">551</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::str_start" title='SingleRequest::str_start' data-ref="SingleRequest::str_start">str_start</dfn>;              <i>/* within buf */</i></td></tr>
<tr><th id="552">552</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::end_ptr" title='SingleRequest::end_ptr' data-ref="SingleRequest::end_ptr">end_ptr</dfn>;                <i>/* within buf */</i></td></tr>
<tr><th id="553">553</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::p" title='SingleRequest::p' data-ref="SingleRequest::p">p</dfn>;                      <i>/* within headerbuff */</i></td></tr>
<tr><th id="554">554</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::content_range" title='SingleRequest::content_range' data-ref="SingleRequest::content_range">content_range</dfn>;           <i>/* set TRUE if Content-Range: was found */</i></td></tr>
<tr><th id="555">555</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="SingleRequest::offset" title='SingleRequest::offset' data-ref="SingleRequest::offset">offset</dfn>;            <i>/* possible resume offset read from the</i></td></tr>
<tr><th id="556">556</th><td><i>                                   Content-Range: header */</i></td></tr>
<tr><th id="557">557</th><td>  <em>int</em> <dfn class="decl" id="SingleRequest::httpcode" title='SingleRequest::httpcode' data-ref="SingleRequest::httpcode">httpcode</dfn>;                 <i>/* error code from the 'HTTP/1.? XXX' or</i></td></tr>
<tr><th id="558">558</th><td><i>                                   'RTSP/1.? XXX' line */</i></td></tr>
<tr><th id="559">559</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="SingleRequest::start100" title='SingleRequest::start100' data-ref="SingleRequest::start100">start100</dfn>;      <i>/* time stamp to wait for the 100 code from */</i></td></tr>
<tr><th id="560">560</th><td>  <b>enum</b> <a class="type" href="#expect100" title='expect100' data-ref="expect100">expect100</a> <dfn class="decl" id="SingleRequest::exp100" title='SingleRequest::exp100' data-ref="SingleRequest::exp100">exp100</dfn>;        <i>/* expect 100 continue state */</i></td></tr>
<tr><th id="561">561</th><td>  <b>enum</b> <a class="type" href="#upgrade101" title='upgrade101' data-ref="upgrade101">upgrade101</a> <dfn class="decl" id="SingleRequest::upgr101" title='SingleRequest::upgr101' data-ref="SingleRequest::upgr101">upgr101</dfn>;      <i>/* 101 upgrade state */</i></td></tr>
<tr><th id="562">562</th><td></td></tr>
<tr><th id="563">563</th><td>  <em>int</em> <dfn class="decl" id="SingleRequest::auto_decoding" title='SingleRequest::auto_decoding' data-ref="SingleRequest::auto_decoding">auto_decoding</dfn>;            <i>/* What content encoding. sec 3.5, RFC2616. */</i></td></tr>
<tr><th id="564">564</th><td></td></tr>
<tr><th id="565">565</th><td><u>#define <dfn class="macro" id="_M/IDENTITY" data-ref="_M/IDENTITY">IDENTITY</dfn> 0              /* No encoding */</u></td></tr>
<tr><th id="566">566</th><td><u>#define <dfn class="macro" id="_M/DEFLATE" data-ref="_M/DEFLATE">DEFLATE</dfn> 1               /* zlib deflate [RFC 1950 &amp; 1951] */</u></td></tr>
<tr><th id="567">567</th><td><u>#define <dfn class="macro" id="_M/GZIP" data-ref="_M/GZIP">GZIP</dfn> 2                  /* gzip algorithm [RFC 1952] */</u></td></tr>
<tr><th id="568">568</th><td></td></tr>
<tr><th id="569">569</th><td><u>#<span data-ppcond="569">ifdef</span> <a class="macro" href="curl_config.h.html#399" data-ref="_M/HAVE_LIBZ">HAVE_LIBZ</a></u></td></tr>
<tr><th id="570">570</th><td>  <a class="typedef" href="#zlibInitState" title='zlibInitState' data-type='enum zlibInitState' data-ref="zlibInitState">zlibInitState</a> <dfn class="decl" id="SingleRequest::zlib_init" title='SingleRequest::zlib_init' data-ref="SingleRequest::zlib_init">zlib_init</dfn>;      <i>/* possible zlib init state;</i></td></tr>
<tr><th id="571">571</th><td><i>                                   undefined if Content-Encoding header. */</i></td></tr>
<tr><th id="572">572</th><td>  <a class="typedef" href="../../include/zlib.h.html#z_stream" title='z_stream' data-type='struct z_stream_s' data-ref="z_stream">z_stream</a> <dfn class="decl" id="SingleRequest::z" title='SingleRequest::z' data-ref="SingleRequest::z">z</dfn>;                   <i>/* State structure for zlib. */</i></td></tr>
<tr><th id="573">573</th><td><u>#<span data-ppcond="569">endif</span></u></td></tr>
<tr><th id="574">574</th><td></td></tr>
<tr><th id="575">575</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="SingleRequest::timeofdoc" title='SingleRequest::timeofdoc' data-ref="SingleRequest::timeofdoc">timeofdoc</dfn>;</td></tr>
<tr><th id="576">576</th><td>  <em>long</em> <dfn class="decl" id="SingleRequest::bodywrites" title='SingleRequest::bodywrites' data-ref="SingleRequest::bodywrites">bodywrites</dfn>;</td></tr>
<tr><th id="577">577</th><td></td></tr>
<tr><th id="578">578</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::buf" title='SingleRequest::buf' data-ref="SingleRequest::buf">buf</dfn>;</td></tr>
<tr><th id="579">579</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="SingleRequest::maxfd" title='SingleRequest::maxfd' data-ref="SingleRequest::maxfd">maxfd</dfn>;</td></tr>
<tr><th id="580">580</th><td></td></tr>
<tr><th id="581">581</th><td>  <em>int</em> <dfn class="decl" id="SingleRequest::keepon" title='SingleRequest::keepon' data-ref="SingleRequest::keepon">keepon</dfn>;</td></tr>
<tr><th id="582">582</th><td></td></tr>
<tr><th id="583">583</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::upload_done" title='SingleRequest::upload_done' data-ref="SingleRequest::upload_done">upload_done</dfn>; <i>/* set to TRUE when doing chunked transfer-encoding upload</i></td></tr>
<tr><th id="584">584</th><td><i>                       and we're uploading the last chunk */</i></td></tr>
<tr><th id="585">585</th><td></td></tr>
<tr><th id="586">586</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::ignorebody" title='SingleRequest::ignorebody' data-ref="SingleRequest::ignorebody">ignorebody</dfn>;  <i>/* we read a response-body but we ignore it! */</i></td></tr>
<tr><th id="587">587</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::ignorecl" title='SingleRequest::ignorecl' data-ref="SingleRequest::ignorecl">ignorecl</dfn>;    <i>/* This HTTP response has no body so we ignore the Content-</i></td></tr>
<tr><th id="588">588</th><td><i>                       Length: header */</i></td></tr>
<tr><th id="589">589</th><td></td></tr>
<tr><th id="590">590</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::location" title='SingleRequest::location' data-ref="SingleRequest::location">location</dfn>;   <i>/* This points to an allocated version of the Location:</i></td></tr>
<tr><th id="591">591</th><td><i>                       header data */</i></td></tr>
<tr><th id="592">592</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::newurl" title='SingleRequest::newurl' data-ref="SingleRequest::newurl">newurl</dfn>;     <i>/* Set to the new URL to use when a redirect or a retry is</i></td></tr>
<tr><th id="593">593</th><td><i>                       wanted */</i></td></tr>
<tr><th id="594">594</th><td></td></tr>
<tr><th id="595">595</th><td>  <i>/* 'upload_present' is used to keep a byte counter of how much data there is</i></td></tr>
<tr><th id="596">596</th><td><i>     still left in the buffer, aimed for upload. */</i></td></tr>
<tr><th id="597">597</th><td>  <a class="typedef" href="../../include/x86_64-linux-gnu/sys/types.h.html#ssize_t" title='ssize_t' data-type='__ssize_t' data-ref="ssize_t">ssize_t</a> <dfn class="decl" id="SingleRequest::upload_present" title='SingleRequest::upload_present' data-ref="SingleRequest::upload_present">upload_present</dfn>;</td></tr>
<tr><th id="598">598</th><td></td></tr>
<tr><th id="599">599</th><td>   <i>/* 'upload_fromhere' is used as a read-pointer when we uploaded parts of a</i></td></tr>
<tr><th id="600">600</th><td><i>      buffer, so the next read should read from where this pointer points to,</i></td></tr>
<tr><th id="601">601</th><td><i>      and the 'upload_present' contains the number of bytes available at this</i></td></tr>
<tr><th id="602">602</th><td><i>      position */</i></td></tr>
<tr><th id="603">603</th><td>  <em>char</em> *<dfn class="decl" id="SingleRequest::upload_fromhere" title='SingleRequest::upload_fromhere' data-ref="SingleRequest::upload_fromhere">upload_fromhere</dfn>;</td></tr>
<tr><th id="604">604</th><td></td></tr>
<tr><th id="605">605</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::chunk" title='SingleRequest::chunk' data-ref="SingleRequest::chunk">chunk</dfn>; <i>/* if set, this is a chunked transfer-encoding */</i></td></tr>
<tr><th id="606">606</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::upload_chunky" title='SingleRequest::upload_chunky' data-ref="SingleRequest::upload_chunky">upload_chunky</dfn>; <i>/* set TRUE if we are doing chunked transfer-encoding</i></td></tr>
<tr><th id="607">607</th><td><i>                         on upload */</i></td></tr>
<tr><th id="608">608</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::getheader" title='SingleRequest::getheader' data-ref="SingleRequest::getheader">getheader</dfn>;     <i>/* TRUE if header parsing is wanted */</i></td></tr>
<tr><th id="609">609</th><td></td></tr>
<tr><th id="610">610</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="SingleRequest::forbidchunk" title='SingleRequest::forbidchunk' data-ref="SingleRequest::forbidchunk">forbidchunk</dfn>;   <i>/* used only to explicitly forbid chunk-upload for</i></td></tr>
<tr><th id="611">611</th><td><i>                         specific upload buffers. See readmoredata() in</i></td></tr>
<tr><th id="612">612</th><td><i>                         http.c for details. */</i></td></tr>
<tr><th id="613">613</th><td></td></tr>
<tr><th id="614">614</th><td>  <em>void</em> *<dfn class="decl" id="SingleRequest::protop" title='SingleRequest::protop' data-ref="SingleRequest::protop">protop</dfn>;       <i>/* Allocated protocol-specific data. Each protocol</i></td></tr>
<tr><th id="615">615</th><td><i>                         handler makes sure this points to data it needs. */</i></td></tr>
<tr><th id="616">616</th><td>};</td></tr>
<tr><th id="617">617</th><td></td></tr>
<tr><th id="618">618</th><td><i>/*</i></td></tr>
<tr><th id="619">619</th><td><i> * Specific protocol handler.</i></td></tr>
<tr><th id="620">620</th><td><i> */</i></td></tr>
<tr><th id="621">621</th><td></td></tr>
<tr><th id="622">622</th><td><b>struct</b> <dfn class="type def" id="Curl_handler" title='Curl_handler' data-ref="Curl_handler">Curl_handler</dfn> {</td></tr>
<tr><th id="623">623</th><td>  <em>const</em> <em>char</em> *<dfn class="decl" id="Curl_handler::scheme" title='Curl_handler::scheme' data-ref="Curl_handler::scheme">scheme</dfn>;        <i>/* URL scheme name. */</i></td></tr>
<tr><th id="624">624</th><td></td></tr>
<tr><th id="625">625</th><td>  <i>/* Complement to setup_connection_internals(). */</i></td></tr>
<tr><th id="626">626</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::setup_connection" title='Curl_handler::setup_connection' data-ref="Curl_handler::setup_connection">setup_connection</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="627">627</th><td></td></tr>
<tr><th id="628">628</th><td>  <i>/* These two functions MUST be set to be protocol dependent */</i></td></tr>
<tr><th id="629">629</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::do_it" title='Curl_handler::do_it' data-ref="Curl_handler::do_it">do_it</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> *<dfn class="local col6 decl" id="656done" title='done' data-type='_Bool *' data-ref="656done">done</dfn>);</td></tr>
<tr><th id="630">630</th><td>  <a class="typedef" href="#Curl_done_func" title='Curl_done_func' data-type='CURLcode (*)(struct connectdata *, CURLcode, _Bool)' data-ref="Curl_done_func">Curl_done_func</a> <dfn class="decl" id="Curl_handler::done" title='Curl_handler::done' data-ref="Curl_handler::done">done</dfn>;</td></tr>
<tr><th id="631">631</th><td></td></tr>
<tr><th id="632">632</th><td>  <i>/* If the curl_do() function is better made in two halves, this</i></td></tr>
<tr><th id="633">633</th><td><i>   * curl_do_more() function will be called afterwards, if set. For example</i></td></tr>
<tr><th id="634">634</th><td><i>   * for doing the FTP stuff after the PASV/PORT command.</i></td></tr>
<tr><th id="635">635</th><td><i>   */</i></td></tr>
<tr><th id="636">636</th><td>  <a class="typedef" href="#Curl_do_more_func" title='Curl_do_more_func' data-type='CURLcode (*)(struct connectdata *, int *)' data-ref="Curl_do_more_func">Curl_do_more_func</a> <dfn class="decl" id="Curl_handler::do_more" title='Curl_handler::do_more' data-ref="Curl_handler::do_more">do_more</dfn>;</td></tr>
<tr><th id="637">637</th><td></td></tr>
<tr><th id="638">638</th><td>  <i>/* This function *MAY* be set to a protocol-dependent function that is run</i></td></tr>
<tr><th id="639">639</th><td><i>   * after the connect() and everything is done, as a step in the connection.</i></td></tr>
<tr><th id="640">640</th><td><i>   * The 'done' pointer points to a bool that should be set to TRUE if the</i></td></tr>
<tr><th id="641">641</th><td><i>   * function completes before return. If it doesn't complete, the caller</i></td></tr>
<tr><th id="642">642</th><td><i>   * should call the curl_connecting() function until it is.</i></td></tr>
<tr><th id="643">643</th><td><i>   */</i></td></tr>
<tr><th id="644">644</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::connect_it" title='Curl_handler::connect_it' data-ref="Curl_handler::connect_it">connect_it</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> *<dfn class="local col7 decl" id="657done" title='done' data-type='_Bool *' data-ref="657done">done</dfn>);</td></tr>
<tr><th id="645">645</th><td></td></tr>
<tr><th id="646">646</th><td>  <i>/* See above. Currently only used for FTP. */</i></td></tr>
<tr><th id="647">647</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::connecting" title='Curl_handler::connecting' data-ref="Curl_handler::connecting">connecting</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> *<dfn class="local col8 decl" id="658done" title='done' data-type='_Bool *' data-ref="658done">done</dfn>);</td></tr>
<tr><th id="648">648</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::doing" title='Curl_handler::doing' data-ref="Curl_handler::doing">doing</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> *<dfn class="local col9 decl" id="659done" title='done' data-type='_Bool *' data-ref="659done">done</dfn>);</td></tr>
<tr><th id="649">649</th><td></td></tr>
<tr><th id="650">650</th><td>  <i>/* Called from the multi interface during the PROTOCONNECT phase, and it</i></td></tr>
<tr><th id="651">651</th><td><i>     should then return a proper fd set */</i></td></tr>
<tr><th id="652">652</th><td>  <em>int</em> (*<dfn class="decl" id="Curl_handler::proto_getsock" title='Curl_handler::proto_getsock' data-ref="Curl_handler::proto_getsock">proto_getsock</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col0 decl" id="660conn" title='conn' data-type='struct connectdata *' data-ref="660conn">conn</dfn>,</td></tr>
<tr><th id="653">653</th><td>                       <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> *<dfn class="local col1 decl" id="661socks" title='socks' data-type='curl_socket_t *' data-ref="661socks">socks</dfn>,</td></tr>
<tr><th id="654">654</th><td>                       <em>int</em> <dfn class="local col2 decl" id="662numsocks" title='numsocks' data-type='int' data-ref="662numsocks">numsocks</dfn>);</td></tr>
<tr><th id="655">655</th><td></td></tr>
<tr><th id="656">656</th><td>  <i>/* Called from the multi interface during the DOING phase, and it should</i></td></tr>
<tr><th id="657">657</th><td><i>     then return a proper fd set */</i></td></tr>
<tr><th id="658">658</th><td>  <em>int</em> (*<dfn class="decl" id="Curl_handler::doing_getsock" title='Curl_handler::doing_getsock' data-ref="Curl_handler::doing_getsock">doing_getsock</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col3 decl" id="663conn" title='conn' data-type='struct connectdata *' data-ref="663conn">conn</dfn>,</td></tr>
<tr><th id="659">659</th><td>                       <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> *<dfn class="local col4 decl" id="664socks" title='socks' data-type='curl_socket_t *' data-ref="664socks">socks</dfn>,</td></tr>
<tr><th id="660">660</th><td>                       <em>int</em> <dfn class="local col5 decl" id="665numsocks" title='numsocks' data-type='int' data-ref="665numsocks">numsocks</dfn>);</td></tr>
<tr><th id="661">661</th><td></td></tr>
<tr><th id="662">662</th><td>  <i>/* Called from the multi interface during the DO_MORE phase, and it should</i></td></tr>
<tr><th id="663">663</th><td><i>     then return a proper fd set */</i></td></tr>
<tr><th id="664">664</th><td>  <em>int</em> (*<dfn class="decl" id="Curl_handler::domore_getsock" title='Curl_handler::domore_getsock' data-ref="Curl_handler::domore_getsock">domore_getsock</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col6 decl" id="666conn" title='conn' data-type='struct connectdata *' data-ref="666conn">conn</dfn>,</td></tr>
<tr><th id="665">665</th><td>                        <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> *<dfn class="local col7 decl" id="667socks" title='socks' data-type='curl_socket_t *' data-ref="667socks">socks</dfn>,</td></tr>
<tr><th id="666">666</th><td>                        <em>int</em> <dfn class="local col8 decl" id="668numsocks" title='numsocks' data-type='int' data-ref="668numsocks">numsocks</dfn>);</td></tr>
<tr><th id="667">667</th><td></td></tr>
<tr><th id="668">668</th><td>  <i>/* Called from the multi interface during the DO_DONE, PERFORM and</i></td></tr>
<tr><th id="669">669</th><td><i>     WAITPERFORM phases, and it should then return a proper fd set. Not setting</i></td></tr>
<tr><th id="670">670</th><td><i>     this will make libcurl use the generic default one. */</i></td></tr>
<tr><th id="671">671</th><td>  <em>int</em> (*<dfn class="decl" id="Curl_handler::perform_getsock" title='Curl_handler::perform_getsock' data-ref="Curl_handler::perform_getsock">perform_getsock</dfn>)(<em>const</em> <b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col9 decl" id="669conn" title='conn' data-type='const struct connectdata *' data-ref="669conn">conn</dfn>,</td></tr>
<tr><th id="672">672</th><td>                         <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> *<dfn class="local col0 decl" id="670socks" title='socks' data-type='curl_socket_t *' data-ref="670socks">socks</dfn>,</td></tr>
<tr><th id="673">673</th><td>                         <em>int</em> <dfn class="local col1 decl" id="671numsocks" title='numsocks' data-type='int' data-ref="671numsocks">numsocks</dfn>);</td></tr>
<tr><th id="674">674</th><td></td></tr>
<tr><th id="675">675</th><td>  <i>/* This function *MAY* be set to a protocol-dependent function that is run</i></td></tr>
<tr><th id="676">676</th><td><i>   * by the curl_disconnect(), as a step in the disconnection.  If the handler</i></td></tr>
<tr><th id="677">677</th><td><i>   * is called because the connection has been considered dead, dead_connection</i></td></tr>
<tr><th id="678">678</th><td><i>   * is set to TRUE.</i></td></tr>
<tr><th id="679">679</th><td><i>   */</i></td></tr>
<tr><th id="680">680</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::disconnect" title='Curl_handler::disconnect' data-ref="Curl_handler::disconnect">disconnect</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="local col2 decl" id="672dead_connection" title='dead_connection' data-type='_Bool' data-ref="672dead_connection">dead_connection</dfn>);</td></tr>
<tr><th id="681">681</th><td></td></tr>
<tr><th id="682">682</th><td>  <i>/* If used, this function gets called from transfer.c:readwrite_data() to</i></td></tr>
<tr><th id="683">683</th><td><i>     allow the protocol to do extra reads/writes */</i></td></tr>
<tr><th id="684">684</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="Curl_handler::readwrite" title='Curl_handler::readwrite' data-ref="Curl_handler::readwrite">readwrite</dfn>)(<b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="local col3 decl" id="673data" title='data' data-type='struct Curl_easy *' data-ref="673data">data</dfn>, <b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col4 decl" id="674conn" title='conn' data-type='struct connectdata *' data-ref="674conn">conn</dfn>,</td></tr>
<tr><th id="685">685</th><td>                        <a class="typedef" href="../../include/x86_64-linux-gnu/sys/types.h.html#ssize_t" title='ssize_t' data-type='__ssize_t' data-ref="ssize_t">ssize_t</a> *<dfn class="local col5 decl" id="675nread" title='nread' data-type='ssize_t *' data-ref="675nread">nread</dfn>, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> *<dfn class="local col6 decl" id="676readmore" title='readmore' data-type='_Bool *' data-ref="676readmore">readmore</dfn>);</td></tr>
<tr><th id="686">686</th><td></td></tr>
<tr><th id="687">687</th><td>  <i>/* This function can perform various checks on the connection. See</i></td></tr>
<tr><th id="688">688</th><td><i>     CONNCHECK_* for more information about the checks that can be performed,</i></td></tr>
<tr><th id="689">689</th><td><i>     and CONNRESULT_* for the results that can be returned. */</i></td></tr>
<tr><th id="690">690</th><td>  <em>unsigned</em> <em>int</em> (*<dfn class="decl" id="Curl_handler::connection_check" title='Curl_handler::connection_check' data-ref="Curl_handler::connection_check">connection_check</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col7 decl" id="677conn" title='conn' data-type='struct connectdata *' data-ref="677conn">conn</dfn>,</td></tr>
<tr><th id="691">691</th><td>                                   <em>unsigned</em> <em>int</em> <dfn class="local col8 decl" id="678checks_to_perform" title='checks_to_perform' data-type='unsigned int' data-ref="678checks_to_perform">checks_to_perform</dfn>);</td></tr>
<tr><th id="692">692</th><td></td></tr>
<tr><th id="693">693</th><td>  <em>long</em> <dfn class="decl" id="Curl_handler::defport" title='Curl_handler::defport' data-ref="Curl_handler::defport">defport</dfn>;           <i>/* Default port. */</i></td></tr>
<tr><th id="694">694</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="Curl_handler::protocol" title='Curl_handler::protocol' data-ref="Curl_handler::protocol">protocol</dfn>;  <i>/* See CURLPROTO_* - this needs to be the single</i></td></tr>
<tr><th id="695">695</th><td><i>                             specific protocol bit */</i></td></tr>
<tr><th id="696">696</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="Curl_handler::flags" title='Curl_handler::flags' data-ref="Curl_handler::flags">flags</dfn>;     <i>/* Extra particular characteristics, see PROTOPT_* */</i></td></tr>
<tr><th id="697">697</th><td>};</td></tr>
<tr><th id="698">698</th><td></td></tr>
<tr><th id="699">699</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_NONE" data-ref="_M/PROTOPT_NONE">PROTOPT_NONE</dfn> 0             /* nothing extra */</u></td></tr>
<tr><th id="700">700</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_SSL" data-ref="_M/PROTOPT_SSL">PROTOPT_SSL</dfn> (1&lt;&lt;0)         /* uses SSL */</u></td></tr>
<tr><th id="701">701</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_DUAL" data-ref="_M/PROTOPT_DUAL">PROTOPT_DUAL</dfn> (1&lt;&lt;1)        /* this protocol uses two connections */</u></td></tr>
<tr><th id="702">702</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_CLOSEACTION" data-ref="_M/PROTOPT_CLOSEACTION">PROTOPT_CLOSEACTION</dfn> (1&lt;&lt;2) /* need action before socket close */</u></td></tr>
<tr><th id="703">703</th><td><i>/* some protocols will have to call the underlying functions without regard to</i></td></tr>
<tr><th id="704">704</th><td><i>   what exact state the socket signals. IE even if the socket says "readable",</i></td></tr>
<tr><th id="705">705</th><td><i>   the send function might need to be called while uploading, or vice versa.</i></td></tr>
<tr><th id="706">706</th><td><i>*/</i></td></tr>
<tr><th id="707">707</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_DIRLOCK" data-ref="_M/PROTOPT_DIRLOCK">PROTOPT_DIRLOCK</dfn> (1&lt;&lt;3)</u></td></tr>
<tr><th id="708">708</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_NONETWORK" data-ref="_M/PROTOPT_NONETWORK">PROTOPT_NONETWORK</dfn> (1&lt;&lt;4)   /* protocol doesn't use the network! */</u></td></tr>
<tr><th id="709">709</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_NEEDSPWD" data-ref="_M/PROTOPT_NEEDSPWD">PROTOPT_NEEDSPWD</dfn> (1&lt;&lt;5)    /* needs a password, and if none is set it</u></td></tr>
<tr><th id="710">710</th><td><u>                                      gets a default */</u></td></tr>
<tr><th id="711">711</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_NOURLQUERY" data-ref="_M/PROTOPT_NOURLQUERY">PROTOPT_NOURLQUERY</dfn> (1&lt;&lt;6)   /* protocol can't handle</u></td></tr>
<tr><th id="712">712</th><td><u>                                        url query strings (?foo=bar) ! */</u></td></tr>
<tr><th id="713">713</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_CREDSPERREQUEST" data-ref="_M/PROTOPT_CREDSPERREQUEST">PROTOPT_CREDSPERREQUEST</dfn> (1&lt;&lt;7) /* requires login credentials per</u></td></tr>
<tr><th id="714">714</th><td><u>                                          request instead of per connection */</u></td></tr>
<tr><th id="715">715</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_ALPN_NPN" data-ref="_M/PROTOPT_ALPN_NPN">PROTOPT_ALPN_NPN</dfn> (1&lt;&lt;8) /* set ALPN and/or NPN for this */</u></td></tr>
<tr><th id="716">716</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_STREAM" data-ref="_M/PROTOPT_STREAM">PROTOPT_STREAM</dfn> (1&lt;&lt;9) /* a protocol with individual logical streams */</u></td></tr>
<tr><th id="717">717</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_URLOPTIONS" data-ref="_M/PROTOPT_URLOPTIONS">PROTOPT_URLOPTIONS</dfn> (1&lt;&lt;10) /* allow options part in the userinfo field</u></td></tr>
<tr><th id="718">718</th><td><u>                                      of the URL */</u></td></tr>
<tr><th id="719">719</th><td><u>#define <dfn class="macro" id="_M/PROTOPT_PROXY_AS_HTTP" data-ref="_M/PROTOPT_PROXY_AS_HTTP">PROTOPT_PROXY_AS_HTTP</dfn> (1&lt;&lt;11) /* allow this non-HTTP scheme over a</u></td></tr>
<tr><th id="720">720</th><td><u>                                         HTTP proxy as HTTP proxies may know</u></td></tr>
<tr><th id="721">721</th><td><u>                                         this protocol and act as a gateway */</u></td></tr>
<tr><th id="722">722</th><td></td></tr>
<tr><th id="723">723</th><td><u>#define <dfn class="macro" id="_M/CONNCHECK_NONE" data-ref="_M/CONNCHECK_NONE">CONNCHECK_NONE</dfn> 0                 /* No checks */</u></td></tr>
<tr><th id="724">724</th><td><u>#define <dfn class="macro" id="_M/CONNCHECK_ISDEAD" data-ref="_M/CONNCHECK_ISDEAD">CONNCHECK_ISDEAD</dfn> (1&lt;&lt;0)          /* Check if the connection is dead. */</u></td></tr>
<tr><th id="725">725</th><td></td></tr>
<tr><th id="726">726</th><td><u>#define <dfn class="macro" id="_M/CONNRESULT_NONE" data-ref="_M/CONNRESULT_NONE">CONNRESULT_NONE</dfn> 0                /* No extra information. */</u></td></tr>
<tr><th id="727">727</th><td><u>#define <dfn class="macro" id="_M/CONNRESULT_DEAD" data-ref="_M/CONNRESULT_DEAD">CONNRESULT_DEAD</dfn> (1&lt;&lt;0)           /* The connection is dead. */</u></td></tr>
<tr><th id="728">728</th><td></td></tr>
<tr><th id="729">729</th><td><i>/* return the count of bytes sent, or -1 on error */</i></td></tr>
<tr><th id="730">730</th><td><b>typedef</b> <a class="typedef" href="../../include/x86_64-linux-gnu/sys/types.h.html#ssize_t" title='ssize_t' data-type='__ssize_t' data-ref="ssize_t">ssize_t</a> (<dfn class="typedef" id="Curl_send" title='Curl_send' data-type='ssize_t (struct connectdata *, int, const void *, size_t, CURLcode *)' data-ref="Curl_send">Curl_send</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col9 decl" id="679conn" title='conn' data-type='struct connectdata *' data-ref="679conn">conn</dfn>, <i>/* connection data */</i></td></tr>
<tr><th id="731">731</th><td>                            <em>int</em> <dfn class="local col0 decl" id="680sockindex" title='sockindex' data-type='int' data-ref="680sockindex">sockindex</dfn>,            <i>/* socketindex */</i></td></tr>
<tr><th id="732">732</th><td>                            <em>const</em> <em>void</em> *<dfn class="local col1 decl" id="681buf" title='buf' data-type='const void *' data-ref="681buf">buf</dfn>,          <i>/* data to write */</i></td></tr>
<tr><th id="733">733</th><td>                            <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col2 decl" id="682len" title='len' data-type='size_t' data-ref="682len">len</dfn>,               <i>/* max amount to write */</i></td></tr>
<tr><th id="734">734</th><td>                            <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> *<dfn class="local col3 decl" id="683err" title='err' data-type='CURLcode *' data-ref="683err">err</dfn>);           <i>/* error to return */</i></td></tr>
<tr><th id="735">735</th><td></td></tr>
<tr><th id="736">736</th><td><i>/* return the count of bytes read, or -1 on error */</i></td></tr>
<tr><th id="737">737</th><td><b>typedef</b> <a class="typedef" href="../../include/x86_64-linux-gnu/sys/types.h.html#ssize_t" title='ssize_t' data-type='__ssize_t' data-ref="ssize_t">ssize_t</a> (<dfn class="typedef" id="Curl_recv" title='Curl_recv' data-type='ssize_t (struct connectdata *, int, char *, size_t, CURLcode *)' data-ref="Curl_recv">Curl_recv</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="local col4 decl" id="684conn" title='conn' data-type='struct connectdata *' data-ref="684conn">conn</dfn>, <i>/* connection data */</i></td></tr>
<tr><th id="738">738</th><td>                            <em>int</em> <dfn class="local col5 decl" id="685sockindex" title='sockindex' data-type='int' data-ref="685sockindex">sockindex</dfn>,            <i>/* socketindex */</i></td></tr>
<tr><th id="739">739</th><td>                            <em>char</em> *<dfn class="local col6 decl" id="686buf" title='buf' data-type='char *' data-ref="686buf">buf</dfn>,                <i>/* store data here */</i></td></tr>
<tr><th id="740">740</th><td>                            <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col7 decl" id="687len" title='len' data-type='size_t' data-ref="687len">len</dfn>,               <i>/* max amount to read */</i></td></tr>
<tr><th id="741">741</th><td>                            <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> *<dfn class="local col8 decl" id="688err" title='err' data-type='CURLcode *' data-ref="688err">err</dfn>);           <i>/* error to return */</i></td></tr>
<tr><th id="742">742</th><td></td></tr>
<tr><th id="743">743</th><td><u>#<span data-ppcond="743">ifdef</span> <span class="macro" data-ref="_M/USE_RECV_BEFORE_SEND_WORKAROUND">USE_RECV_BEFORE_SEND_WORKAROUND</span></u></td></tr>
<tr><th id="744">744</th><td><b>struct</b> postponed_data {</td></tr>
<tr><th id="745">745</th><td>  <em>char</em> *buffer;          <i>/* Temporal store for received data during</i></td></tr>
<tr><th id="746">746</th><td><i>                            sending, must be freed */</i></td></tr>
<tr><th id="747">747</th><td>  size_t allocated_size; <i>/* Size of temporal store */</i></td></tr>
<tr><th id="748">748</th><td>  size_t recv_size;      <i>/* Size of received data during sending */</i></td></tr>
<tr><th id="749">749</th><td>  size_t recv_processed; <i>/* Size of processed part of postponed data */</i></td></tr>
<tr><th id="750">750</th><td><u>#ifdef DEBUGBUILD</u></td></tr>
<tr><th id="751">751</th><td>  curl_socket_t bindsock;<i>/* Structure must be bound to specific socket,</i></td></tr>
<tr><th id="752">752</th><td><i>                            used only for DEBUGASSERT */</i></td></tr>
<tr><th id="753">753</th><td><u>#endif /* DEBUGBUILD */</u></td></tr>
<tr><th id="754">754</th><td>};</td></tr>
<tr><th id="755">755</th><td><u>#<span data-ppcond="743">endif</span> /* USE_RECV_BEFORE_SEND_WORKAROUND */</u></td></tr>
<tr><th id="756">756</th><td></td></tr>
<tr><th id="757">757</th><td><b>struct</b> <dfn class="type def" id="proxy_info" title='proxy_info' data-ref="proxy_info">proxy_info</dfn> {</td></tr>
<tr><th id="758">758</th><td>  <b>struct</b> <a class="type" href="#hostname" title='hostname' data-ref="hostname">hostname</a> <dfn class="decl" id="proxy_info::host" title='proxy_info::host' data-ref="proxy_info::host">host</dfn>;</td></tr>
<tr><th id="759">759</th><td>  <em>long</em> <dfn class="decl" id="proxy_info::port" title='proxy_info::port' data-ref="proxy_info::port">port</dfn>;</td></tr>
<tr><th id="760">760</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_proxytype" title='curl_proxytype' data-type='enum curl_proxytype' data-ref="curl_proxytype">curl_proxytype</a> <dfn class="decl" id="proxy_info::proxytype" title='proxy_info::proxytype' data-ref="proxy_info::proxytype">proxytype</dfn>; <i>/* what kind of proxy that is in use */</i></td></tr>
<tr><th id="761">761</th><td>  <em>char</em> *<dfn class="decl" id="proxy_info::user" title='proxy_info::user' data-ref="proxy_info::user">user</dfn>;    <i>/* proxy user name string, allocated */</i></td></tr>
<tr><th id="762">762</th><td>  <em>char</em> *<dfn class="decl" id="proxy_info::passwd" title='proxy_info::passwd' data-ref="proxy_info::passwd">passwd</dfn>;  <i>/* proxy password string, allocated */</i></td></tr>
<tr><th id="763">763</th><td>};</td></tr>
<tr><th id="764">764</th><td></td></tr>
<tr><th id="765">765</th><td><u>#define <dfn class="macro" id="_M/CONNECT_BUFFER_SIZE" data-ref="_M/CONNECT_BUFFER_SIZE">CONNECT_BUFFER_SIZE</dfn> 16384</u></td></tr>
<tr><th id="766">766</th><td></td></tr>
<tr><th id="767">767</th><td><i>/* struct for HTTP CONNECT state data */</i></td></tr>
<tr><th id="768">768</th><td><b>struct</b> <dfn class="type def" id="http_connect_state" title='http_connect_state' data-ref="http_connect_state">http_connect_state</dfn> {</td></tr>
<tr><th id="769">769</th><td>  <em>char</em> <dfn class="decl" id="http_connect_state::connect_buffer" title='http_connect_state::connect_buffer' data-ref="http_connect_state::connect_buffer">connect_buffer</dfn>[<a class="macro" href="#765" title="16384" data-ref="_M/CONNECT_BUFFER_SIZE">CONNECT_BUFFER_SIZE</a>];</td></tr>
<tr><th id="770">770</th><td>  <em>int</em> <dfn class="decl" id="http_connect_state::perline" title='http_connect_state::perline' data-ref="http_connect_state::perline">perline</dfn>; <i>/* count bytes per line */</i></td></tr>
<tr><th id="771">771</th><td>  <em>int</em> <dfn class="decl" id="http_connect_state::keepon" title='http_connect_state::keepon' data-ref="http_connect_state::keepon">keepon</dfn>;</td></tr>
<tr><th id="772">772</th><td>  <em>char</em> *<dfn class="decl" id="http_connect_state::line_start" title='http_connect_state::line_start' data-ref="http_connect_state::line_start">line_start</dfn>;</td></tr>
<tr><th id="773">773</th><td>  <em>char</em> *<dfn class="decl" id="http_connect_state::ptr" title='http_connect_state::ptr' data-ref="http_connect_state::ptr">ptr</dfn>; <i>/* where to store more data */</i></td></tr>
<tr><th id="774">774</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="http_connect_state::cl" title='http_connect_state::cl' data-ref="http_connect_state::cl">cl</dfn>; <i>/* size of content to read and ignore */</i></td></tr>
<tr><th id="775">775</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="http_connect_state::chunked_encoding" title='http_connect_state::chunked_encoding' data-ref="http_connect_state::chunked_encoding">chunked_encoding</dfn>;</td></tr>
<tr><th id="776">776</th><td>  <b>enum</b> {</td></tr>
<tr><th id="777">777</th><td>    <dfn class="enum" id="http_connect_state::TUNNEL_INIT" title='http_connect_state::TUNNEL_INIT' data-ref="http_connect_state::TUNNEL_INIT">TUNNEL_INIT</dfn>,    <i>/* init/default/no tunnel state */</i></td></tr>
<tr><th id="778">778</th><td>    <dfn class="enum" id="http_connect_state::TUNNEL_CONNECT" title='http_connect_state::TUNNEL_CONNECT' data-ref="http_connect_state::TUNNEL_CONNECT">TUNNEL_CONNECT</dfn>, <i>/* CONNECT has been sent off */</i></td></tr>
<tr><th id="779">779</th><td>    <dfn class="enum" id="http_connect_state::TUNNEL_COMPLETE" title='http_connect_state::TUNNEL_COMPLETE' data-ref="http_connect_state::TUNNEL_COMPLETE">TUNNEL_COMPLETE</dfn> <i>/* CONNECT response received completely */</i></td></tr>
<tr><th id="780">780</th><td>  } <dfn class="decl" id="http_connect_state::tunnel_state" title='http_connect_state::tunnel_state' data-ref="http_connect_state::tunnel_state">tunnel_state</dfn>;</td></tr>
<tr><th id="781">781</th><td>};</td></tr>
<tr><th id="782">782</th><td></td></tr>
<tr><th id="783">783</th><td><i>/*</i></td></tr>
<tr><th id="784">784</th><td><i> * The connectdata struct contains all fields and variables that should be</i></td></tr>
<tr><th id="785">785</th><td><i> * unique for an entire connection.</i></td></tr>
<tr><th id="786">786</th><td><i> */</i></td></tr>
<tr><th id="787">787</th><td><b>struct</b> <dfn class="type def" id="connectdata" title='connectdata' data-ref="connectdata">connectdata</dfn> {</td></tr>
<tr><th id="788">788</th><td>  <i>/* 'data' is the CURRENT Curl_easy using this connection -- take great</i></td></tr>
<tr><th id="789">789</th><td><i>     caution that this might very well vary between different times this</i></td></tr>
<tr><th id="790">790</th><td><i>     connection is used! */</i></td></tr>
<tr><th id="791">791</th><td>  <b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="decl" id="connectdata::data" title='connectdata::data' data-ref="connectdata::data">data</dfn>;</td></tr>
<tr><th id="792">792</th><td></td></tr>
<tr><th id="793">793</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist_element" title='curl_llist_element' data-ref="curl_llist_element">curl_llist_element</a> <dfn class="decl" id="connectdata::bundle_node" title='connectdata::bundle_node' data-ref="connectdata::bundle_node">bundle_node</dfn>; <i>/* conncache */</i></td></tr>
<tr><th id="794">794</th><td></td></tr>
<tr><th id="795">795</th><td>  <i>/* chunk is for HTTP chunked encoding, but is in the general connectdata</i></td></tr>
<tr><th id="796">796</th><td><i>     struct only because we can do just about any protocol through a HTTP proxy</i></td></tr>
<tr><th id="797">797</th><td><i>     and a HTTP proxy may in fact respond using chunked encoding */</i></td></tr>
<tr><th id="798">798</th><td>  <b>struct</b> <a class="type" href="http_chunks.h.html#Curl_chunker" title='Curl_chunker' data-ref="Curl_chunker">Curl_chunker</a> <dfn class="decl" id="connectdata::chunk" title='connectdata::chunk' data-ref="connectdata::chunk">chunk</dfn>;</td></tr>
<tr><th id="799">799</th><td></td></tr>
<tr><th id="800">800</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_closesocket_callback" title='curl_closesocket_callback' data-type='int (*)(void *, curl_socket_t)' data-ref="curl_closesocket_callback">curl_closesocket_callback</a> <dfn class="decl" id="connectdata::fclosesocket" title='connectdata::fclosesocket' data-ref="connectdata::fclosesocket">fclosesocket</dfn>; <i>/* function closing the socket(s) */</i></td></tr>
<tr><th id="801">801</th><td>  <em>void</em> *<dfn class="decl" id="connectdata::closesocket_client" title='connectdata::closesocket_client' data-ref="connectdata::closesocket_client">closesocket_client</dfn>;</td></tr>
<tr><th id="802">802</th><td></td></tr>
<tr><th id="803">803</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="connectdata::inuse" title='connectdata::inuse' data-ref="connectdata::inuse">inuse</dfn>; <i>/* This is a marker for the connection cache logic. If this is</i></td></tr>
<tr><th id="804">804</th><td><i>                 TRUE this handle is being used by an easy handle and cannot</i></td></tr>
<tr><th id="805">805</th><td><i>                 be used by any other easy handle without careful</i></td></tr>
<tr><th id="806">806</th><td><i>                 consideration (== only for pipelining). */</i></td></tr>
<tr><th id="807">807</th><td></td></tr>
<tr><th id="808">808</th><td>  <i>/**** Fields set when inited and not modified again */</i></td></tr>
<tr><th id="809">809</th><td>  <em>long</em> <dfn class="decl" id="connectdata::connection_id" title='connectdata::connection_id' data-ref="connectdata::connection_id">connection_id</dfn>; <i>/* Contains a unique number to make it easier to</i></td></tr>
<tr><th id="810">810</th><td><i>                         track the connections in the log output */</i></td></tr>
<tr><th id="811">811</th><td></td></tr>
<tr><th id="812">812</th><td>  <i>/* 'dns_entry' is the particular host we use. This points to an entry in the</i></td></tr>
<tr><th id="813">813</th><td><i>     DNS cache and it will not get pruned while locked. It gets unlocked in</i></td></tr>
<tr><th id="814">814</th><td><i>     Curl_done(). This entry will be NULL if the connection is re-used as then</i></td></tr>
<tr><th id="815">815</th><td><i>     there is no name resolve done. */</i></td></tr>
<tr><th id="816">816</th><td>  <b>struct</b> <a class="type" href="hostip.h.html#Curl_dns_entry" title='Curl_dns_entry' data-ref="Curl_dns_entry">Curl_dns_entry</a> *<dfn class="decl" id="connectdata::dns_entry" title='connectdata::dns_entry' data-ref="connectdata::dns_entry">dns_entry</dfn>;</td></tr>
<tr><th id="817">817</th><td></td></tr>
<tr><th id="818">818</th><td>  <i>/* 'ip_addr' is the particular IP we connected to. It points to a struct</i></td></tr>
<tr><th id="819">819</th><td><i>     within the DNS cache, so this pointer is only valid as long as the DNS</i></td></tr>
<tr><th id="820">820</th><td><i>     cache entry remains locked. It gets unlocked in Curl_done() */</i></td></tr>
<tr><th id="821">821</th><td>  <a class="typedef" href="curl_addrinfo.h.html#Curl_addrinfo" title='Curl_addrinfo' data-type='struct Curl_addrinfo' data-ref="Curl_addrinfo">Curl_addrinfo</a> *<dfn class="decl" id="connectdata::ip_addr" title='connectdata::ip_addr' data-ref="connectdata::ip_addr">ip_addr</dfn>;</td></tr>
<tr><th id="822">822</th><td>  <a class="typedef" href="curl_addrinfo.h.html#Curl_addrinfo" title='Curl_addrinfo' data-type='struct Curl_addrinfo' data-ref="Curl_addrinfo">Curl_addrinfo</a> *<dfn class="decl" id="connectdata::tempaddr" title='connectdata::tempaddr' data-ref="connectdata::tempaddr">tempaddr</dfn>[<var>2</var>]; <i>/* for happy eyeballs */</i></td></tr>
<tr><th id="823">823</th><td></td></tr>
<tr><th id="824">824</th><td>  <i>/* 'ip_addr_str' is the ip_addr data as a human readable string.</i></td></tr>
<tr><th id="825">825</th><td><i>     It remains available as long as the connection does, which is longer than</i></td></tr>
<tr><th id="826">826</th><td><i>     the ip_addr itself. */</i></td></tr>
<tr><th id="827">827</th><td>  <em>char</em> <dfn class="decl" id="connectdata::ip_addr_str" title='connectdata::ip_addr_str' data-ref="connectdata::ip_addr_str">ip_addr_str</dfn>[<a class="macro" href="#75" title="sizeof(&quot;ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255&quot;)" data-ref="_M/MAX_IPADR_LEN">MAX_IPADR_LEN</a>];</td></tr>
<tr><th id="828">828</th><td></td></tr>
<tr><th id="829">829</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="connectdata::scope_id" title='connectdata::scope_id' data-ref="connectdata::scope_id">scope_id</dfn>;  <i>/* Scope id for IPv6 */</i></td></tr>
<tr><th id="830">830</th><td></td></tr>
<tr><th id="831">831</th><td>  <em>int</em> <dfn class="decl" id="connectdata::socktype" title='connectdata::socktype' data-ref="connectdata::socktype">socktype</dfn>;  <i>/* SOCK_STREAM or SOCK_DGRAM */</i></td></tr>
<tr><th id="832">832</th><td></td></tr>
<tr><th id="833">833</th><td>  <b>struct</b> <a class="type" href="#hostname" title='hostname' data-ref="hostname">hostname</a> <dfn class="decl" id="connectdata::host" title='connectdata::host' data-ref="connectdata::host">host</dfn>;</td></tr>
<tr><th id="834">834</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::secondaryhostname" title='connectdata::secondaryhostname' data-ref="connectdata::secondaryhostname">secondaryhostname</dfn>; <i>/* secondary socket host name (ftp) */</i></td></tr>
<tr><th id="835">835</th><td>  <b>struct</b> <a class="type" href="#hostname" title='hostname' data-ref="hostname">hostname</a> <dfn class="decl" id="connectdata::conn_to_host" title='connectdata::conn_to_host' data-ref="connectdata::conn_to_host">conn_to_host</dfn>; <i>/* the host to connect to. valid only if</i></td></tr>
<tr><th id="836">836</th><td><i>                                   bits.conn_to_host is set */</i></td></tr>
<tr><th id="837">837</th><td></td></tr>
<tr><th id="838">838</th><td>  <b>struct</b> <a class="type" href="#proxy_info" title='proxy_info' data-ref="proxy_info">proxy_info</a> <dfn class="decl" id="connectdata::socks_proxy" title='connectdata::socks_proxy' data-ref="connectdata::socks_proxy">socks_proxy</dfn>;</td></tr>
<tr><th id="839">839</th><td>  <b>struct</b> <a class="type" href="#proxy_info" title='proxy_info' data-ref="proxy_info">proxy_info</a> <dfn class="decl" id="connectdata::http_proxy" title='connectdata::http_proxy' data-ref="connectdata::http_proxy">http_proxy</dfn>;</td></tr>
<tr><th id="840">840</th><td></td></tr>
<tr><th id="841">841</th><td>  <em>long</em> <dfn class="decl" id="connectdata::port" title='connectdata::port' data-ref="connectdata::port">port</dfn>;       <i>/* which port to use locally */</i></td></tr>
<tr><th id="842">842</th><td>  <em>int</em> <dfn class="decl" id="connectdata::remote_port" title='connectdata::remote_port' data-ref="connectdata::remote_port">remote_port</dfn>; <i>/* the remote port, not the proxy port! */</i></td></tr>
<tr><th id="843">843</th><td>  <em>int</em> <dfn class="decl" id="connectdata::conn_to_port" title='connectdata::conn_to_port' data-ref="connectdata::conn_to_port">conn_to_port</dfn>; <i>/* the remote port to connect to. valid only if</i></td></tr>
<tr><th id="844">844</th><td><i>                       bits.conn_to_port is set */</i></td></tr>
<tr><th id="845">845</th><td>  <em>unsigned</em> <em>short</em> <dfn class="decl" id="connectdata::secondary_port" title='connectdata::secondary_port' data-ref="connectdata::secondary_port">secondary_port</dfn>; <i>/* secondary socket remote port to connect to</i></td></tr>
<tr><th id="846">846</th><td><i>                                    (ftp) */</i></td></tr>
<tr><th id="847">847</th><td></td></tr>
<tr><th id="848">848</th><td>  <i>/* 'primary_ip' and 'primary_port' get filled with peer's numerical</i></td></tr>
<tr><th id="849">849</th><td><i>     ip address and port number whenever an outgoing connection is</i></td></tr>
<tr><th id="850">850</th><td><i>     *attempted* from the primary socket to a remote address. When more</i></td></tr>
<tr><th id="851">851</th><td><i>     than one address is tried for a connection these will hold data</i></td></tr>
<tr><th id="852">852</th><td><i>     for the last attempt. When the connection is actually established</i></td></tr>
<tr><th id="853">853</th><td><i>     these are updated with data which comes directly from the socket. */</i></td></tr>
<tr><th id="854">854</th><td></td></tr>
<tr><th id="855">855</th><td>  <em>char</em> <dfn class="decl" id="connectdata::primary_ip" title='connectdata::primary_ip' data-ref="connectdata::primary_ip">primary_ip</dfn>[<a class="macro" href="#75" title="sizeof(&quot;ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255&quot;)" data-ref="_M/MAX_IPADR_LEN">MAX_IPADR_LEN</a>];</td></tr>
<tr><th id="856">856</th><td>  <em>long</em> <dfn class="decl" id="connectdata::primary_port" title='connectdata::primary_port' data-ref="connectdata::primary_port">primary_port</dfn>;</td></tr>
<tr><th id="857">857</th><td></td></tr>
<tr><th id="858">858</th><td>  <i>/* 'local_ip' and 'local_port' get filled with local's numerical</i></td></tr>
<tr><th id="859">859</th><td><i>     ip address and port number whenever an outgoing connection is</i></td></tr>
<tr><th id="860">860</th><td><i>     **established** from the primary socket to a remote address. */</i></td></tr>
<tr><th id="861">861</th><td></td></tr>
<tr><th id="862">862</th><td>  <em>char</em> <dfn class="decl" id="connectdata::local_ip" title='connectdata::local_ip' data-ref="connectdata::local_ip">local_ip</dfn>[<a class="macro" href="#75" title="sizeof(&quot;ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255&quot;)" data-ref="_M/MAX_IPADR_LEN">MAX_IPADR_LEN</a>];</td></tr>
<tr><th id="863">863</th><td>  <em>long</em> <dfn class="decl" id="connectdata::local_port" title='connectdata::local_port' data-ref="connectdata::local_port">local_port</dfn>;</td></tr>
<tr><th id="864">864</th><td></td></tr>
<tr><th id="865">865</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::user" title='connectdata::user' data-ref="connectdata::user">user</dfn>;    <i>/* user name string, allocated */</i></td></tr>
<tr><th id="866">866</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::passwd" title='connectdata::passwd' data-ref="connectdata::passwd">passwd</dfn>;  <i>/* password string, allocated */</i></td></tr>
<tr><th id="867">867</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::options" title='connectdata::options' data-ref="connectdata::options">options</dfn>; <i>/* options string, allocated */</i></td></tr>
<tr><th id="868">868</th><td></td></tr>
<tr><th id="869">869</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::oauth_bearer" title='connectdata::oauth_bearer' data-ref="connectdata::oauth_bearer">oauth_bearer</dfn>; <i>/* bearer token for OAuth 2.0, allocated */</i></td></tr>
<tr><th id="870">870</th><td></td></tr>
<tr><th id="871">871</th><td>  <em>int</em> <dfn class="decl" id="connectdata::httpversion" title='connectdata::httpversion' data-ref="connectdata::httpversion">httpversion</dfn>;        <i>/* the HTTP version*10 reported by the server */</i></td></tr>
<tr><th id="872">872</th><td>  <em>int</em> <dfn class="decl" id="connectdata::rtspversion" title='connectdata::rtspversion' data-ref="connectdata::rtspversion">rtspversion</dfn>;        <i>/* the RTSP version*10 reported by the server */</i></td></tr>
<tr><th id="873">873</th><td></td></tr>
<tr><th id="874">874</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="connectdata::now" title='connectdata::now' data-ref="connectdata::now">now</dfn>;     <i>/* "current" time */</i></td></tr>
<tr><th id="875">875</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="connectdata::created" title='connectdata::created' data-ref="connectdata::created">created</dfn>; <i>/* creation time */</i></td></tr>
<tr><th id="876">876</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::sock" title='connectdata::sock' data-ref="connectdata::sock">sock</dfn>[<var>2</var>]; <i>/* two sockets, the second is used for the data</i></td></tr>
<tr><th id="877">877</th><td><i>                            transfer when doing FTP */</i></td></tr>
<tr><th id="878">878</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::tempsock" title='connectdata::tempsock' data-ref="connectdata::tempsock">tempsock</dfn>[<var>2</var>]; <i>/* temporary sockets for happy eyeballs */</i></td></tr>
<tr><th id="879">879</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="connectdata::sock_accepted" title='connectdata::sock_accepted' data-ref="connectdata::sock_accepted">sock_accepted</dfn>[<var>2</var>]; <i>/* TRUE if the socket on this index was created with</i></td></tr>
<tr><th id="880">880</th><td><i>                            accept() */</i></td></tr>
<tr><th id="881">881</th><td>  <a class="typedef" href="#Curl_recv" title='Curl_recv' data-type='ssize_t (struct connectdata *, int, char *, size_t, CURLcode *)' data-ref="Curl_recv">Curl_recv</a> *<dfn class="decl" id="connectdata::recv" title='connectdata::recv' data-ref="connectdata::recv">recv</dfn>[<var>2</var>];</td></tr>
<tr><th id="882">882</th><td>  <a class="typedef" href="#Curl_send" title='Curl_send' data-type='ssize_t (struct connectdata *, int, const void *, size_t, CURLcode *)' data-ref="Curl_send">Curl_send</a> *<dfn class="decl" id="connectdata::send" title='connectdata::send' data-ref="connectdata::send">send</dfn>[<var>2</var>];</td></tr>
<tr><th id="883">883</th><td></td></tr>
<tr><th id="884">884</th><td><u>#<span data-ppcond="884">ifdef</span> <span class="macro" data-ref="_M/USE_RECV_BEFORE_SEND_WORKAROUND">USE_RECV_BEFORE_SEND_WORKAROUND</span></u></td></tr>
<tr><th id="885">885</th><td>  <b>struct</b> postponed_data postponed[<var>2</var>]; <i>/* two buffers for two sockets */</i></td></tr>
<tr><th id="886">886</th><td><u>#<span data-ppcond="884">endif</span> /* USE_RECV_BEFORE_SEND_WORKAROUND */</u></td></tr>
<tr><th id="887">887</th><td>  <b>struct</b> <a class="type" href="#ssl_connect_data" title='ssl_connect_data' data-ref="ssl_connect_data">ssl_connect_data</a> <dfn class="decl" id="connectdata::ssl" title='connectdata::ssl' data-ref="connectdata::ssl">ssl</dfn>[<var>2</var>]; <i>/* this is for ssl-stuff */</i></td></tr>
<tr><th id="888">888</th><td>  <b>struct</b> <a class="type" href="#ssl_connect_data" title='ssl_connect_data' data-ref="ssl_connect_data">ssl_connect_data</a> <dfn class="decl" id="connectdata::proxy_ssl" title='connectdata::proxy_ssl' data-ref="connectdata::proxy_ssl">proxy_ssl</dfn>[<var>2</var>]; <i>/* this is for proxy ssl-stuff */</i></td></tr>
<tr><th id="889">889</th><td>  <b>struct</b> <a class="type" href="#ssl_primary_config" title='ssl_primary_config' data-ref="ssl_primary_config">ssl_primary_config</a> <dfn class="decl" id="connectdata::ssl_config" title='connectdata::ssl_config' data-ref="connectdata::ssl_config">ssl_config</dfn>;</td></tr>
<tr><th id="890">890</th><td>  <b>struct</b> <a class="type" href="#ssl_primary_config" title='ssl_primary_config' data-ref="ssl_primary_config">ssl_primary_config</a> <dfn class="decl" id="connectdata::proxy_ssl_config" title='connectdata::proxy_ssl_config' data-ref="connectdata::proxy_ssl_config">proxy_ssl_config</dfn>;</td></tr>
<tr><th id="891">891</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="connectdata::tls_upgraded" title='connectdata::tls_upgraded' data-ref="connectdata::tls_upgraded">tls_upgraded</dfn>;</td></tr>
<tr><th id="892">892</th><td></td></tr>
<tr><th id="893">893</th><td>  <b>struct</b> <a class="type" href="#ConnectBits" title='ConnectBits' data-ref="ConnectBits">ConnectBits</a> <dfn class="decl" id="connectdata::bits" title='connectdata::bits' data-ref="connectdata::bits">bits</dfn>;    <i>/* various state-flags for this connection */</i></td></tr>
<tr><th id="894">894</th><td></td></tr>
<tr><th id="895">895</th><td> <i>/* connecttime: when connect() is called on the current IP address. Used to</i></td></tr>
<tr><th id="896">896</th><td><i>    be able to track when to move on to try next IP - but only when the multi</i></td></tr>
<tr><th id="897">897</th><td><i>    interface is used. */</i></td></tr>
<tr><th id="898">898</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="connectdata::connecttime" title='connectdata::connecttime' data-ref="connectdata::connecttime">connecttime</dfn>;</td></tr>
<tr><th id="899">899</th><td>  <i>/* The two fields below get set in Curl_connecthost */</i></td></tr>
<tr><th id="900">900</th><td>  <em>int</em> <dfn class="decl" id="connectdata::num_addr" title='connectdata::num_addr' data-ref="connectdata::num_addr">num_addr</dfn>; <i>/* number of addresses to try to connect to */</i></td></tr>
<tr><th id="901">901</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="connectdata::timeoutms_per_addr" title='connectdata::timeoutms_per_addr' data-ref="connectdata::timeoutms_per_addr">timeoutms_per_addr</dfn>; <i>/* how long time in milliseconds to spend on</i></td></tr>
<tr><th id="902">902</th><td><i>                                trying to connect to each IP address */</i></td></tr>
<tr><th id="903">903</th><td></td></tr>
<tr><th id="904">904</th><td>  <em>const</em> <b>struct</b> <a class="type" href="#Curl_handler" title='Curl_handler' data-ref="Curl_handler">Curl_handler</a> *<dfn class="decl" id="connectdata::handler" title='connectdata::handler' data-ref="connectdata::handler">handler</dfn>; <i>/* Connection's protocol handler */</i></td></tr>
<tr><th id="905">905</th><td>  <em>const</em> <b>struct</b> <a class="type" href="#Curl_handler" title='Curl_handler' data-ref="Curl_handler">Curl_handler</a> *<dfn class="decl" id="connectdata::given" title='connectdata::given' data-ref="connectdata::given">given</dfn>;   <i>/* The protocol first given */</i></td></tr>
<tr><th id="906">906</th><td></td></tr>
<tr><th id="907">907</th><td>  <em>long</em> <dfn class="decl" id="connectdata::ip_version" title='connectdata::ip_version' data-ref="connectdata::ip_version">ip_version</dfn>; <i>/* copied from the Curl_easy at creation time */</i></td></tr>
<tr><th id="908">908</th><td></td></tr>
<tr><th id="909">909</th><td>  <i>/**** curl_get() phase fields */</i></td></tr>
<tr><th id="910">910</th><td></td></tr>
<tr><th id="911">911</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::sockfd" title='connectdata::sockfd' data-ref="connectdata::sockfd">sockfd</dfn>;   <i>/* socket to read from or CURL_SOCKET_BAD */</i></td></tr>
<tr><th id="912">912</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::writesockfd" title='connectdata::writesockfd' data-ref="connectdata::writesockfd">writesockfd</dfn>; <i>/* socket to write to, it may very</i></td></tr>
<tr><th id="913">913</th><td><i>                                well be the same we read from.</i></td></tr>
<tr><th id="914">914</th><td><i>                                CURL_SOCKET_BAD disables */</i></td></tr>
<tr><th id="915">915</th><td></td></tr>
<tr><th id="916">916</th><td>  <i class="doc">/** Dynamicly allocated strings, MUST be freed before this **/</i></td></tr>
<tr><th id="917">917</th><td>  <i class="doc">/** struct is killed.                                      **/</i></td></tr>
<tr><th id="918">918</th><td>  <b>struct</b> <dfn class="type def" id="dynamically_allocated_data" title='dynamically_allocated_data' data-ref="dynamically_allocated_data"><a class="type" href="#dynamically_allocated_data" title='dynamically_allocated_data' data-ref="dynamically_allocated_data">dynamically_allocated_data</a></dfn> {</td></tr>
<tr><th id="919">919</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::proxyuserpwd" title='dynamically_allocated_data::proxyuserpwd' data-ref="dynamically_allocated_data::proxyuserpwd">proxyuserpwd</dfn>;</td></tr>
<tr><th id="920">920</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::uagent" title='dynamically_allocated_data::uagent' data-ref="dynamically_allocated_data::uagent">uagent</dfn>;</td></tr>
<tr><th id="921">921</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::accept_encoding" title='dynamically_allocated_data::accept_encoding' data-ref="dynamically_allocated_data::accept_encoding">accept_encoding</dfn>;</td></tr>
<tr><th id="922">922</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::userpwd" title='dynamically_allocated_data::userpwd' data-ref="dynamically_allocated_data::userpwd">userpwd</dfn>;</td></tr>
<tr><th id="923">923</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::rangeline" title='dynamically_allocated_data::rangeline' data-ref="dynamically_allocated_data::rangeline">rangeline</dfn>;</td></tr>
<tr><th id="924">924</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::ref" title='dynamically_allocated_data::ref' data-ref="dynamically_allocated_data::ref">ref</dfn>;</td></tr>
<tr><th id="925">925</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::host" title='dynamically_allocated_data::host' data-ref="dynamically_allocated_data::host">host</dfn>;</td></tr>
<tr><th id="926">926</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::cookiehost" title='dynamically_allocated_data::cookiehost' data-ref="dynamically_allocated_data::cookiehost">cookiehost</dfn>;</td></tr>
<tr><th id="927">927</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::rtsp_transport" title='dynamically_allocated_data::rtsp_transport' data-ref="dynamically_allocated_data::rtsp_transport">rtsp_transport</dfn>;</td></tr>
<tr><th id="928">928</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::te" title='dynamically_allocated_data::te' data-ref="dynamically_allocated_data::te">te</dfn>; <i>/* TE: request header */</i></td></tr>
<tr><th id="929">929</th><td>  } <dfn class="decl" id="connectdata::allocptr" title='connectdata::allocptr' data-ref="connectdata::allocptr">allocptr</dfn>;</td></tr>
<tr><th id="930">930</th><td></td></tr>
<tr><th id="931">931</th><td><u>#<span data-ppcond="931">ifdef</span> <span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span></u></td></tr>
<tr><th id="932">932</th><td>  <em>int</em> sec_complete; <i>/* if Kerberos is enabled for this connection */</i></td></tr>
<tr><th id="933">933</th><td>  <b>enum</b> protection_level command_prot;</td></tr>
<tr><th id="934">934</th><td>  <b>enum</b> protection_level data_prot;</td></tr>
<tr><th id="935">935</th><td>  <b>enum</b> protection_level request_data_prot;</td></tr>
<tr><th id="936">936</th><td>  size_t buffer_size;</td></tr>
<tr><th id="937">937</th><td>  <b>struct</b> krb5buffer in_buffer;</td></tr>
<tr><th id="938">938</th><td>  <em>void</em> *app_data;</td></tr>
<tr><th id="939">939</th><td>  <em>const</em> <b>struct</b> Curl_sec_client_mech *mech;</td></tr>
<tr><th id="940">940</th><td>  <b>struct</b> sockaddr_in local_addr;</td></tr>
<tr><th id="941">941</th><td><u>#<span data-ppcond="931">endif</span></u></td></tr>
<tr><th id="942">942</th><td></td></tr>
<tr><th id="943">943</th><td><u>#<span data-ppcond="943">if</span> defined(<span class="macro" data-ref="_M/USE_KERBEROS5">USE_KERBEROS5</span>)    /* Consider moving some of the above GSS-API */</u></td></tr>
<tr><th id="944">944</th><td>  <b>struct</b> kerberos5data krb5;  <i>/* variables into the structure definition, */</i></td></tr>
<tr><th id="945">945</th><td><u>#<span data-ppcond="943">endif</span>                        /* however, some of them are ftp specific. */</u></td></tr>
<tr><th id="946">946</th><td></td></tr>
<tr><th id="947">947</th><td>  <i>/* the two following *_inuse fields are only flags, not counters in any way.</i></td></tr>
<tr><th id="948">948</th><td><i>     If TRUE it means the channel is in use, and if FALSE it means the channel</i></td></tr>
<tr><th id="949">949</th><td><i>     is up for grabs by one. */</i></td></tr>
<tr><th id="950">950</th><td></td></tr>
<tr><th id="951">951</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="connectdata::readchannel_inuse" title='connectdata::readchannel_inuse' data-ref="connectdata::readchannel_inuse">readchannel_inuse</dfn>;  <i>/* whether the read channel is in use by an easy</i></td></tr>
<tr><th id="952">952</th><td><i>                              handle */</i></td></tr>
<tr><th id="953">953</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="connectdata::writechannel_inuse" title='connectdata::writechannel_inuse' data-ref="connectdata::writechannel_inuse">writechannel_inuse</dfn>; <i>/* whether the write channel is in use by an easy</i></td></tr>
<tr><th id="954">954</th><td><i>                              handle */</i></td></tr>
<tr><th id="955">955</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist" title='curl_llist' data-ref="curl_llist">curl_llist</a> <dfn class="decl" id="connectdata::send_pipe" title='connectdata::send_pipe' data-ref="connectdata::send_pipe">send_pipe</dfn>; <i>/* List of handles waiting to send on this</i></td></tr>
<tr><th id="956">956</th><td><i>                                  pipeline */</i></td></tr>
<tr><th id="957">957</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist" title='curl_llist' data-ref="curl_llist">curl_llist</a> <dfn class="decl" id="connectdata::recv_pipe" title='connectdata::recv_pipe' data-ref="connectdata::recv_pipe">recv_pipe</dfn>; <i>/* List of handles waiting to read their</i></td></tr>
<tr><th id="958">958</th><td><i>                                  responses on this pipeline */</i></td></tr>
<tr><th id="959">959</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::master_buffer" title='connectdata::master_buffer' data-ref="connectdata::master_buffer">master_buffer</dfn>; <i>/* The master buffer allocated on-demand;</i></td></tr>
<tr><th id="960">960</th><td><i>                          used for pipelining. */</i></td></tr>
<tr><th id="961">961</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="connectdata::read_pos" title='connectdata::read_pos' data-ref="connectdata::read_pos">read_pos</dfn>; <i>/* Current read position in the master buffer */</i></td></tr>
<tr><th id="962">962</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="connectdata::buf_len" title='connectdata::buf_len' data-ref="connectdata::buf_len">buf_len</dfn>; <i>/* Length of the buffer?? */</i></td></tr>
<tr><th id="963">963</th><td></td></tr>
<tr><th id="964">964</th><td></td></tr>
<tr><th id="965">965</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_seek_callback" title='curl_seek_callback' data-type='int (*)(void *, curl_off_t, int)' data-ref="curl_seek_callback">curl_seek_callback</a> <dfn class="decl" id="connectdata::seek_func" title='connectdata::seek_func' data-ref="connectdata::seek_func">seek_func</dfn>; <i>/* function that seeks the input */</i></td></tr>
<tr><th id="966">966</th><td>  <em>void</em> *<dfn class="decl" id="connectdata::seek_client" title='connectdata::seek_client' data-ref="connectdata::seek_client">seek_client</dfn>;            <i>/* pointer to pass to the seek() above */</i></td></tr>
<tr><th id="967">967</th><td></td></tr>
<tr><th id="968">968</th><td>  <i>/*************** Request - specific items ************/</i></td></tr>
<tr><th id="969">969</th><td></td></tr>
<tr><th id="970">970</th><td><u>#<span data-ppcond="970">if</span> defined(<a class="macro" href="curl_setup.h.html#635" data-ref="_M/USE_NTLM">USE_NTLM</a>)</u></td></tr>
<tr><th id="971">971</th><td>  <b>struct</b> <a class="type" href="#ntlmdata" title='ntlmdata' data-ref="ntlmdata">ntlmdata</a> <dfn class="decl" id="connectdata::ntlm" title='connectdata::ntlm' data-ref="connectdata::ntlm">ntlm</dfn>;     <i>/* NTLM differs from other authentication schemes</i></td></tr>
<tr><th id="972">972</th><td><i>                               because it authenticates connections, not</i></td></tr>
<tr><th id="973">973</th><td><i>                               single requests! */</i></td></tr>
<tr><th id="974">974</th><td>  <b>struct</b> <a class="type" href="#ntlmdata" title='ntlmdata' data-ref="ntlmdata">ntlmdata</a> <dfn class="decl" id="connectdata::proxyntlm" title='connectdata::proxyntlm' data-ref="connectdata::proxyntlm">proxyntlm</dfn>; <i>/* NTLM data for proxy */</i></td></tr>
<tr><th id="975">975</th><td></td></tr>
<tr><th id="976">976</th><td><u>#<span data-ppcond="976">if</span> defined(<span class="macro" data-ref="_M/NTLM_WB_ENABLED">NTLM_WB_ENABLED</span>)</u></td></tr>
<tr><th id="977">977</th><td>  <i>/* used for communication with Samba's winbind daemon helper ntlm_auth */</i></td></tr>
<tr><th id="978">978</th><td>  curl_socket_t ntlm_auth_hlpr_socket;</td></tr>
<tr><th id="979">979</th><td>  pid_t ntlm_auth_hlpr_pid;</td></tr>
<tr><th id="980">980</th><td>  <em>char</em> *challenge_header;</td></tr>
<tr><th id="981">981</th><td>  <em>char</em> *response_header;</td></tr>
<tr><th id="982">982</th><td><u>#<span data-ppcond="976">endif</span></u></td></tr>
<tr><th id="983">983</th><td><u>#<span data-ppcond="970">endif</span></u></td></tr>
<tr><th id="984">984</th><td></td></tr>
<tr><th id="985">985</th><td>  <em>char</em> <dfn class="decl" id="connectdata::syserr_buf" title='connectdata::syserr_buf' data-ref="connectdata::syserr_buf">syserr_buf</dfn> [<var>256</var>]; <i>/* buffer for Curl_strerror() */</i></td></tr>
<tr><th id="986">986</th><td></td></tr>
<tr><th id="987">987</th><td><u>#<span data-ppcond="987">ifdef</span> <a class="macro" href="curl_setup.h.html#534" data-ref="_M/CURLRES_ASYNCH">CURLRES_ASYNCH</a></u></td></tr>
<tr><th id="988">988</th><td>  <i>/* data used for the asynch name resolve callback */</i></td></tr>
<tr><th id="989">989</th><td>  <b>struct</b> <a class="type" href="#Curl_async" title='Curl_async' data-ref="Curl_async">Curl_async</a> <dfn class="decl" id="connectdata::async" title='connectdata::async' data-ref="connectdata::async">async</dfn>;</td></tr>
<tr><th id="990">990</th><td><u>#<span data-ppcond="987">endif</span></u></td></tr>
<tr><th id="991">991</th><td></td></tr>
<tr><th id="992">992</th><td>  <i>/* These three are used for chunked-encoding trailer support */</i></td></tr>
<tr><th id="993">993</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::trailer" title='connectdata::trailer' data-ref="connectdata::trailer">trailer</dfn>; <i>/* allocated buffer to store trailer in */</i></td></tr>
<tr><th id="994">994</th><td>  <em>int</em> <dfn class="decl" id="connectdata::trlMax" title='connectdata::trlMax' data-ref="connectdata::trlMax">trlMax</dfn>;    <i>/* allocated buffer size */</i></td></tr>
<tr><th id="995">995</th><td>  <em>int</em> <dfn class="decl" id="connectdata::trlPos" title='connectdata::trlPos' data-ref="connectdata::trlPos">trlPos</dfn>;    <i>/* index of where to store data */</i></td></tr>
<tr><th id="996">996</th><td></td></tr>
<tr><th id="997">997</th><td>  <b>union</b> {</td></tr>
<tr><th id="998">998</th><td>    <b>struct</b> <a class="type" href="ftp.h.html#ftp_conn" title='ftp_conn' data-ref="ftp_conn">ftp_conn</a> <dfn class="decl" id="connectdata::(anonymous)::ftpc" title='connectdata::(anonymous union)::ftpc' data-ref="connectdata::(anonymous)::ftpc">ftpc</dfn>;</td></tr>
<tr><th id="999">999</th><td>    <b>struct</b> <a class="type" href="http.h.html#http_conn" title='http_conn' data-ref="http_conn">http_conn</a> <dfn class="decl" id="connectdata::(anonymous)::httpc" title='connectdata::(anonymous union)::httpc' data-ref="connectdata::(anonymous)::httpc">httpc</dfn>;</td></tr>
<tr><th id="1000">1000</th><td>    <b>struct</b> <a class="type" href="ssh.h.html#ssh_conn" title='ssh_conn' data-ref="ssh_conn">ssh_conn</a> <dfn class="decl" id="connectdata::(anonymous)::sshc" title='connectdata::(anonymous union)::sshc' data-ref="connectdata::(anonymous)::sshc">sshc</dfn>;</td></tr>
<tr><th id="1001">1001</th><td>    <b>struct</b> <dfn class="type" id="tftp_state_data" title='tftp_state_data' data-ref="tftp_state_data"><a class="type" href="#tftp_state_data" title='tftp_state_data' data-ref="tftp_state_data">tftp_state_data</a></dfn> *<dfn class="decl" id="connectdata::(anonymous)::tftpc" title='connectdata::(anonymous union)::tftpc' data-ref="connectdata::(anonymous)::tftpc">tftpc</dfn>;</td></tr>
<tr><th id="1002">1002</th><td>    <b>struct</b> <a class="type" href="imap.h.html#imap_conn" title='imap_conn' data-ref="imap_conn">imap_conn</a> <dfn class="decl" id="connectdata::(anonymous)::imapc" title='connectdata::(anonymous union)::imapc' data-ref="connectdata::(anonymous)::imapc">imapc</dfn>;</td></tr>
<tr><th id="1003">1003</th><td>    <b>struct</b> <a class="type" href="pop3.h.html#pop3_conn" title='pop3_conn' data-ref="pop3_conn">pop3_conn</a> <dfn class="decl" id="connectdata::(anonymous)::pop3c" title='connectdata::(anonymous union)::pop3c' data-ref="connectdata::(anonymous)::pop3c">pop3c</dfn>;</td></tr>
<tr><th id="1004">1004</th><td>    <b>struct</b> <a class="type" href="smtp.h.html#smtp_conn" title='smtp_conn' data-ref="smtp_conn">smtp_conn</a> <dfn class="decl" id="connectdata::(anonymous)::smtpc" title='connectdata::(anonymous union)::smtpc' data-ref="connectdata::(anonymous)::smtpc">smtpc</dfn>;</td></tr>
<tr><th id="1005">1005</th><td>    <b>struct</b> <a class="type" href="rtsp.h.html#rtsp_conn" title='rtsp_conn' data-ref="rtsp_conn">rtsp_conn</a> <dfn class="decl" id="connectdata::(anonymous)::rtspc" title='connectdata::(anonymous union)::rtspc' data-ref="connectdata::(anonymous)::rtspc">rtspc</dfn>;</td></tr>
<tr><th id="1006">1006</th><td>    <b>struct</b> <a class="type" href="smb.h.html#smb_conn" title='smb_conn' data-ref="smb_conn">smb_conn</a> <dfn class="decl" id="connectdata::(anonymous)::smbc" title='connectdata::(anonymous union)::smbc' data-ref="connectdata::(anonymous)::smbc">smbc</dfn>;</td></tr>
<tr><th id="1007">1007</th><td>    <em>void</em> *<dfn class="decl" id="connectdata::(anonymous)::generic" title='connectdata::(anonymous union)::generic' data-ref="connectdata::(anonymous)::generic">generic</dfn>; <i>/* RTMP and LDAP use this */</i></td></tr>
<tr><th id="1008">1008</th><td>  } <dfn class="decl" id="connectdata::proto" title='connectdata::proto' data-ref="connectdata::proto">proto</dfn>;</td></tr>
<tr><th id="1009">1009</th><td></td></tr>
<tr><th id="1010">1010</th><td>  <em>int</em> <dfn class="decl" id="connectdata::cselect_bits" title='connectdata::cselect_bits' data-ref="connectdata::cselect_bits">cselect_bits</dfn>; <i>/* bitmask of socket events */</i></td></tr>
<tr><th id="1011">1011</th><td>  <em>int</em> <dfn class="decl" id="connectdata::waitfor" title='connectdata::waitfor' data-ref="connectdata::waitfor">waitfor</dfn>;      <i>/* current READ/WRITE bits to wait for */</i></td></tr>
<tr><th id="1012">1012</th><td></td></tr>
<tr><th id="1013">1013</th><td><u>#<span data-ppcond="1013">if</span> defined(<span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span>) || defined(<span class="macro" data-ref="_M/USE_WINDOWS_SSPI">USE_WINDOWS_SSPI</span>)</u></td></tr>
<tr><th id="1014">1014</th><td>  <em>int</em> socks5_gssapi_enctype;</td></tr>
<tr><th id="1015">1015</th><td><u>#<span data-ppcond="1013">endif</span></u></td></tr>
<tr><th id="1016">1016</th><td></td></tr>
<tr><th id="1017">1017</th><td>  <i>/* When this connection is created, store the conditions for the local end</i></td></tr>
<tr><th id="1018">1018</th><td><i>     bind. This is stored before the actual bind and before any connection is</i></td></tr>
<tr><th id="1019">1019</th><td><i>     made and will serve the purpose of being used for comparison reasons so</i></td></tr>
<tr><th id="1020">1020</th><td><i>     that subsequent bound-requested connections aren't accidentally re-using</i></td></tr>
<tr><th id="1021">1021</th><td><i>     wrong connections. */</i></td></tr>
<tr><th id="1022">1022</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::localdev" title='connectdata::localdev' data-ref="connectdata::localdev">localdev</dfn>;</td></tr>
<tr><th id="1023">1023</th><td>  <em>unsigned</em> <em>short</em> <dfn class="decl" id="connectdata::localport" title='connectdata::localport' data-ref="connectdata::localport">localport</dfn>;</td></tr>
<tr><th id="1024">1024</th><td>  <em>int</em> <dfn class="decl" id="connectdata::localportrange" title='connectdata::localportrange' data-ref="connectdata::localportrange">localportrange</dfn>;</td></tr>
<tr><th id="1025">1025</th><td>  <b>struct</b> <a class="type" href="#http_connect_state" title='http_connect_state' data-ref="http_connect_state">http_connect_state</a> *<dfn class="decl" id="connectdata::connect_state" title='connectdata::connect_state' data-ref="connectdata::connect_state">connect_state</dfn>; <i>/* for HTTP CONNECT */</i></td></tr>
<tr><th id="1026">1026</th><td>  <b>struct</b> <a class="type" href="conncache.h.html#connectbundle" title='connectbundle' data-ref="connectbundle">connectbundle</a> *<dfn class="decl" id="connectdata::bundle" title='connectdata::bundle' data-ref="connectdata::bundle">bundle</dfn>; <i>/* The bundle we are member of */</i></td></tr>
<tr><th id="1027">1027</th><td>  <em>int</em> <dfn class="decl" id="connectdata::negnpn" title='connectdata::negnpn' data-ref="connectdata::negnpn">negnpn</dfn>; <i>/* APLN or NPN TLS negotiated protocol, CURL_HTTP_VERSION* */</i></td></tr>
<tr><th id="1028">1028</th><td></td></tr>
<tr><th id="1029">1029</th><td><u>#<span data-ppcond="1029">ifdef</span> <a class="macro" href="curl_config.h.html#955" data-ref="_M/USE_UNIX_SOCKETS">USE_UNIX_SOCKETS</a></u></td></tr>
<tr><th id="1030">1030</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::unix_domain_socket" title='connectdata::unix_domain_socket' data-ref="connectdata::unix_domain_socket">unix_domain_socket</dfn>;</td></tr>
<tr><th id="1031">1031</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="connectdata::abstract_unix_socket" title='connectdata::abstract_unix_socket' data-ref="connectdata::abstract_unix_socket">abstract_unix_socket</dfn>;</td></tr>
<tr><th id="1032">1032</th><td><u>#<span data-ppcond="1029">endif</span></u></td></tr>
<tr><th id="1033">1033</th><td></td></tr>
<tr><th id="1034">1034</th><td><u>#<span data-ppcond="1034">ifdef</span> <a class="macro" href="curl_setup.h.html#613" data-ref="_M/USE_SSL">USE_SSL</a></u></td></tr>
<tr><th id="1035">1035</th><td>  <i>/*</i></td></tr>
<tr><th id="1036">1036</th><td><i>   * To avoid multiple malloc() calls, the ssl_connect_data structures</i></td></tr>
<tr><th id="1037">1037</th><td><i>   * associated with a connectdata struct are allocated in the same block</i></td></tr>
<tr><th id="1038">1038</th><td><i>   * as the latter. This field forces alignment to an 8-byte boundary so</i></td></tr>
<tr><th id="1039">1039</th><td><i>   * that this all works.</i></td></tr>
<tr><th id="1040">1040</th><td><i>   */</i></td></tr>
<tr><th id="1041">1041</th><td>  <em>long</em> <em>long</em> *<dfn class="decl" id="connectdata::align_data__do_not_use" title='connectdata::align_data__do_not_use' data-ref="connectdata::align_data__do_not_use">align_data__do_not_use</dfn>;</td></tr>
<tr><th id="1042">1042</th><td><u>#<span data-ppcond="1034">endif</span></u></td></tr>
<tr><th id="1043">1043</th><td>};</td></tr>
<tr><th id="1044">1044</th><td></td></tr>
<tr><th id="1045">1045</th><td><i>/* The end of connectdata. */</i></td></tr>
<tr><th id="1046">1046</th><td></td></tr>
<tr><th id="1047">1047</th><td><i>/*</i></td></tr>
<tr><th id="1048">1048</th><td><i> * Struct to keep statistical and informational data.</i></td></tr>
<tr><th id="1049">1049</th><td><i> * All variables in this struct must be initialized/reset in Curl_initinfo().</i></td></tr>
<tr><th id="1050">1050</th><td><i> */</i></td></tr>
<tr><th id="1051">1051</th><td><b>struct</b> <dfn class="type def" id="PureInfo" title='PureInfo' data-ref="PureInfo">PureInfo</dfn> {</td></tr>
<tr><th id="1052">1052</th><td>  <em>int</em> <dfn class="decl" id="PureInfo::httpcode" title='PureInfo::httpcode' data-ref="PureInfo::httpcode">httpcode</dfn>;  <i>/* Recent HTTP, FTP, RTSP or SMTP response code */</i></td></tr>
<tr><th id="1053">1053</th><td>  <em>int</em> <dfn class="decl" id="PureInfo::httpproxycode" title='PureInfo::httpproxycode' data-ref="PureInfo::httpproxycode">httpproxycode</dfn>; <i>/* response code from proxy when received separate */</i></td></tr>
<tr><th id="1054">1054</th><td>  <em>int</em> <dfn class="decl" id="PureInfo::httpversion" title='PureInfo::httpversion' data-ref="PureInfo::httpversion">httpversion</dfn>; <i>/* the http version number X.Y = X*10+Y */</i></td></tr>
<tr><th id="1055">1055</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::filetime" title='PureInfo::filetime' data-ref="PureInfo::filetime">filetime</dfn>; <i>/* If requested, this is might get set. Set to -1 if the time</i></td></tr>
<tr><th id="1056">1056</th><td><i>                    was unretrievable. We cannot have this of type time_t,</i></td></tr>
<tr><th id="1057">1057</th><td><i>                    since time_t is unsigned on several platforms such as</i></td></tr>
<tr><th id="1058">1058</th><td><i>                    OpenVMS. */</i></td></tr>
<tr><th id="1059">1059</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="PureInfo::timecond" title='PureInfo::timecond' data-ref="PureInfo::timecond">timecond</dfn>;  <i>/* set to TRUE if the time condition didn't match, which</i></td></tr>
<tr><th id="1060">1060</th><td><i>                     thus made the document NOT get fetched */</i></td></tr>
<tr><th id="1061">1061</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::header_size" title='PureInfo::header_size' data-ref="PureInfo::header_size">header_size</dfn>;  <i>/* size of read header(s) in bytes */</i></td></tr>
<tr><th id="1062">1062</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::request_size" title='PureInfo::request_size' data-ref="PureInfo::request_size">request_size</dfn>; <i>/* the amount of bytes sent in the request(s) */</i></td></tr>
<tr><th id="1063">1063</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="PureInfo::proxyauthavail" title='PureInfo::proxyauthavail' data-ref="PureInfo::proxyauthavail">proxyauthavail</dfn>; <i>/* what proxy auth types were announced */</i></td></tr>
<tr><th id="1064">1064</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="PureInfo::httpauthavail" title='PureInfo::httpauthavail' data-ref="PureInfo::httpauthavail">httpauthavail</dfn>;  <i>/* what host auth types were announced */</i></td></tr>
<tr><th id="1065">1065</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::numconnects" title='PureInfo::numconnects' data-ref="PureInfo::numconnects">numconnects</dfn>; <i>/* how many new connection did libcurl created */</i></td></tr>
<tr><th id="1066">1066</th><td>  <em>char</em> *<dfn class="decl" id="PureInfo::contenttype" title='PureInfo::contenttype' data-ref="PureInfo::contenttype">contenttype</dfn>; <i>/* the content type of the object */</i></td></tr>
<tr><th id="1067">1067</th><td>  <em>char</em> *<dfn class="decl" id="PureInfo::wouldredirect" title='PureInfo::wouldredirect' data-ref="PureInfo::wouldredirect">wouldredirect</dfn>; <i>/* URL this would've been redirected to if asked to */</i></td></tr>
<tr><th id="1068">1068</th><td></td></tr>
<tr><th id="1069">1069</th><td>  <i>/* PureInfo members 'conn_primary_ip', 'conn_primary_port', 'conn_local_ip'</i></td></tr>
<tr><th id="1070">1070</th><td><i>     and, 'conn_local_port' are copied over from the connectdata struct in</i></td></tr>
<tr><th id="1071">1071</th><td><i>     order to allow curl_easy_getinfo() to return this information even when</i></td></tr>
<tr><th id="1072">1072</th><td><i>     the session handle is no longer associated with a connection, and also</i></td></tr>
<tr><th id="1073">1073</th><td><i>     allow curl_easy_reset() to clear this information from the session handle</i></td></tr>
<tr><th id="1074">1074</th><td><i>     without disturbing information which is still alive, and that might be</i></td></tr>
<tr><th id="1075">1075</th><td><i>     reused, in the connection cache. */</i></td></tr>
<tr><th id="1076">1076</th><td></td></tr>
<tr><th id="1077">1077</th><td>  <em>char</em> <dfn class="decl" id="PureInfo::conn_primary_ip" title='PureInfo::conn_primary_ip' data-ref="PureInfo::conn_primary_ip">conn_primary_ip</dfn>[<a class="macro" href="#75" title="sizeof(&quot;ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255&quot;)" data-ref="_M/MAX_IPADR_LEN">MAX_IPADR_LEN</a>];</td></tr>
<tr><th id="1078">1078</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::conn_primary_port" title='PureInfo::conn_primary_port' data-ref="PureInfo::conn_primary_port">conn_primary_port</dfn>;</td></tr>
<tr><th id="1079">1079</th><td></td></tr>
<tr><th id="1080">1080</th><td>  <em>char</em> <dfn class="decl" id="PureInfo::conn_local_ip" title='PureInfo::conn_local_ip' data-ref="PureInfo::conn_local_ip">conn_local_ip</dfn>[<a class="macro" href="#75" title="sizeof(&quot;ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255&quot;)" data-ref="_M/MAX_IPADR_LEN">MAX_IPADR_LEN</a>];</td></tr>
<tr><th id="1081">1081</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::conn_local_port" title='PureInfo::conn_local_port' data-ref="PureInfo::conn_local_port">conn_local_port</dfn>;</td></tr>
<tr><th id="1082">1082</th><td></td></tr>
<tr><th id="1083">1083</th><td>  <em>const</em> <em>char</em> *<dfn class="decl" id="PureInfo::conn_scheme" title='PureInfo::conn_scheme' data-ref="PureInfo::conn_scheme">conn_scheme</dfn>;</td></tr>
<tr><th id="1084">1084</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="PureInfo::conn_protocol" title='PureInfo::conn_protocol' data-ref="PureInfo::conn_protocol">conn_protocol</dfn>;</td></tr>
<tr><th id="1085">1085</th><td></td></tr>
<tr><th id="1086">1086</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_certinfo" title='curl_certinfo' data-ref="curl_certinfo">curl_certinfo</a> <dfn class="decl" id="PureInfo::certs" title='PureInfo::certs' data-ref="PureInfo::certs">certs</dfn>; <i>/* info about the certs, only populated in</i></td></tr>
<tr><th id="1087">1087</th><td><i>                                 OpenSSL builds. Asked for with</i></td></tr>
<tr><th id="1088">1088</th><td><i>                                 CURLOPT_CERTINFO / CURLINFO_CERTINFO */</i></td></tr>
<tr><th id="1089">1089</th><td>};</td></tr>
<tr><th id="1090">1090</th><td></td></tr>
<tr><th id="1091">1091</th><td></td></tr>
<tr><th id="1092">1092</th><td><b>struct</b> <dfn class="type def" id="Progress" title='Progress' data-ref="Progress">Progress</dfn> {</td></tr>
<tr><th id="1093">1093</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::lastshow" title='Progress::lastshow' data-ref="Progress::lastshow">lastshow</dfn>; <i>/* time() of the last displayed progress meter or NULL to</i></td></tr>
<tr><th id="1094">1094</th><td><i>                      force redraw at next call */</i></td></tr>
<tr><th id="1095">1095</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::size_dl" title='Progress::size_dl' data-ref="Progress::size_dl">size_dl</dfn>; <i>/* total expected size */</i></td></tr>
<tr><th id="1096">1096</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::size_ul" title='Progress::size_ul' data-ref="Progress::size_ul">size_ul</dfn>; <i>/* total expected size */</i></td></tr>
<tr><th id="1097">1097</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::downloaded" title='Progress::downloaded' data-ref="Progress::downloaded">downloaded</dfn>; <i>/* transferred so far */</i></td></tr>
<tr><th id="1098">1098</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::uploaded" title='Progress::uploaded' data-ref="Progress::uploaded">uploaded</dfn>; <i>/* transferred so far */</i></td></tr>
<tr><th id="1099">1099</th><td></td></tr>
<tr><th id="1100">1100</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::current_speed" title='Progress::current_speed' data-ref="Progress::current_speed">current_speed</dfn>; <i>/* uses the currently fastest transfer */</i></td></tr>
<tr><th id="1101">1101</th><td></td></tr>
<tr><th id="1102">1102</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="Progress::callback" title='Progress::callback' data-ref="Progress::callback">callback</dfn>;  <i>/* set when progress callback is used */</i></td></tr>
<tr><th id="1103">1103</th><td>  <em>int</em> <dfn class="decl" id="Progress::width" title='Progress::width' data-ref="Progress::width">width</dfn>; <i>/* screen width at download start */</i></td></tr>
<tr><th id="1104">1104</th><td>  <em>int</em> <dfn class="decl" id="Progress::flags" title='Progress::flags' data-ref="Progress::flags">flags</dfn>; <i>/* see progress.h */</i></td></tr>
<tr><th id="1105">1105</th><td></td></tr>
<tr><th id="1106">1106</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::timespent" title='Progress::timespent' data-ref="Progress::timespent">timespent</dfn>;</td></tr>
<tr><th id="1107">1107</th><td></td></tr>
<tr><th id="1108">1108</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::dlspeed" title='Progress::dlspeed' data-ref="Progress::dlspeed">dlspeed</dfn>;</td></tr>
<tr><th id="1109">1109</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::ulspeed" title='Progress::ulspeed' data-ref="Progress::ulspeed">ulspeed</dfn>;</td></tr>
<tr><th id="1110">1110</th><td></td></tr>
<tr><th id="1111">1111</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::t_nslookup" title='Progress::t_nslookup' data-ref="Progress::t_nslookup">t_nslookup</dfn>;</td></tr>
<tr><th id="1112">1112</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::t_connect" title='Progress::t_connect' data-ref="Progress::t_connect">t_connect</dfn>;</td></tr>
<tr><th id="1113">1113</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::t_appconnect" title='Progress::t_appconnect' data-ref="Progress::t_appconnect">t_appconnect</dfn>;</td></tr>
<tr><th id="1114">1114</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::t_pretransfer" title='Progress::t_pretransfer' data-ref="Progress::t_pretransfer">t_pretransfer</dfn>;</td></tr>
<tr><th id="1115">1115</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::t_starttransfer" title='Progress::t_starttransfer' data-ref="Progress::t_starttransfer">t_starttransfer</dfn>;</td></tr>
<tr><th id="1116">1116</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Progress::t_redirect" title='Progress::t_redirect' data-ref="Progress::t_redirect">t_redirect</dfn>;</td></tr>
<tr><th id="1117">1117</th><td></td></tr>
<tr><th id="1118">1118</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::start" title='Progress::start' data-ref="Progress::start">start</dfn>;</td></tr>
<tr><th id="1119">1119</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::t_startsingle" title='Progress::t_startsingle' data-ref="Progress::t_startsingle">t_startsingle</dfn>;</td></tr>
<tr><th id="1120">1120</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::t_startop" title='Progress::t_startop' data-ref="Progress::t_startop">t_startop</dfn>;</td></tr>
<tr><th id="1121">1121</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::t_acceptdata" title='Progress::t_acceptdata' data-ref="Progress::t_acceptdata">t_acceptdata</dfn>;</td></tr>
<tr><th id="1122">1122</th><td></td></tr>
<tr><th id="1123">1123</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="Progress::is_t_startransfer_set" title='Progress::is_t_startransfer_set' data-ref="Progress::is_t_startransfer_set">is_t_startransfer_set</dfn>;</td></tr>
<tr><th id="1124">1124</th><td></td></tr>
<tr><th id="1125">1125</th><td>  <i>/* upload speed limit */</i></td></tr>
<tr><th id="1126">1126</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::ul_limit_start" title='Progress::ul_limit_start' data-ref="Progress::ul_limit_start">ul_limit_start</dfn>;</td></tr>
<tr><th id="1127">1127</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::ul_limit_size" title='Progress::ul_limit_size' data-ref="Progress::ul_limit_size">ul_limit_size</dfn>;</td></tr>
<tr><th id="1128">1128</th><td>  <i>/* download speed limit */</i></td></tr>
<tr><th id="1129">1129</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::dl_limit_start" title='Progress::dl_limit_start' data-ref="Progress::dl_limit_start">dl_limit_start</dfn>;</td></tr>
<tr><th id="1130">1130</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::dl_limit_size" title='Progress::dl_limit_size' data-ref="Progress::dl_limit_size">dl_limit_size</dfn>;</td></tr>
<tr><th id="1131">1131</th><td></td></tr>
<tr><th id="1132">1132</th><td><u>#define <dfn class="macro" id="_M/CURR_TIME" data-ref="_M/CURR_TIME">CURR_TIME</dfn> (5 + 1) /* 6 entries for 5 seconds */</u></td></tr>
<tr><th id="1133">1133</th><td></td></tr>
<tr><th id="1134">1134</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::speeder" title='Progress::speeder' data-ref="Progress::speeder">speeder</dfn>[ <a class="macro" href="#1132" title="(5 + 1)" data-ref="_M/CURR_TIME">CURR_TIME</a> ];</td></tr>
<tr><th id="1135">1135</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="Progress::speeder_time" title='Progress::speeder_time' data-ref="Progress::speeder_time">speeder_time</dfn>[ <a class="macro" href="#1132" title="(5 + 1)" data-ref="_M/CURR_TIME">CURR_TIME</a> ];</td></tr>
<tr><th id="1136">1136</th><td>  <em>int</em> <dfn class="decl" id="Progress::speeder_c" title='Progress::speeder_c' data-ref="Progress::speeder_c">speeder_c</dfn>;</td></tr>
<tr><th id="1137">1137</th><td>};</td></tr>
<tr><th id="1138">1138</th><td></td></tr>
<tr><th id="1139">1139</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="1140">1140</th><td>  <dfn class="enum" id="HTTPREQ_NONE" title='HTTPREQ_NONE' data-ref="HTTPREQ_NONE">HTTPREQ_NONE</dfn>, <i>/* first in list */</i></td></tr>
<tr><th id="1141">1141</th><td>  <dfn class="enum" id="HTTPREQ_GET" title='HTTPREQ_GET' data-ref="HTTPREQ_GET">HTTPREQ_GET</dfn>,</td></tr>
<tr><th id="1142">1142</th><td>  <dfn class="enum" id="HTTPREQ_POST" title='HTTPREQ_POST' data-ref="HTTPREQ_POST">HTTPREQ_POST</dfn>,</td></tr>
<tr><th id="1143">1143</th><td>  <dfn class="enum" id="HTTPREQ_POST_FORM" title='HTTPREQ_POST_FORM' data-ref="HTTPREQ_POST_FORM">HTTPREQ_POST_FORM</dfn>, <i>/* we make a difference internally */</i></td></tr>
<tr><th id="1144">1144</th><td>  <dfn class="enum" id="HTTPREQ_POST_MIME" title='HTTPREQ_POST_MIME' data-ref="HTTPREQ_POST_MIME">HTTPREQ_POST_MIME</dfn>, <i>/* we make a difference internally */</i></td></tr>
<tr><th id="1145">1145</th><td>  <dfn class="enum" id="HTTPREQ_PUT" title='HTTPREQ_PUT' data-ref="HTTPREQ_PUT">HTTPREQ_PUT</dfn>,</td></tr>
<tr><th id="1146">1146</th><td>  <dfn class="enum" id="HTTPREQ_HEAD" title='HTTPREQ_HEAD' data-ref="HTTPREQ_HEAD">HTTPREQ_HEAD</dfn>,</td></tr>
<tr><th id="1147">1147</th><td>  <dfn class="enum" id="HTTPREQ_OPTIONS" title='HTTPREQ_OPTIONS' data-ref="HTTPREQ_OPTIONS">HTTPREQ_OPTIONS</dfn>,</td></tr>
<tr><th id="1148">1148</th><td>  <dfn class="enum" id="HTTPREQ_CUSTOM" title='HTTPREQ_CUSTOM' data-ref="HTTPREQ_CUSTOM">HTTPREQ_CUSTOM</dfn>,</td></tr>
<tr><th id="1149">1149</th><td>  <dfn class="enum" id="HTTPREQ_LAST" title='HTTPREQ_LAST' data-ref="HTTPREQ_LAST">HTTPREQ_LAST</dfn> <i>/* last in list */</i></td></tr>
<tr><th id="1150">1150</th><td>} <dfn class="typedef" id="Curl_HttpReq" title='Curl_HttpReq' data-type='enum Curl_HttpReq' data-ref="Curl_HttpReq">Curl_HttpReq</dfn>;</td></tr>
<tr><th id="1151">1151</th><td></td></tr>
<tr><th id="1152">1152</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="1153">1153</th><td>    <dfn class="enum" id="RTSPREQ_NONE" title='RTSPREQ_NONE' data-ref="RTSPREQ_NONE">RTSPREQ_NONE</dfn>, <i>/* first in list */</i></td></tr>
<tr><th id="1154">1154</th><td>    <dfn class="enum" id="RTSPREQ_OPTIONS" title='RTSPREQ_OPTIONS' data-ref="RTSPREQ_OPTIONS">RTSPREQ_OPTIONS</dfn>,</td></tr>
<tr><th id="1155">1155</th><td>    <dfn class="enum" id="RTSPREQ_DESCRIBE" title='RTSPREQ_DESCRIBE' data-ref="RTSPREQ_DESCRIBE">RTSPREQ_DESCRIBE</dfn>,</td></tr>
<tr><th id="1156">1156</th><td>    <dfn class="enum" id="RTSPREQ_ANNOUNCE" title='RTSPREQ_ANNOUNCE' data-ref="RTSPREQ_ANNOUNCE">RTSPREQ_ANNOUNCE</dfn>,</td></tr>
<tr><th id="1157">1157</th><td>    <dfn class="enum" id="RTSPREQ_SETUP" title='RTSPREQ_SETUP' data-ref="RTSPREQ_SETUP">RTSPREQ_SETUP</dfn>,</td></tr>
<tr><th id="1158">1158</th><td>    <dfn class="enum" id="RTSPREQ_PLAY" title='RTSPREQ_PLAY' data-ref="RTSPREQ_PLAY">RTSPREQ_PLAY</dfn>,</td></tr>
<tr><th id="1159">1159</th><td>    <dfn class="enum" id="RTSPREQ_PAUSE" title='RTSPREQ_PAUSE' data-ref="RTSPREQ_PAUSE">RTSPREQ_PAUSE</dfn>,</td></tr>
<tr><th id="1160">1160</th><td>    <dfn class="enum" id="RTSPREQ_TEARDOWN" title='RTSPREQ_TEARDOWN' data-ref="RTSPREQ_TEARDOWN">RTSPREQ_TEARDOWN</dfn>,</td></tr>
<tr><th id="1161">1161</th><td>    <dfn class="enum" id="RTSPREQ_GET_PARAMETER" title='RTSPREQ_GET_PARAMETER' data-ref="RTSPREQ_GET_PARAMETER">RTSPREQ_GET_PARAMETER</dfn>,</td></tr>
<tr><th id="1162">1162</th><td>    <dfn class="enum" id="RTSPREQ_SET_PARAMETER" title='RTSPREQ_SET_PARAMETER' data-ref="RTSPREQ_SET_PARAMETER">RTSPREQ_SET_PARAMETER</dfn>,</td></tr>
<tr><th id="1163">1163</th><td>    <dfn class="enum" id="RTSPREQ_RECORD" title='RTSPREQ_RECORD' data-ref="RTSPREQ_RECORD">RTSPREQ_RECORD</dfn>,</td></tr>
<tr><th id="1164">1164</th><td>    <dfn class="enum" id="RTSPREQ_RECEIVE" title='RTSPREQ_RECEIVE' data-ref="RTSPREQ_RECEIVE">RTSPREQ_RECEIVE</dfn>,</td></tr>
<tr><th id="1165">1165</th><td>    <dfn class="enum" id="RTSPREQ_LAST" title='RTSPREQ_LAST' data-ref="RTSPREQ_LAST">RTSPREQ_LAST</dfn> <i>/* last in list */</i></td></tr>
<tr><th id="1166">1166</th><td>} <dfn class="typedef" id="Curl_RtspReq" title='Curl_RtspReq' data-type='enum Curl_RtspReq' data-ref="Curl_RtspReq">Curl_RtspReq</dfn>;</td></tr>
<tr><th id="1167">1167</th><td></td></tr>
<tr><th id="1168">1168</th><td><i>/*</i></td></tr>
<tr><th id="1169">1169</th><td><i> * Values that are generated, temporary or calculated internally for a</i></td></tr>
<tr><th id="1170">1170</th><td><i> * "session handle" must be defined within the 'struct UrlState'.  This struct</i></td></tr>
<tr><th id="1171">1171</th><td><i> * will be used within the Curl_easy struct. When the 'Curl_easy'</i></td></tr>
<tr><th id="1172">1172</th><td><i> * struct is cloned, this data MUST NOT be copied.</i></td></tr>
<tr><th id="1173">1173</th><td><i> *</i></td></tr>
<tr><th id="1174">1174</th><td><i> * Remember that any "state" information goes globally for the curl handle.</i></td></tr>
<tr><th id="1175">1175</th><td><i> * Session-data MUST be put in the connectdata struct and here.  */</i></td></tr>
<tr><th id="1176">1176</th><td><u>#define <dfn class="macro" id="_M/MAX_CURL_USER_LENGTH" data-ref="_M/MAX_CURL_USER_LENGTH">MAX_CURL_USER_LENGTH</dfn> 256</u></td></tr>
<tr><th id="1177">1177</th><td><u>#define <dfn class="macro" id="_M/MAX_CURL_PASSWORD_LENGTH" data-ref="_M/MAX_CURL_PASSWORD_LENGTH">MAX_CURL_PASSWORD_LENGTH</dfn> 256</u></td></tr>
<tr><th id="1178">1178</th><td></td></tr>
<tr><th id="1179">1179</th><td><b>struct</b> <dfn class="type def" id="auth" title='auth' data-ref="auth">auth</dfn> {</td></tr>
<tr><th id="1180">1180</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="auth::want" title='auth::want' data-ref="auth::want">want</dfn>;  <i>/* Bitmask set to the authentication methods wanted by</i></td></tr>
<tr><th id="1181">1181</th><td><i>                          app (with CURLOPT_HTTPAUTH or CURLOPT_PROXYAUTH). */</i></td></tr>
<tr><th id="1182">1182</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="auth::picked" title='auth::picked' data-ref="auth::picked">picked</dfn>;</td></tr>
<tr><th id="1183">1183</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="auth::avail" title='auth::avail' data-ref="auth::avail">avail</dfn>; <i>/* Bitmask for what the server reports to support for</i></td></tr>
<tr><th id="1184">1184</th><td><i>                          this resource */</i></td></tr>
<tr><th id="1185">1185</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="auth::done" title='auth::done' data-ref="auth::done">done</dfn>;  <i>/* TRUE when the auth phase is done and ready to do the *actual*</i></td></tr>
<tr><th id="1186">1186</th><td><i>                 request */</i></td></tr>
<tr><th id="1187">1187</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="auth::multipass" title='auth::multipass' data-ref="auth::multipass">multipass</dfn>; <i>/* TRUE if this is not yet authenticated but within the</i></td></tr>
<tr><th id="1188">1188</th><td><i>                     auth multipass negotiation */</i></td></tr>
<tr><th id="1189">1189</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="auth::iestyle" title='auth::iestyle' data-ref="auth::iestyle">iestyle</dfn>; <i>/* TRUE if digest should be done IE-style or FALSE if it should</i></td></tr>
<tr><th id="1190">1190</th><td><i>                   be RFC compliant */</i></td></tr>
<tr><th id="1191">1191</th><td>};</td></tr>
<tr><th id="1192">1192</th><td></td></tr>
<tr><th id="1193">1193</th><td><b>struct</b> <dfn class="type def" id="Curl_http2_dep" title='Curl_http2_dep' data-ref="Curl_http2_dep">Curl_http2_dep</dfn> {</td></tr>
<tr><th id="1194">1194</th><td>  <b>struct</b> <a class="type" href="#Curl_http2_dep" title='Curl_http2_dep' data-ref="Curl_http2_dep">Curl_http2_dep</a> *<dfn class="decl" id="Curl_http2_dep::next" title='Curl_http2_dep::next' data-ref="Curl_http2_dep::next">next</dfn>;</td></tr>
<tr><th id="1195">1195</th><td>  <b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="decl" id="Curl_http2_dep::data" title='Curl_http2_dep::data' data-ref="Curl_http2_dep::data">data</dfn>;</td></tr>
<tr><th id="1196">1196</th><td>};</td></tr>
<tr><th id="1197">1197</th><td></td></tr>
<tr><th id="1198">1198</th><td><i>/*</i></td></tr>
<tr><th id="1199">1199</th><td><i> * This struct is for holding data that was attemped to get sent to the user's</i></td></tr>
<tr><th id="1200">1200</th><td><i> * callback but is held due to pausing. One instance per type (BOTH, HEADER,</i></td></tr>
<tr><th id="1201">1201</th><td><i> * BODY).</i></td></tr>
<tr><th id="1202">1202</th><td><i> */</i></td></tr>
<tr><th id="1203">1203</th><td><b>struct</b> <dfn class="type def" id="tempbuf" title='tempbuf' data-ref="tempbuf">tempbuf</dfn> {</td></tr>
<tr><th id="1204">1204</th><td>  <em>char</em> *<dfn class="decl" id="tempbuf::buf" title='tempbuf::buf' data-ref="tempbuf::buf">buf</dfn>;  <i>/* allocated buffer to keep data in when a write callback</i></td></tr>
<tr><th id="1205">1205</th><td><i>                 returns to make the connection paused */</i></td></tr>
<tr><th id="1206">1206</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="tempbuf::len" title='tempbuf::len' data-ref="tempbuf::len">len</dfn>; <i>/* size of the 'tempwrite' allocated buffer */</i></td></tr>
<tr><th id="1207">1207</th><td>  <em>int</em> <dfn class="decl" id="tempbuf::type" title='tempbuf::type' data-ref="tempbuf::type">type</dfn>;   <i>/* type of the 'tempwrite' buffer as a bitmask that is used with</i></td></tr>
<tr><th id="1208">1208</th><td><i>                 Curl_client_write() */</i></td></tr>
<tr><th id="1209">1209</th><td>};</td></tr>
<tr><th id="1210">1210</th><td></td></tr>
<tr><th id="1211">1211</th><td><i>/* Timers */</i></td></tr>
<tr><th id="1212">1212</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="1213">1213</th><td>  <dfn class="enum" id="EXPIRE_100_TIMEOUT" title='EXPIRE_100_TIMEOUT' data-ref="EXPIRE_100_TIMEOUT">EXPIRE_100_TIMEOUT</dfn>,</td></tr>
<tr><th id="1214">1214</th><td>  <dfn class="enum" id="EXPIRE_ASYNC_NAME" title='EXPIRE_ASYNC_NAME' data-ref="EXPIRE_ASYNC_NAME">EXPIRE_ASYNC_NAME</dfn>,</td></tr>
<tr><th id="1215">1215</th><td>  <dfn class="enum" id="EXPIRE_CONNECTTIMEOUT" title='EXPIRE_CONNECTTIMEOUT' data-ref="EXPIRE_CONNECTTIMEOUT">EXPIRE_CONNECTTIMEOUT</dfn>,</td></tr>
<tr><th id="1216">1216</th><td>  <dfn class="enum" id="EXPIRE_DNS_PER_NAME" title='EXPIRE_DNS_PER_NAME' data-ref="EXPIRE_DNS_PER_NAME">EXPIRE_DNS_PER_NAME</dfn>,</td></tr>
<tr><th id="1217">1217</th><td>  <dfn class="enum" id="EXPIRE_HAPPY_EYEBALLS" title='EXPIRE_HAPPY_EYEBALLS' data-ref="EXPIRE_HAPPY_EYEBALLS">EXPIRE_HAPPY_EYEBALLS</dfn>,</td></tr>
<tr><th id="1218">1218</th><td>  <dfn class="enum" id="EXPIRE_MULTI_PENDING" title='EXPIRE_MULTI_PENDING' data-ref="EXPIRE_MULTI_PENDING">EXPIRE_MULTI_PENDING</dfn>,</td></tr>
<tr><th id="1219">1219</th><td>  <dfn class="enum" id="EXPIRE_RUN_NOW" title='EXPIRE_RUN_NOW' data-ref="EXPIRE_RUN_NOW">EXPIRE_RUN_NOW</dfn>,</td></tr>
<tr><th id="1220">1220</th><td>  <dfn class="enum" id="EXPIRE_SPEEDCHECK" title='EXPIRE_SPEEDCHECK' data-ref="EXPIRE_SPEEDCHECK">EXPIRE_SPEEDCHECK</dfn>,</td></tr>
<tr><th id="1221">1221</th><td>  <dfn class="enum" id="EXPIRE_TIMEOUT" title='EXPIRE_TIMEOUT' data-ref="EXPIRE_TIMEOUT">EXPIRE_TIMEOUT</dfn>,</td></tr>
<tr><th id="1222">1222</th><td>  <dfn class="enum" id="EXPIRE_TOOFAST" title='EXPIRE_TOOFAST' data-ref="EXPIRE_TOOFAST">EXPIRE_TOOFAST</dfn>,</td></tr>
<tr><th id="1223">1223</th><td>  <dfn class="enum" id="EXPIRE_LAST" title='EXPIRE_LAST' data-ref="EXPIRE_LAST">EXPIRE_LAST</dfn> <i>/* not an actual timer, used as a marker only */</i></td></tr>
<tr><th id="1224">1224</th><td>} <dfn class="typedef" id="expire_id" title='expire_id' data-type='enum expire_id' data-ref="expire_id">expire_id</dfn>;</td></tr>
<tr><th id="1225">1225</th><td></td></tr>
<tr><th id="1226">1226</th><td><i>/*</i></td></tr>
<tr><th id="1227">1227</th><td><i> * One instance for each timeout an easy handle can set.</i></td></tr>
<tr><th id="1228">1228</th><td><i> */</i></td></tr>
<tr><th id="1229">1229</th><td><b>struct</b> <dfn class="type def" id="time_node" title='time_node' data-ref="time_node">time_node</dfn> {</td></tr>
<tr><th id="1230">1230</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist_element" title='curl_llist_element' data-ref="curl_llist_element">curl_llist_element</a> <dfn class="decl" id="time_node::list" title='time_node::list' data-ref="time_node::list">list</dfn>;</td></tr>
<tr><th id="1231">1231</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="time_node::time" title='time_node::time' data-ref="time_node::time">time</dfn>;</td></tr>
<tr><th id="1232">1232</th><td>  <a class="typedef" href="#expire_id" title='expire_id' data-type='enum expire_id' data-ref="expire_id">expire_id</a> <dfn class="decl" id="time_node::eid" title='time_node::eid' data-ref="time_node::eid">eid</dfn>;</td></tr>
<tr><th id="1233">1233</th><td>};</td></tr>
<tr><th id="1234">1234</th><td></td></tr>
<tr><th id="1235">1235</th><td><b>struct</b> <dfn class="type def" id="UrlState" title='UrlState' data-ref="UrlState">UrlState</dfn> {</td></tr>
<tr><th id="1236">1236</th><td></td></tr>
<tr><th id="1237">1237</th><td>  <i>/* Points to the connection cache */</i></td></tr>
<tr><th id="1238">1238</th><td>  <b>struct</b> <a class="type" href="conncache.h.html#conncache" title='conncache' data-ref="conncache">conncache</a> *<dfn class="decl" id="UrlState::conn_cache" title='UrlState::conn_cache' data-ref="UrlState::conn_cache">conn_cache</dfn>;</td></tr>
<tr><th id="1239">1239</th><td></td></tr>
<tr><th id="1240">1240</th><td>  <i>/* when curl_easy_perform() is called, the multi handle is "owned" by</i></td></tr>
<tr><th id="1241">1241</th><td><i>     the easy handle so curl_easy_cleanup() on such an easy handle will</i></td></tr>
<tr><th id="1242">1242</th><td><i>     also close the multi handle! */</i></td></tr>
<tr><th id="1243">1243</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::multi_owned_by_easy" title='UrlState::multi_owned_by_easy' data-ref="UrlState::multi_owned_by_easy">multi_owned_by_easy</dfn>;</td></tr>
<tr><th id="1244">1244</th><td></td></tr>
<tr><th id="1245">1245</th><td>  <i>/* buffers to store authentication data in, as parsed from input options */</i></td></tr>
<tr><th id="1246">1246</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="UrlState::keeps_speed" title='UrlState::keeps_speed' data-ref="UrlState::keeps_speed">keeps_speed</dfn>; <i>/* for the progress meter really */</i></td></tr>
<tr><th id="1247">1247</th><td></td></tr>
<tr><th id="1248">1248</th><td>  <b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="decl" id="UrlState::lastconnect" title='UrlState::lastconnect' data-ref="UrlState::lastconnect">lastconnect</dfn>; <i>/* The last connection, NULL if undefined */</i></td></tr>
<tr><th id="1249">1249</th><td></td></tr>
<tr><th id="1250">1250</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::headerbuff" title='UrlState::headerbuff' data-ref="UrlState::headerbuff">headerbuff</dfn>; <i>/* allocated buffer to store headers in */</i></td></tr>
<tr><th id="1251">1251</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="UrlState::headersize" title='UrlState::headersize' data-ref="UrlState::headersize">headersize</dfn>;   <i>/* size of the allocation */</i></td></tr>
<tr><th id="1252">1252</th><td></td></tr>
<tr><th id="1253">1253</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::buffer" title='UrlState::buffer' data-ref="UrlState::buffer">buffer</dfn>; <i>/* download buffer */</i></td></tr>
<tr><th id="1254">1254</th><td>  <em>char</em> <dfn class="decl" id="UrlState::uploadbuffer" title='UrlState::uploadbuffer' data-ref="UrlState::uploadbuffer">uploadbuffer</dfn>[<a class="macro" href="#137" title="16384" data-ref="_M/UPLOAD_BUFSIZE">UPLOAD_BUFSIZE</a> + <var>1</var>]; <i>/* upload buffer */</i></td></tr>
<tr><th id="1255">1255</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UrlState::current_speed" title='UrlState::current_speed' data-ref="UrlState::current_speed">current_speed</dfn>;  <i>/* the ProgressShow() function sets this,</i></td></tr>
<tr><th id="1256">1256</th><td><i>                                bytes / second */</i></td></tr>
<tr><th id="1257">1257</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::this_is_a_follow" title='UrlState::this_is_a_follow' data-ref="UrlState::this_is_a_follow">this_is_a_follow</dfn>; <i>/* this is a followed Location: request */</i></td></tr>
<tr><th id="1258">1258</th><td></td></tr>
<tr><th id="1259">1259</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::first_host" title='UrlState::first_host' data-ref="UrlState::first_host">first_host</dfn>; <i>/* host name of the first (not followed) request.</i></td></tr>
<tr><th id="1260">1260</th><td><i>                       if set, this should be the host name that we will</i></td></tr>
<tr><th id="1261">1261</th><td><i>                       sent authorization to, no else. Used to make Location:</i></td></tr>
<tr><th id="1262">1262</th><td><i>                       following not keep sending user+password... This is</i></td></tr>
<tr><th id="1263">1263</th><td><i>                       strdup() data.</i></td></tr>
<tr><th id="1264">1264</th><td><i>                    */</i></td></tr>
<tr><th id="1265">1265</th><td>  <em>int</em> <dfn class="decl" id="UrlState::first_remote_port" title='UrlState::first_remote_port' data-ref="UrlState::first_remote_port">first_remote_port</dfn>; <i>/* remote port of the first (not followed) request */</i></td></tr>
<tr><th id="1266">1266</th><td>  <b>struct</b> <a class="type" href="#curl_ssl_session" title='curl_ssl_session' data-ref="curl_ssl_session">curl_ssl_session</a> *<dfn class="decl" id="UrlState::session" title='UrlState::session' data-ref="UrlState::session">session</dfn>; <i>/* array of 'max_ssl_sessions' size */</i></td></tr>
<tr><th id="1267">1267</th><td>  <em>long</em> <dfn class="decl" id="UrlState::sessionage" title='UrlState::sessionage' data-ref="UrlState::sessionage">sessionage</dfn>;                  <i>/* number of the most recent session */</i></td></tr>
<tr><th id="1268">1268</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="UrlState::tempcount" title='UrlState::tempcount' data-ref="UrlState::tempcount">tempcount</dfn>; <i>/* number of entries in use in tempwrite, 0 - 3 */</i></td></tr>
<tr><th id="1269">1269</th><td>  <b>struct</b> <a class="type" href="#tempbuf" title='tempbuf' data-ref="tempbuf">tempbuf</a> <dfn class="decl" id="UrlState::tempwrite" title='UrlState::tempwrite' data-ref="UrlState::tempwrite">tempwrite</dfn>[<var>3</var>]; <i>/* BOTH, HEADER, BODY */</i></td></tr>
<tr><th id="1270">1270</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::scratch" title='UrlState::scratch' data-ref="UrlState::scratch">scratch</dfn>; <i>/* huge buffer[set.buffer_size*2] for upload CRLF replacing */</i></td></tr>
<tr><th id="1271">1271</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::errorbuf" title='UrlState::errorbuf' data-ref="UrlState::errorbuf">errorbuf</dfn>; <i>/* Set to TRUE if the error buffer is already filled in.</i></td></tr>
<tr><th id="1272">1272</th><td><i>                    This must be set to FALSE every time _easy_perform() is</i></td></tr>
<tr><th id="1273">1273</th><td><i>                    called. */</i></td></tr>
<tr><th id="1274">1274</th><td>  <em>int</em> <dfn class="decl" id="UrlState::os_errno" title='UrlState::os_errno' data-ref="UrlState::os_errno">os_errno</dfn>;  <i>/* filled in with errno whenever an error occurs */</i></td></tr>
<tr><th id="1275">1275</th><td><u>#<span data-ppcond="1275">ifdef</span> <a class="macro" href="curl_config.h.html#555" data-ref="_M/HAVE_SIGNAL">HAVE_SIGNAL</a></u></td></tr>
<tr><th id="1276">1276</th><td>  <i>/* storage for the previous bag^H^H^HSIGPIPE signal handler :-) */</i></td></tr>
<tr><th id="1277">1277</th><td>  <em>void</em> (*<dfn class="decl" id="UrlState::prev_signal" title='UrlState::prev_signal' data-ref="UrlState::prev_signal">prev_signal</dfn>)(<em>int</em> <dfn class="local col9 decl" id="689sig" title='sig' data-type='int' data-ref="689sig">sig</dfn>);</td></tr>
<tr><th id="1278">1278</th><td><u>#<span data-ppcond="1275">endif</span></u></td></tr>
<tr><th id="1279">1279</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::allow_port" title='UrlState::allow_port' data-ref="UrlState::allow_port">allow_port</dfn>; <i>/* Is set.use_port allowed to take effect or not. This</i></td></tr>
<tr><th id="1280">1280</th><td><i>                      is always set TRUE when curl_easy_perform() is called. */</i></td></tr>
<tr><th id="1281">1281</th><td>  <b>struct</b> <a class="type" href="#digestdata" title='digestdata' data-ref="digestdata">digestdata</a> <dfn class="decl" id="UrlState::digest" title='UrlState::digest' data-ref="UrlState::digest">digest</dfn>;      <i>/* state data for host Digest auth */</i></td></tr>
<tr><th id="1282">1282</th><td>  <b>struct</b> <a class="type" href="#digestdata" title='digestdata' data-ref="digestdata">digestdata</a> <dfn class="decl" id="UrlState::proxydigest" title='UrlState::proxydigest' data-ref="UrlState::proxydigest">proxydigest</dfn>; <i>/* state data for proxy Digest auth */</i></td></tr>
<tr><th id="1283">1283</th><td></td></tr>
<tr><th id="1284">1284</th><td><u>#<span data-ppcond="1284">ifdef</span> <span class="macro" data-ref="_M/USE_SPNEGO">USE_SPNEGO</span></u></td></tr>
<tr><th id="1285">1285</th><td>  <b>struct</b> negotiatedata negotiate; <i>/* state data for host Negotiate auth */</i></td></tr>
<tr><th id="1286">1286</th><td>  <b>struct</b> negotiatedata proxyneg; <i>/* state data for proxy Negotiate auth */</i></td></tr>
<tr><th id="1287">1287</th><td><u>#<span data-ppcond="1284">endif</span></u></td></tr>
<tr><th id="1288">1288</th><td></td></tr>
<tr><th id="1289">1289</th><td>  <b>struct</b> <a class="type" href="#auth" title='auth' data-ref="auth">auth</a> <dfn class="decl" id="UrlState::authhost" title='UrlState::authhost' data-ref="UrlState::authhost">authhost</dfn>;  <i>/* auth details for host */</i></td></tr>
<tr><th id="1290">1290</th><td>  <b>struct</b> <a class="type" href="#auth" title='auth' data-ref="auth">auth</a> <dfn class="decl" id="UrlState::authproxy" title='UrlState::authproxy' data-ref="UrlState::authproxy">authproxy</dfn>; <i>/* auth details for proxy */</i></td></tr>
<tr><th id="1291">1291</th><td></td></tr>
<tr><th id="1292">1292</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::authproblem" title='UrlState::authproblem' data-ref="UrlState::authproblem">authproblem</dfn>; <i>/* TRUE if there's some problem authenticating */</i></td></tr>
<tr><th id="1293">1293</th><td></td></tr>
<tr><th id="1294">1294</th><td>  <em>void</em> *<dfn class="decl" id="UrlState::resolver" title='UrlState::resolver' data-ref="UrlState::resolver">resolver</dfn>; <i>/* resolver state, if it is used in the URL state -</i></td></tr>
<tr><th id="1295">1295</th><td><i>                     ares_channel f.e. */</i></td></tr>
<tr><th id="1296">1296</th><td></td></tr>
<tr><th id="1297">1297</th><td><u>#<span data-ppcond="1297">if</span> defined(<a class="macro" href="curl_config.h.html#949" data-ref="_M/USE_OPENSSL">USE_OPENSSL</a>) &amp;&amp; defined(<a class="macro" href="curl_config.h.html#447" data-ref="_M/HAVE_OPENSSL_ENGINE_H">HAVE_OPENSSL_ENGINE_H</a>)</u></td></tr>
<tr><th id="1298">1298</th><td>  <i>/* void instead of ENGINE to avoid bleeding OpenSSL into this header */</i></td></tr>
<tr><th id="1299">1299</th><td>  <em>void</em> *<dfn class="decl" id="UrlState::engine" title='UrlState::engine' data-ref="UrlState::engine">engine</dfn>;</td></tr>
<tr><th id="1300">1300</th><td><u>#<span data-ppcond="1297">endif</span> /* USE_OPENSSL */</u></td></tr>
<tr><th id="1301">1301</th><td>  <b>struct</b> <a class="type" href="timeval.h.html#curltime" title='curltime' data-ref="curltime">curltime</a> <dfn class="decl" id="UrlState::expiretime" title='UrlState::expiretime' data-ref="UrlState::expiretime">expiretime</dfn>; <i>/* set this with Curl_expire() only */</i></td></tr>
<tr><th id="1302">1302</th><td>  <b>struct</b> <a class="type" href="splay.h.html#Curl_tree" title='Curl_tree' data-ref="Curl_tree">Curl_tree</a> <dfn class="decl" id="UrlState::timenode" title='UrlState::timenode' data-ref="UrlState::timenode">timenode</dfn>; <i>/* for the splay stuff */</i></td></tr>
<tr><th id="1303">1303</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist" title='curl_llist' data-ref="curl_llist">curl_llist</a> <dfn class="decl" id="UrlState::timeoutlist" title='UrlState::timeoutlist' data-ref="UrlState::timeoutlist">timeoutlist</dfn>; <i>/* list of pending timeouts */</i></td></tr>
<tr><th id="1304">1304</th><td>  <b>struct</b> <a class="type" href="#time_node" title='time_node' data-ref="time_node">time_node</a> <dfn class="decl" id="UrlState::expires" title='UrlState::expires' data-ref="UrlState::expires">expires</dfn>[<a class="enum" href="#EXPIRE_LAST" title='EXPIRE_LAST' data-ref="EXPIRE_LAST">EXPIRE_LAST</a>]; <i>/* nodes for each expire type */</i></td></tr>
<tr><th id="1305">1305</th><td></td></tr>
<tr><th id="1306">1306</th><td>  <i>/* a place to store the most recently set FTP entrypath */</i></td></tr>
<tr><th id="1307">1307</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::most_recent_ftp_entrypath" title='UrlState::most_recent_ftp_entrypath' data-ref="UrlState::most_recent_ftp_entrypath">most_recent_ftp_entrypath</dfn>;</td></tr>
<tr><th id="1308">1308</th><td></td></tr>
<tr><th id="1309">1309</th><td>  <i>/* set after initial USER failure, to prevent an authentication loop */</i></td></tr>
<tr><th id="1310">1310</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::ftp_trying_alternative" title='UrlState::ftp_trying_alternative' data-ref="UrlState::ftp_trying_alternative">ftp_trying_alternative</dfn>;</td></tr>
<tr><th id="1311">1311</th><td></td></tr>
<tr><th id="1312">1312</th><td>  <em>int</em> <dfn class="decl" id="UrlState::httpversion" title='UrlState::httpversion' data-ref="UrlState::httpversion">httpversion</dfn>;       <i>/* the lowest HTTP version*10 reported by any server</i></td></tr>
<tr><th id="1313">1313</th><td><i>                            involved in this request */</i></td></tr>
<tr><th id="1314">1314</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::expect100header" title='UrlState::expect100header' data-ref="UrlState::expect100header">expect100header</dfn>;  <i>/* TRUE if we added Expect: 100-continue */</i></td></tr>
<tr><th id="1315">1315</th><td></td></tr>
<tr><th id="1316">1316</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::pipe_broke" title='UrlState::pipe_broke' data-ref="UrlState::pipe_broke">pipe_broke</dfn>; <i>/* TRUE if the connection we were pipelined on broke</i></td></tr>
<tr><th id="1317">1317</th><td><i>                      and we need to restart from the beginning */</i></td></tr>
<tr><th id="1318">1318</th><td></td></tr>
<tr><th id="1319">1319</th><td><u>#<span data-ppcond="1319">if</span> !defined(<span class="macro" data-ref="_M/WIN32">WIN32</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/MSDOS">MSDOS</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/__EMX__">__EMX__</span>) &amp;&amp; \</u></td></tr>
<tr><th id="1320">1320</th><td><u>    !defined(<span class="macro" data-ref="_M/__SYMBIAN32__">__SYMBIAN32__</span>)</u></td></tr>
<tr><th id="1321">1321</th><td><i>/* do FTP line-end conversions on most platforms */</i></td></tr>
<tr><th id="1322">1322</th><td><u>#define <dfn class="macro" id="_M/CURL_DO_LINEEND_CONV" data-ref="_M/CURL_DO_LINEEND_CONV">CURL_DO_LINEEND_CONV</dfn></u></td></tr>
<tr><th id="1323">1323</th><td>  <i>/* for FTP downloads: track CRLF sequences that span blocks */</i></td></tr>
<tr><th id="1324">1324</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::prev_block_had_trailing_cr" title='UrlState::prev_block_had_trailing_cr' data-ref="UrlState::prev_block_had_trailing_cr">prev_block_had_trailing_cr</dfn>;</td></tr>
<tr><th id="1325">1325</th><td>  <i>/* for FTP downloads: how many CRLFs did we converted to LFs? */</i></td></tr>
<tr><th id="1326">1326</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UrlState::crlf_conversions" title='UrlState::crlf_conversions' data-ref="UrlState::crlf_conversions">crlf_conversions</dfn>;</td></tr>
<tr><th id="1327">1327</th><td><u>#<span data-ppcond="1319">endif</span></u></td></tr>
<tr><th id="1328">1328</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::pathbuffer" title='UrlState::pathbuffer' data-ref="UrlState::pathbuffer">pathbuffer</dfn>;<i>/* allocated buffer to store the URL's path part in */</i></td></tr>
<tr><th id="1329">1329</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::path" title='UrlState::path' data-ref="UrlState::path">path</dfn>;      <i>/* path to use, points to somewhere within the pathbuffer</i></td></tr>
<tr><th id="1330">1330</th><td><i>                      area */</i></td></tr>
<tr><th id="1331">1331</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::slash_removed" title='UrlState::slash_removed' data-ref="UrlState::slash_removed">slash_removed</dfn>; <i>/* set TRUE if the 'path' points to a path where the</i></td></tr>
<tr><th id="1332">1332</th><td><i>                         initial URL slash separator has been taken off */</i></td></tr>
<tr><th id="1333">1333</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::use_range" title='UrlState::use_range' data-ref="UrlState::use_range">use_range</dfn>;</td></tr>
<tr><th id="1334">1334</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::rangestringalloc" title='UrlState::rangestringalloc' data-ref="UrlState::rangestringalloc">rangestringalloc</dfn>; <i>/* the range string is malloc()'ed */</i></td></tr>
<tr><th id="1335">1335</th><td></td></tr>
<tr><th id="1336">1336</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::range" title='UrlState::range' data-ref="UrlState::range">range</dfn>; <i>/* range, if used. See README for detailed specification on</i></td></tr>
<tr><th id="1337">1337</th><td><i>                  this syntax. */</i></td></tr>
<tr><th id="1338">1338</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UrlState::resume_from" title='UrlState::resume_from' data-ref="UrlState::resume_from">resume_from</dfn>; <i>/* continue [ftp] transfer from here */</i></td></tr>
<tr><th id="1339">1339</th><td></td></tr>
<tr><th id="1340">1340</th><td>  <i>/* This RTSP state information survives requests and connections */</i></td></tr>
<tr><th id="1341">1341</th><td>  <em>long</em> <dfn class="decl" id="UrlState::rtsp_next_client_CSeq" title='UrlState::rtsp_next_client_CSeq' data-ref="UrlState::rtsp_next_client_CSeq">rtsp_next_client_CSeq</dfn>; <i>/* the session's next client CSeq */</i></td></tr>
<tr><th id="1342">1342</th><td>  <em>long</em> <dfn class="decl" id="UrlState::rtsp_next_server_CSeq" title='UrlState::rtsp_next_server_CSeq' data-ref="UrlState::rtsp_next_server_CSeq">rtsp_next_server_CSeq</dfn>; <i>/* the session's next server CSeq */</i></td></tr>
<tr><th id="1343">1343</th><td>  <em>long</em> <dfn class="decl" id="UrlState::rtsp_CSeq_recv" title='UrlState::rtsp_CSeq_recv' data-ref="UrlState::rtsp_CSeq_recv">rtsp_CSeq_recv</dfn>; <i>/* most recent CSeq received */</i></td></tr>
<tr><th id="1344">1344</th><td></td></tr>
<tr><th id="1345">1345</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UrlState::infilesize" title='UrlState::infilesize' data-ref="UrlState::infilesize">infilesize</dfn>; <i>/* size of file to upload, -1 means unknown.</i></td></tr>
<tr><th id="1346">1346</th><td><i>                            Copied from set.filesize at start of operation */</i></td></tr>
<tr><th id="1347">1347</th><td></td></tr>
<tr><th id="1348">1348</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="UrlState::drain" title='UrlState::drain' data-ref="UrlState::drain">drain</dfn>; <i>/* Increased when this stream has data to read, even if its</i></td></tr>
<tr><th id="1349">1349</th><td><i>                   socket is not necessarily is readable. Decreased when</i></td></tr>
<tr><th id="1350">1350</th><td><i>                   checked. */</i></td></tr>
<tr><th id="1351">1351</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::done" title='UrlState::done' data-ref="UrlState::done">done</dfn>; <i>/* set to FALSE when Curl_init_do() is called and set to TRUE</i></td></tr>
<tr><th id="1352">1352</th><td><i>                when multi_done() is called, to prevent multi_done() to get</i></td></tr>
<tr><th id="1353">1353</th><td><i>                invoked twice when the multi interface is used. */</i></td></tr>
<tr><th id="1354">1354</th><td></td></tr>
<tr><th id="1355">1355</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_read_callback" title='curl_read_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_read_callback">curl_read_callback</a> <dfn class="decl" id="UrlState::fread_func" title='UrlState::fread_func' data-ref="UrlState::fread_func">fread_func</dfn>; <i>/* read callback/function */</i></td></tr>
<tr><th id="1356">1356</th><td>  <em>void</em> *<dfn class="decl" id="UrlState::in" title='UrlState::in' data-ref="UrlState::in">in</dfn>;                      <i>/* CURLOPT_READDATA */</i></td></tr>
<tr><th id="1357">1357</th><td></td></tr>
<tr><th id="1358">1358</th><td>  <b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="decl" id="UrlState::stream_depends_on" title='UrlState::stream_depends_on' data-ref="UrlState::stream_depends_on">stream_depends_on</dfn>;</td></tr>
<tr><th id="1359">1359</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UrlState::stream_depends_e" title='UrlState::stream_depends_e' data-ref="UrlState::stream_depends_e">stream_depends_e</dfn>; <i>/* set or don't set the Exclusive bit */</i></td></tr>
<tr><th id="1360">1360</th><td>  <em>int</em> <dfn class="decl" id="UrlState::stream_weight" title='UrlState::stream_weight' data-ref="UrlState::stream_weight">stream_weight</dfn>;</td></tr>
<tr><th id="1361">1361</th><td>};</td></tr>
<tr><th id="1362">1362</th><td></td></tr>
<tr><th id="1363">1363</th><td></td></tr>
<tr><th id="1364">1364</th><td><i>/*</i></td></tr>
<tr><th id="1365">1365</th><td><i> * This 'DynamicStatic' struct defines dynamic states that actually change</i></td></tr>
<tr><th id="1366">1366</th><td><i> * values in the 'UserDefined' area, which MUST be taken into consideration</i></td></tr>
<tr><th id="1367">1367</th><td><i> * if the UserDefined struct is cloned or similar. You can probably just</i></td></tr>
<tr><th id="1368">1368</th><td><i> * copy these, but each one indicate a special action on other data.</i></td></tr>
<tr><th id="1369">1369</th><td><i> */</i></td></tr>
<tr><th id="1370">1370</th><td></td></tr>
<tr><th id="1371">1371</th><td><b>struct</b> <dfn class="type def" id="DynamicStatic" title='DynamicStatic' data-ref="DynamicStatic">DynamicStatic</dfn> {</td></tr>
<tr><th id="1372">1372</th><td>  <em>char</em> *<dfn class="decl" id="DynamicStatic::url" title='DynamicStatic::url' data-ref="DynamicStatic::url">url</dfn>;        <i>/* work URL, copied from UserDefined */</i></td></tr>
<tr><th id="1373">1373</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="DynamicStatic::url_alloc" title='DynamicStatic::url_alloc' data-ref="DynamicStatic::url_alloc">url_alloc</dfn>;   <i>/* URL string is malloc()'ed */</i></td></tr>
<tr><th id="1374">1374</th><td>  <em>char</em> *<dfn class="decl" id="DynamicStatic::referer" title='DynamicStatic::referer' data-ref="DynamicStatic::referer">referer</dfn>;    <i>/* referer string */</i></td></tr>
<tr><th id="1375">1375</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="DynamicStatic::referer_alloc" title='DynamicStatic::referer_alloc' data-ref="DynamicStatic::referer_alloc">referer_alloc</dfn>; <i>/* referer sting is malloc()ed */</i></td></tr>
<tr><th id="1376">1376</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="DynamicStatic::cookielist" title='DynamicStatic::cookielist' data-ref="DynamicStatic::cookielist">cookielist</dfn>; <i>/* list of cookie files set by</i></td></tr>
<tr><th id="1377">1377</th><td><i>                                    curl_easy_setopt(COOKIEFILE) calls */</i></td></tr>
<tr><th id="1378">1378</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="DynamicStatic::resolve" title='DynamicStatic::resolve' data-ref="DynamicStatic::resolve">resolve</dfn>; <i>/* set to point to the set.resolve list when</i></td></tr>
<tr><th id="1379">1379</th><td><i>                                 this should be dealt with in pretransfer */</i></td></tr>
<tr><th id="1380">1380</th><td>};</td></tr>
<tr><th id="1381">1381</th><td></td></tr>
<tr><th id="1382">1382</th><td><i>/*</i></td></tr>
<tr><th id="1383">1383</th><td><i> * This 'UserDefined' struct must only contain data that is set once to go</i></td></tr>
<tr><th id="1384">1384</th><td><i> * for many (perhaps) independent connections. Values that are generated or</i></td></tr>
<tr><th id="1385">1385</th><td><i> * calculated internally for the "session handle" MUST be defined within the</i></td></tr>
<tr><th id="1386">1386</th><td><i> * 'struct UrlState' instead. The only exceptions MUST note the changes in</i></td></tr>
<tr><th id="1387">1387</th><td><i> * the 'DynamicStatic' struct.</i></td></tr>
<tr><th id="1388">1388</th><td><i> * Character pointer fields point to dynamic storage, unless otherwise stated.</i></td></tr>
<tr><th id="1389">1389</th><td><i> */</i></td></tr>
<tr><th id="1390">1390</th><td></td></tr>
<tr><th id="1391">1391</th><td><b>struct</b> <a class="type" href="multihandle.h.html#Curl_multi" title='Curl_multi' data-ref="Curl_multi" id="Curl_multi">Curl_multi</a>;    <i>/* declared and used only in multi.c */</i></td></tr>
<tr><th id="1392">1392</th><td></td></tr>
<tr><th id="1393">1393</th><td><b>enum</b> <dfn class="type def" id="dupstring" title='dupstring' data-ref="dupstring">dupstring</dfn> {</td></tr>
<tr><th id="1394">1394</th><td>  <dfn class="enum" id="dupstring::STRING_CERT_ORIG" title='dupstring::STRING_CERT_ORIG' data-ref="dupstring::STRING_CERT_ORIG">STRING_CERT_ORIG</dfn>,       <i>/* client certificate file name */</i></td></tr>
<tr><th id="1395">1395</th><td>  <dfn class="enum" id="dupstring::STRING_CERT_PROXY" title='dupstring::STRING_CERT_PROXY' data-ref="dupstring::STRING_CERT_PROXY">STRING_CERT_PROXY</dfn>,      <i>/* client certificate file name */</i></td></tr>
<tr><th id="1396">1396</th><td>  <dfn class="enum" id="dupstring::STRING_CERT_TYPE_ORIG" title='dupstring::STRING_CERT_TYPE_ORIG' data-ref="dupstring::STRING_CERT_TYPE_ORIG">STRING_CERT_TYPE_ORIG</dfn>,  <i>/* format for certificate (default: PEM)*/</i></td></tr>
<tr><th id="1397">1397</th><td>  <dfn class="enum" id="dupstring::STRING_CERT_TYPE_PROXY" title='dupstring::STRING_CERT_TYPE_PROXY' data-ref="dupstring::STRING_CERT_TYPE_PROXY">STRING_CERT_TYPE_PROXY</dfn>, <i>/* format for certificate (default: PEM)*/</i></td></tr>
<tr><th id="1398">1398</th><td>  <dfn class="enum" id="dupstring::STRING_COOKIE" title='dupstring::STRING_COOKIE' data-ref="dupstring::STRING_COOKIE">STRING_COOKIE</dfn>,          <i>/* HTTP cookie string to send */</i></td></tr>
<tr><th id="1399">1399</th><td>  <dfn class="enum" id="dupstring::STRING_COOKIEJAR" title='dupstring::STRING_COOKIEJAR' data-ref="dupstring::STRING_COOKIEJAR">STRING_COOKIEJAR</dfn>,       <i>/* dump all cookies to this file */</i></td></tr>
<tr><th id="1400">1400</th><td>  <dfn class="enum" id="dupstring::STRING_CUSTOMREQUEST" title='dupstring::STRING_CUSTOMREQUEST' data-ref="dupstring::STRING_CUSTOMREQUEST">STRING_CUSTOMREQUEST</dfn>,   <i>/* HTTP/FTP/RTSP request/method to use */</i></td></tr>
<tr><th id="1401">1401</th><td>  <dfn class="enum" id="dupstring::STRING_DEFAULT_PROTOCOL" title='dupstring::STRING_DEFAULT_PROTOCOL' data-ref="dupstring::STRING_DEFAULT_PROTOCOL">STRING_DEFAULT_PROTOCOL</dfn>, <i>/* Protocol to use when the URL doesn't specify */</i></td></tr>
<tr><th id="1402">1402</th><td>  <dfn class="enum" id="dupstring::STRING_DEVICE" title='dupstring::STRING_DEVICE' data-ref="dupstring::STRING_DEVICE">STRING_DEVICE</dfn>,          <i>/* local network interface/address to use */</i></td></tr>
<tr><th id="1403">1403</th><td>  <dfn class="enum" id="dupstring::STRING_ENCODING" title='dupstring::STRING_ENCODING' data-ref="dupstring::STRING_ENCODING">STRING_ENCODING</dfn>,        <i>/* Accept-Encoding string */</i></td></tr>
<tr><th id="1404">1404</th><td>  <dfn class="enum" id="dupstring::STRING_FTP_ACCOUNT" title='dupstring::STRING_FTP_ACCOUNT' data-ref="dupstring::STRING_FTP_ACCOUNT">STRING_FTP_ACCOUNT</dfn>,     <i>/* ftp account data */</i></td></tr>
<tr><th id="1405">1405</th><td>  <dfn class="enum" id="dupstring::STRING_FTP_ALTERNATIVE_TO_USER" title='dupstring::STRING_FTP_ALTERNATIVE_TO_USER' data-ref="dupstring::STRING_FTP_ALTERNATIVE_TO_USER">STRING_FTP_ALTERNATIVE_TO_USER</dfn>, <i>/* command to send if USER/PASS fails */</i></td></tr>
<tr><th id="1406">1406</th><td>  <dfn class="enum" id="dupstring::STRING_FTPPORT" title='dupstring::STRING_FTPPORT' data-ref="dupstring::STRING_FTPPORT">STRING_FTPPORT</dfn>,         <i>/* port to send with the FTP PORT command */</i></td></tr>
<tr><th id="1407">1407</th><td>  <dfn class="enum" id="dupstring::STRING_KEY_ORIG" title='dupstring::STRING_KEY_ORIG' data-ref="dupstring::STRING_KEY_ORIG">STRING_KEY_ORIG</dfn>,        <i>/* private key file name */</i></td></tr>
<tr><th id="1408">1408</th><td>  <dfn class="enum" id="dupstring::STRING_KEY_PROXY" title='dupstring::STRING_KEY_PROXY' data-ref="dupstring::STRING_KEY_PROXY">STRING_KEY_PROXY</dfn>,       <i>/* private key file name */</i></td></tr>
<tr><th id="1409">1409</th><td>  <dfn class="enum" id="dupstring::STRING_KEY_PASSWD_ORIG" title='dupstring::STRING_KEY_PASSWD_ORIG' data-ref="dupstring::STRING_KEY_PASSWD_ORIG">STRING_KEY_PASSWD_ORIG</dfn>, <i>/* plain text private key password */</i></td></tr>
<tr><th id="1410">1410</th><td>  <dfn class="enum" id="dupstring::STRING_KEY_PASSWD_PROXY" title='dupstring::STRING_KEY_PASSWD_PROXY' data-ref="dupstring::STRING_KEY_PASSWD_PROXY">STRING_KEY_PASSWD_PROXY</dfn>, <i>/* plain text private key password */</i></td></tr>
<tr><th id="1411">1411</th><td>  <dfn class="enum" id="dupstring::STRING_KEY_TYPE_ORIG" title='dupstring::STRING_KEY_TYPE_ORIG' data-ref="dupstring::STRING_KEY_TYPE_ORIG">STRING_KEY_TYPE_ORIG</dfn>,   <i>/* format for private key (default: PEM) */</i></td></tr>
<tr><th id="1412">1412</th><td>  <dfn class="enum" id="dupstring::STRING_KEY_TYPE_PROXY" title='dupstring::STRING_KEY_TYPE_PROXY' data-ref="dupstring::STRING_KEY_TYPE_PROXY">STRING_KEY_TYPE_PROXY</dfn>,  <i>/* format for private key (default: PEM) */</i></td></tr>
<tr><th id="1413">1413</th><td>  <dfn class="enum" id="dupstring::STRING_KRB_LEVEL" title='dupstring::STRING_KRB_LEVEL' data-ref="dupstring::STRING_KRB_LEVEL">STRING_KRB_LEVEL</dfn>,       <i>/* krb security level */</i></td></tr>
<tr><th id="1414">1414</th><td>  <dfn class="enum" id="dupstring::STRING_NETRC_FILE" title='dupstring::STRING_NETRC_FILE' data-ref="dupstring::STRING_NETRC_FILE">STRING_NETRC_FILE</dfn>,      <i>/* if not NULL, use this instead of trying to find</i></td></tr>
<tr><th id="1415">1415</th><td><i>                             $HOME/.netrc */</i></td></tr>
<tr><th id="1416">1416</th><td>  <dfn class="enum" id="dupstring::STRING_PROXY" title='dupstring::STRING_PROXY' data-ref="dupstring::STRING_PROXY">STRING_PROXY</dfn>,           <i>/* proxy to use */</i></td></tr>
<tr><th id="1417">1417</th><td>  <dfn class="enum" id="dupstring::STRING_PRE_PROXY" title='dupstring::STRING_PRE_PROXY' data-ref="dupstring::STRING_PRE_PROXY">STRING_PRE_PROXY</dfn>,       <i>/* pre socks proxy to use */</i></td></tr>
<tr><th id="1418">1418</th><td>  <dfn class="enum" id="dupstring::STRING_SET_RANGE" title='dupstring::STRING_SET_RANGE' data-ref="dupstring::STRING_SET_RANGE">STRING_SET_RANGE</dfn>,       <i>/* range, if used */</i></td></tr>
<tr><th id="1419">1419</th><td>  <dfn class="enum" id="dupstring::STRING_SET_REFERER" title='dupstring::STRING_SET_REFERER' data-ref="dupstring::STRING_SET_REFERER">STRING_SET_REFERER</dfn>,     <i>/* custom string for the HTTP referer field */</i></td></tr>
<tr><th id="1420">1420</th><td>  <dfn class="enum" id="dupstring::STRING_SET_URL" title='dupstring::STRING_SET_URL' data-ref="dupstring::STRING_SET_URL">STRING_SET_URL</dfn>,         <i>/* what original URL to work on */</i></td></tr>
<tr><th id="1421">1421</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CAPATH_ORIG" title='dupstring::STRING_SSL_CAPATH_ORIG' data-ref="dupstring::STRING_SSL_CAPATH_ORIG">STRING_SSL_CAPATH_ORIG</dfn>, <i>/* CA directory name (doesn't work on windows) */</i></td></tr>
<tr><th id="1422">1422</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CAPATH_PROXY" title='dupstring::STRING_SSL_CAPATH_PROXY' data-ref="dupstring::STRING_SSL_CAPATH_PROXY">STRING_SSL_CAPATH_PROXY</dfn>, <i>/* CA directory name (doesn't work on windows) */</i></td></tr>
<tr><th id="1423">1423</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CAFILE_ORIG" title='dupstring::STRING_SSL_CAFILE_ORIG' data-ref="dupstring::STRING_SSL_CAFILE_ORIG">STRING_SSL_CAFILE_ORIG</dfn>, <i>/* certificate file to verify peer against */</i></td></tr>
<tr><th id="1424">1424</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CAFILE_PROXY" title='dupstring::STRING_SSL_CAFILE_PROXY' data-ref="dupstring::STRING_SSL_CAFILE_PROXY">STRING_SSL_CAFILE_PROXY</dfn>, <i>/* certificate file to verify peer against */</i></td></tr>
<tr><th id="1425">1425</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_PINNEDPUBLICKEY_ORIG" title='dupstring::STRING_SSL_PINNEDPUBLICKEY_ORIG' data-ref="dupstring::STRING_SSL_PINNEDPUBLICKEY_ORIG">STRING_SSL_PINNEDPUBLICKEY_ORIG</dfn>, <i>/* public key file to verify peer against */</i></td></tr>
<tr><th id="1426">1426</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_PINNEDPUBLICKEY_PROXY" title='dupstring::STRING_SSL_PINNEDPUBLICKEY_PROXY' data-ref="dupstring::STRING_SSL_PINNEDPUBLICKEY_PROXY">STRING_SSL_PINNEDPUBLICKEY_PROXY</dfn>, <i>/* public key file to verify proxy */</i></td></tr>
<tr><th id="1427">1427</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CIPHER_LIST_ORIG" title='dupstring::STRING_SSL_CIPHER_LIST_ORIG' data-ref="dupstring::STRING_SSL_CIPHER_LIST_ORIG">STRING_SSL_CIPHER_LIST_ORIG</dfn>, <i>/* list of ciphers to use */</i></td></tr>
<tr><th id="1428">1428</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CIPHER_LIST_PROXY" title='dupstring::STRING_SSL_CIPHER_LIST_PROXY' data-ref="dupstring::STRING_SSL_CIPHER_LIST_PROXY">STRING_SSL_CIPHER_LIST_PROXY</dfn>, <i>/* list of ciphers to use */</i></td></tr>
<tr><th id="1429">1429</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_EGDSOCKET" title='dupstring::STRING_SSL_EGDSOCKET' data-ref="dupstring::STRING_SSL_EGDSOCKET">STRING_SSL_EGDSOCKET</dfn>,   <i>/* path to file containing the EGD daemon socket */</i></td></tr>
<tr><th id="1430">1430</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_RANDOM_FILE" title='dupstring::STRING_SSL_RANDOM_FILE' data-ref="dupstring::STRING_SSL_RANDOM_FILE">STRING_SSL_RANDOM_FILE</dfn>, <i>/* path to file containing "random" data */</i></td></tr>
<tr><th id="1431">1431</th><td>  <dfn class="enum" id="dupstring::STRING_USERAGENT" title='dupstring::STRING_USERAGENT' data-ref="dupstring::STRING_USERAGENT">STRING_USERAGENT</dfn>,       <i>/* User-Agent string */</i></td></tr>
<tr><th id="1432">1432</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CRLFILE_ORIG" title='dupstring::STRING_SSL_CRLFILE_ORIG' data-ref="dupstring::STRING_SSL_CRLFILE_ORIG">STRING_SSL_CRLFILE_ORIG</dfn>, <i>/* crl file to check certificate */</i></td></tr>
<tr><th id="1433">1433</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_CRLFILE_PROXY" title='dupstring::STRING_SSL_CRLFILE_PROXY' data-ref="dupstring::STRING_SSL_CRLFILE_PROXY">STRING_SSL_CRLFILE_PROXY</dfn>, <i>/* crl file to check certificate */</i></td></tr>
<tr><th id="1434">1434</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_ISSUERCERT_ORIG" title='dupstring::STRING_SSL_ISSUERCERT_ORIG' data-ref="dupstring::STRING_SSL_ISSUERCERT_ORIG">STRING_SSL_ISSUERCERT_ORIG</dfn>, <i>/* issuer cert file to check certificate */</i></td></tr>
<tr><th id="1435">1435</th><td>  <dfn class="enum" id="dupstring::STRING_SSL_ISSUERCERT_PROXY" title='dupstring::STRING_SSL_ISSUERCERT_PROXY' data-ref="dupstring::STRING_SSL_ISSUERCERT_PROXY">STRING_SSL_ISSUERCERT_PROXY</dfn>, <i>/* issuer cert file to check certificate */</i></td></tr>
<tr><th id="1436">1436</th><td>  <dfn class="enum" id="dupstring::STRING_USERNAME" title='dupstring::STRING_USERNAME' data-ref="dupstring::STRING_USERNAME">STRING_USERNAME</dfn>,        <i>/* &lt;username&gt;, if used */</i></td></tr>
<tr><th id="1437">1437</th><td>  <dfn class="enum" id="dupstring::STRING_PASSWORD" title='dupstring::STRING_PASSWORD' data-ref="dupstring::STRING_PASSWORD">STRING_PASSWORD</dfn>,        <i>/* &lt;password&gt;, if used */</i></td></tr>
<tr><th id="1438">1438</th><td>  <dfn class="enum" id="dupstring::STRING_OPTIONS" title='dupstring::STRING_OPTIONS' data-ref="dupstring::STRING_OPTIONS">STRING_OPTIONS</dfn>,         <i>/* &lt;options&gt;, if used */</i></td></tr>
<tr><th id="1439">1439</th><td>  <dfn class="enum" id="dupstring::STRING_PROXYUSERNAME" title='dupstring::STRING_PROXYUSERNAME' data-ref="dupstring::STRING_PROXYUSERNAME">STRING_PROXYUSERNAME</dfn>,   <i>/* Proxy &lt;username&gt;, if used */</i></td></tr>
<tr><th id="1440">1440</th><td>  <dfn class="enum" id="dupstring::STRING_PROXYPASSWORD" title='dupstring::STRING_PROXYPASSWORD' data-ref="dupstring::STRING_PROXYPASSWORD">STRING_PROXYPASSWORD</dfn>,   <i>/* Proxy &lt;password&gt;, if used */</i></td></tr>
<tr><th id="1441">1441</th><td>  <dfn class="enum" id="dupstring::STRING_NOPROXY" title='dupstring::STRING_NOPROXY' data-ref="dupstring::STRING_NOPROXY">STRING_NOPROXY</dfn>,         <i>/* List of hosts which should not use the proxy, if</i></td></tr>
<tr><th id="1442">1442</th><td><i>                             used */</i></td></tr>
<tr><th id="1443">1443</th><td>  <dfn class="enum" id="dupstring::STRING_RTSP_SESSION_ID" title='dupstring::STRING_RTSP_SESSION_ID' data-ref="dupstring::STRING_RTSP_SESSION_ID">STRING_RTSP_SESSION_ID</dfn>, <i>/* Session ID to use */</i></td></tr>
<tr><th id="1444">1444</th><td>  <dfn class="enum" id="dupstring::STRING_RTSP_STREAM_URI" title='dupstring::STRING_RTSP_STREAM_URI' data-ref="dupstring::STRING_RTSP_STREAM_URI">STRING_RTSP_STREAM_URI</dfn>, <i>/* Stream URI for this request */</i></td></tr>
<tr><th id="1445">1445</th><td>  <dfn class="enum" id="dupstring::STRING_RTSP_TRANSPORT" title='dupstring::STRING_RTSP_TRANSPORT' data-ref="dupstring::STRING_RTSP_TRANSPORT">STRING_RTSP_TRANSPORT</dfn>,  <i>/* Transport for this session */</i></td></tr>
<tr><th id="1446">1446</th><td><u>#<span data-ppcond="1446">ifdef</span> <span class="macro" data-ref="_M/USE_LIBSSH2">USE_LIBSSH2</span></u></td></tr>
<tr><th id="1447">1447</th><td>  STRING_SSH_PRIVATE_KEY, <i>/* path to the private key file for auth */</i></td></tr>
<tr><th id="1448">1448</th><td>  STRING_SSH_PUBLIC_KEY,  <i>/* path to the public key file for auth */</i></td></tr>
<tr><th id="1449">1449</th><td>  STRING_SSH_HOST_PUBLIC_KEY_MD5, <i>/* md5 of host public key in ascii hex */</i></td></tr>
<tr><th id="1450">1450</th><td>  STRING_SSH_KNOWNHOSTS,  <i>/* file name of knownhosts file */</i></td></tr>
<tr><th id="1451">1451</th><td><u>#<span data-ppcond="1446">endif</span></u></td></tr>
<tr><th id="1452">1452</th><td><u>#<span data-ppcond="1452">if</span> defined(<span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span>) || defined(<span class="macro" data-ref="_M/USE_WINDOWS_SSPI">USE_WINDOWS_SSPI</span>)</u></td></tr>
<tr><th id="1453">1453</th><td>  STRING_PROXY_SERVICE_NAME, <i>/* Proxy service name */</i></td></tr>
<tr><th id="1454">1454</th><td><u>#<span data-ppcond="1452">endif</span></u></td></tr>
<tr><th id="1455">1455</th><td><u>#<span data-ppcond="1455">if</span> !defined(<span class="macro" data-ref="_M/CURL_DISABLE_CRYPTO_AUTH">CURL_DISABLE_CRYPTO_AUTH</span>) || defined(<span class="macro" data-ref="_M/USE_KERBEROS5">USE_KERBEROS5</span>) || \</u></td></tr>
<tr><th id="1456">1456</th><td><u>  defined(<span class="macro" data-ref="_M/USE_SPNEGO">USE_SPNEGO</span>) || defined(<span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span>)</u></td></tr>
<tr><th id="1457">1457</th><td>  <dfn class="enum" id="dupstring::STRING_SERVICE_NAME" title='dupstring::STRING_SERVICE_NAME' data-ref="dupstring::STRING_SERVICE_NAME">STRING_SERVICE_NAME</dfn>,    <i>/* Service name */</i></td></tr>
<tr><th id="1458">1458</th><td><u>#<span data-ppcond="1455">endif</span></u></td></tr>
<tr><th id="1459">1459</th><td>  <dfn class="enum" id="dupstring::STRING_MAIL_FROM" title='dupstring::STRING_MAIL_FROM' data-ref="dupstring::STRING_MAIL_FROM">STRING_MAIL_FROM</dfn>,</td></tr>
<tr><th id="1460">1460</th><td>  <dfn class="enum" id="dupstring::STRING_MAIL_AUTH" title='dupstring::STRING_MAIL_AUTH' data-ref="dupstring::STRING_MAIL_AUTH">STRING_MAIL_AUTH</dfn>,</td></tr>
<tr><th id="1461">1461</th><td></td></tr>
<tr><th id="1462">1462</th><td><u>#<span data-ppcond="1462">ifdef</span> <span class="macro" data-ref="_M/USE_TLS_SRP">USE_TLS_SRP</span></u></td></tr>
<tr><th id="1463">1463</th><td>  STRING_TLSAUTH_USERNAME_ORIG,  <i>/* TLS auth &lt;username&gt; */</i></td></tr>
<tr><th id="1464">1464</th><td>  STRING_TLSAUTH_USERNAME_PROXY, <i>/* TLS auth &lt;username&gt; */</i></td></tr>
<tr><th id="1465">1465</th><td>  STRING_TLSAUTH_PASSWORD_ORIG,  <i>/* TLS auth &lt;password&gt; */</i></td></tr>
<tr><th id="1466">1466</th><td>  STRING_TLSAUTH_PASSWORD_PROXY, <i>/* TLS auth &lt;password&gt; */</i></td></tr>
<tr><th id="1467">1467</th><td><u>#<span data-ppcond="1462">endif</span></u></td></tr>
<tr><th id="1468">1468</th><td>  <dfn class="enum" id="dupstring::STRING_BEARER" title='dupstring::STRING_BEARER' data-ref="dupstring::STRING_BEARER">STRING_BEARER</dfn>,                <i>/* &lt;bearer&gt;, if used */</i></td></tr>
<tr><th id="1469">1469</th><td><u>#<span data-ppcond="1469">ifdef</span> <a class="macro" href="curl_config.h.html#955" data-ref="_M/USE_UNIX_SOCKETS">USE_UNIX_SOCKETS</a></u></td></tr>
<tr><th id="1470">1470</th><td>  <dfn class="enum" id="dupstring::STRING_UNIX_SOCKET_PATH" title='dupstring::STRING_UNIX_SOCKET_PATH' data-ref="dupstring::STRING_UNIX_SOCKET_PATH">STRING_UNIX_SOCKET_PATH</dfn>,      <i>/* path to Unix socket, if used */</i></td></tr>
<tr><th id="1471">1471</th><td><u>#<span data-ppcond="1469">endif</span></u></td></tr>
<tr><th id="1472">1472</th><td>  <dfn class="enum" id="dupstring::STRING_TARGET" title='dupstring::STRING_TARGET' data-ref="dupstring::STRING_TARGET">STRING_TARGET</dfn>,                <i>/* CURLOPT_REQUEST_TARGET */</i></td></tr>
<tr><th id="1473">1473</th><td>  <i>/* -- end of zero-terminated strings -- */</i></td></tr>
<tr><th id="1474">1474</th><td></td></tr>
<tr><th id="1475">1475</th><td>  <dfn class="enum" id="dupstring::STRING_LASTZEROTERMINATED" title='dupstring::STRING_LASTZEROTERMINATED' data-ref="dupstring::STRING_LASTZEROTERMINATED">STRING_LASTZEROTERMINATED</dfn>,</td></tr>
<tr><th id="1476">1476</th><td></td></tr>
<tr><th id="1477">1477</th><td>  <i>/* -- below this are pointers to binary data that cannot be strdup'ed.</i></td></tr>
<tr><th id="1478">1478</th><td><i>     Each such pointer must be added manually to Curl_dupset() --- */</i></td></tr>
<tr><th id="1479">1479</th><td></td></tr>
<tr><th id="1480">1480</th><td>  <dfn class="enum" id="dupstring::STRING_COPYPOSTFIELDS" title='dupstring::STRING_COPYPOSTFIELDS' data-ref="dupstring::STRING_COPYPOSTFIELDS">STRING_COPYPOSTFIELDS</dfn>,  <i>/* if POST, set the fields' values here */</i></td></tr>
<tr><th id="1481">1481</th><td></td></tr>
<tr><th id="1482">1482</th><td>  <dfn class="enum" id="dupstring::STRING_LAST" title='dupstring::STRING_LAST' data-ref="dupstring::STRING_LAST">STRING_LAST</dfn> <i>/* not used, just an end-of-list marker */</i></td></tr>
<tr><th id="1483">1483</th><td>};</td></tr>
<tr><th id="1484">1484</th><td></td></tr>
<tr><th id="1485">1485</th><td><b>struct</b> <dfn class="type def" id="UserDefined" title='UserDefined' data-ref="UserDefined">UserDefined</dfn> {</td></tr>
<tr><th id="1486">1486</th><td>  <a class="typedef" href="../../include/stdio.h.html#FILE" title='FILE' data-type='struct _IO_FILE' data-ref="FILE">FILE</a> *<dfn class="decl" id="UserDefined::err" title='UserDefined::err' data-ref="UserDefined::err">err</dfn>;         <i>/* the stderr user data goes here */</i></td></tr>
<tr><th id="1487">1487</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::debugdata" title='UserDefined::debugdata' data-ref="UserDefined::debugdata">debugdata</dfn>;   <i>/* the data that will be passed to fdebug */</i></td></tr>
<tr><th id="1488">1488</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::errorbuffer" title='UserDefined::errorbuffer' data-ref="UserDefined::errorbuffer">errorbuffer</dfn>; <i>/* (Static) store failure messages in here */</i></td></tr>
<tr><th id="1489">1489</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::proxyport" title='UserDefined::proxyport' data-ref="UserDefined::proxyport">proxyport</dfn>; <i>/* If non-zero, use this port number by default. If the</i></td></tr>
<tr><th id="1490">1490</th><td><i>                     proxy string features a ":[port]" that one will override</i></td></tr>
<tr><th id="1491">1491</th><td><i>                     this. */</i></td></tr>
<tr><th id="1492">1492</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::out" title='UserDefined::out' data-ref="UserDefined::out">out</dfn>;         <i>/* CURLOPT_WRITEDATA */</i></td></tr>
<tr><th id="1493">1493</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::in_set" title='UserDefined::in_set' data-ref="UserDefined::in_set">in_set</dfn>;      <i>/* CURLOPT_READDATA */</i></td></tr>
<tr><th id="1494">1494</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::writeheader" title='UserDefined::writeheader' data-ref="UserDefined::writeheader">writeheader</dfn>; <i>/* write the header to this if non-NULL */</i></td></tr>
<tr><th id="1495">1495</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::rtp_out" title='UserDefined::rtp_out' data-ref="UserDefined::rtp_out">rtp_out</dfn>;     <i>/* write RTP to this if non-NULL */</i></td></tr>
<tr><th id="1496">1496</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::use_port" title='UserDefined::use_port' data-ref="UserDefined::use_port">use_port</dfn>;     <i>/* which port to use (when not using default) */</i></td></tr>
<tr><th id="1497">1497</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="UserDefined::httpauth" title='UserDefined::httpauth' data-ref="UserDefined::httpauth">httpauth</dfn>;  <i>/* kind of HTTP authentication to use (bitmask) */</i></td></tr>
<tr><th id="1498">1498</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="UserDefined::proxyauth" title='UserDefined::proxyauth' data-ref="UserDefined::proxyauth">proxyauth</dfn>; <i>/* kind of proxy authentication to use (bitmask) */</i></td></tr>
<tr><th id="1499">1499</th><td>  <em>unsigned</em> <em>long</em> <dfn class="decl" id="UserDefined::socks5auth" title='UserDefined::socks5auth' data-ref="UserDefined::socks5auth">socks5auth</dfn>;<i>/* kind of SOCKS5 authentication to use (bitmask) */</i></td></tr>
<tr><th id="1500">1500</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::followlocation" title='UserDefined::followlocation' data-ref="UserDefined::followlocation">followlocation</dfn>; <i>/* as in HTTP Location: */</i></td></tr>
<tr><th id="1501">1501</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::maxredirs" title='UserDefined::maxredirs' data-ref="UserDefined::maxredirs">maxredirs</dfn>;    <i>/* maximum no. of http(s) redirects to follow, set to -1</i></td></tr>
<tr><th id="1502">1502</th><td><i>                        for infinity */</i></td></tr>
<tr><th id="1503">1503</th><td></td></tr>
<tr><th id="1504">1504</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::keep_post" title='UserDefined::keep_post' data-ref="UserDefined::keep_post">keep_post</dfn>;     <i>/* keep POSTs as POSTs after a 30x request; each</i></td></tr>
<tr><th id="1505">1505</th><td><i>                        bit represents a request, from 301 to 303 */</i></td></tr>
<tr><th id="1506">1506</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::free_referer" title='UserDefined::free_referer' data-ref="UserDefined::free_referer">free_referer</dfn>; <i>/* set TRUE if 'referer' points to a string we</i></td></tr>
<tr><th id="1507">1507</th><td><i>                        allocated */</i></td></tr>
<tr><th id="1508">1508</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::postfields" title='UserDefined::postfields' data-ref="UserDefined::postfields">postfields</dfn>;  <i>/* if POST, set the fields' values here */</i></td></tr>
<tr><th id="1509">1509</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_seek_callback" title='curl_seek_callback' data-type='int (*)(void *, curl_off_t, int)' data-ref="curl_seek_callback">curl_seek_callback</a> <dfn class="decl" id="UserDefined::seek_func" title='UserDefined::seek_func' data-ref="UserDefined::seek_func">seek_func</dfn>;      <i>/* function that seeks the input */</i></td></tr>
<tr><th id="1510">1510</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::postfieldsize" title='UserDefined::postfieldsize' data-ref="UserDefined::postfieldsize">postfieldsize</dfn>; <i>/* if POST, this might have a size to use instead</i></td></tr>
<tr><th id="1511">1511</th><td><i>                               of strlen(), and then the data *may* be binary</i></td></tr>
<tr><th id="1512">1512</th><td><i>                               (contain zero bytes) */</i></td></tr>
<tr><th id="1513">1513</th><td>  <em>unsigned</em> <em>short</em> <dfn class="decl" id="UserDefined::localport" title='UserDefined::localport' data-ref="UserDefined::localport">localport</dfn>; <i>/* local port number to bind to */</i></td></tr>
<tr><th id="1514">1514</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::localportrange" title='UserDefined::localportrange' data-ref="UserDefined::localportrange">localportrange</dfn>; <i>/* number of additional port numbers to test in case the</i></td></tr>
<tr><th id="1515">1515</th><td><i>                         'localport' one can't be bind()ed */</i></td></tr>
<tr><th id="1516">1516</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_write_callback" title='curl_write_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_write_callback">curl_write_callback</a> <dfn class="decl" id="UserDefined::fwrite_func" title='UserDefined::fwrite_func' data-ref="UserDefined::fwrite_func">fwrite_func</dfn>;   <i>/* function that stores the output */</i></td></tr>
<tr><th id="1517">1517</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_write_callback" title='curl_write_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_write_callback">curl_write_callback</a> <dfn class="decl" id="UserDefined::fwrite_header" title='UserDefined::fwrite_header' data-ref="UserDefined::fwrite_header">fwrite_header</dfn>; <i>/* function that stores headers */</i></td></tr>
<tr><th id="1518">1518</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_write_callback" title='curl_write_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_write_callback">curl_write_callback</a> <dfn class="decl" id="UserDefined::fwrite_rtp" title='UserDefined::fwrite_rtp' data-ref="UserDefined::fwrite_rtp">fwrite_rtp</dfn>;    <i>/* function that stores interleaved RTP */</i></td></tr>
<tr><th id="1519">1519</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_read_callback" title='curl_read_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_read_callback">curl_read_callback</a> <dfn class="decl" id="UserDefined::fread_func_set" title='UserDefined::fread_func_set' data-ref="UserDefined::fread_func_set">fread_func_set</dfn>; <i>/* function that reads the input */</i></td></tr>
<tr><th id="1520">1520</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::is_fread_set" title='UserDefined::is_fread_set' data-ref="UserDefined::is_fread_set">is_fread_set</dfn>; <i>/* boolean, has read callback been set to non-NULL? */</i></td></tr>
<tr><th id="1521">1521</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::is_fwrite_set" title='UserDefined::is_fwrite_set' data-ref="UserDefined::is_fwrite_set">is_fwrite_set</dfn>; <i>/* boolean, has write callback been set to non-NULL? */</i></td></tr>
<tr><th id="1522">1522</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_progress_callback" title='curl_progress_callback' data-type='int (*)(void *, double, double, double, double)' data-ref="curl_progress_callback">curl_progress_callback</a> <dfn class="decl" id="UserDefined::fprogress" title='UserDefined::fprogress' data-ref="UserDefined::fprogress">fprogress</dfn>; <i>/* OLD and deprecated progress callback  */</i></td></tr>
<tr><th id="1523">1523</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_xferinfo_callback" title='curl_xferinfo_callback' data-type='int (*)(void *, curl_off_t, curl_off_t, curl_off_t, curl_off_t)' data-ref="curl_xferinfo_callback">curl_xferinfo_callback</a> <dfn class="decl" id="UserDefined::fxferinfo" title='UserDefined::fxferinfo' data-ref="UserDefined::fxferinfo">fxferinfo</dfn>; <i>/* progress callback */</i></td></tr>
<tr><th id="1524">1524</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_debug_callback" title='curl_debug_callback' data-type='int (*)(CURL *, curl_infotype, char *, size_t, void *)' data-ref="curl_debug_callback">curl_debug_callback</a> <dfn class="decl" id="UserDefined::fdebug" title='UserDefined::fdebug' data-ref="UserDefined::fdebug">fdebug</dfn>;      <i>/* function that write informational data */</i></td></tr>
<tr><th id="1525">1525</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_ioctl_callback" title='curl_ioctl_callback' data-type='curlioerr (*)(CURL *, int, void *)' data-ref="curl_ioctl_callback">curl_ioctl_callback</a> <dfn class="decl" id="UserDefined::ioctl_func" title='UserDefined::ioctl_func' data-ref="UserDefined::ioctl_func">ioctl_func</dfn>;  <i>/* function for I/O control */</i></td></tr>
<tr><th id="1526">1526</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_sockopt_callback" title='curl_sockopt_callback' data-type='int (*)(void *, curl_socket_t, curlsocktype)' data-ref="curl_sockopt_callback">curl_sockopt_callback</a> <dfn class="decl" id="UserDefined::fsockopt" title='UserDefined::fsockopt' data-ref="UserDefined::fsockopt">fsockopt</dfn>;  <i>/* function for setting socket options */</i></td></tr>
<tr><th id="1527">1527</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::sockopt_client" title='UserDefined::sockopt_client' data-ref="UserDefined::sockopt_client">sockopt_client</dfn>; <i>/* pointer to pass to the socket options callback */</i></td></tr>
<tr><th id="1528">1528</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_opensocket_callback" title='curl_opensocket_callback' data-type='curl_socket_t (*)(void *, curlsocktype, struct curl_sockaddr *)' data-ref="curl_opensocket_callback">curl_opensocket_callback</a> <dfn class="decl" id="UserDefined::fopensocket" title='UserDefined::fopensocket' data-ref="UserDefined::fopensocket">fopensocket</dfn>; <i>/* function for checking/translating</i></td></tr>
<tr><th id="1529">1529</th><td><i>                                           the address and opening the</i></td></tr>
<tr><th id="1530">1530</th><td><i>                                           socket */</i></td></tr>
<tr><th id="1531">1531</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::opensocket_client" title='UserDefined::opensocket_client' data-ref="UserDefined::opensocket_client">opensocket_client</dfn>;</td></tr>
<tr><th id="1532">1532</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_closesocket_callback" title='curl_closesocket_callback' data-type='int (*)(void *, curl_socket_t)' data-ref="curl_closesocket_callback">curl_closesocket_callback</a> <dfn class="decl" id="UserDefined::fclosesocket" title='UserDefined::fclosesocket' data-ref="UserDefined::fclosesocket">fclosesocket</dfn>; <i>/* function for closing the</i></td></tr>
<tr><th id="1533">1533</th><td><i>                                             socket */</i></td></tr>
<tr><th id="1534">1534</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::closesocket_client" title='UserDefined::closesocket_client' data-ref="UserDefined::closesocket_client">closesocket_client</dfn>;</td></tr>
<tr><th id="1535">1535</th><td></td></tr>
<tr><th id="1536">1536</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::seek_client" title='UserDefined::seek_client' data-ref="UserDefined::seek_client">seek_client</dfn>;    <i>/* pointer to pass to the seek callback */</i></td></tr>
<tr><th id="1537">1537</th><td>  <i>/* the 3 curl_conv_callback functions below are used on non-ASCII hosts */</i></td></tr>
<tr><th id="1538">1538</th><td>  <i>/* function to convert from the network encoding: */</i></td></tr>
<tr><th id="1539">1539</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_conv_callback" title='curl_conv_callback' data-type='CURLcode (*)(char *, size_t)' data-ref="curl_conv_callback">curl_conv_callback</a> <dfn class="decl" id="UserDefined::convfromnetwork" title='UserDefined::convfromnetwork' data-ref="UserDefined::convfromnetwork">convfromnetwork</dfn>;</td></tr>
<tr><th id="1540">1540</th><td>  <i>/* function to convert to the network encoding: */</i></td></tr>
<tr><th id="1541">1541</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_conv_callback" title='curl_conv_callback' data-type='CURLcode (*)(char *, size_t)' data-ref="curl_conv_callback">curl_conv_callback</a> <dfn class="decl" id="UserDefined::convtonetwork" title='UserDefined::convtonetwork' data-ref="UserDefined::convtonetwork">convtonetwork</dfn>;</td></tr>
<tr><th id="1542">1542</th><td>  <i>/* function to convert from UTF-8 encoding: */</i></td></tr>
<tr><th id="1543">1543</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_conv_callback" title='curl_conv_callback' data-type='CURLcode (*)(char *, size_t)' data-ref="curl_conv_callback">curl_conv_callback</a> <dfn class="decl" id="UserDefined::convfromutf8" title='UserDefined::convfromutf8' data-ref="UserDefined::convfromutf8">convfromutf8</dfn>;</td></tr>
<tr><th id="1544">1544</th><td></td></tr>
<tr><th id="1545">1545</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::progress_client" title='UserDefined::progress_client' data-ref="UserDefined::progress_client">progress_client</dfn>; <i>/* pointer to pass to the progress callback */</i></td></tr>
<tr><th id="1546">1546</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::ioctl_client" title='UserDefined::ioctl_client' data-ref="UserDefined::ioctl_client">ioctl_client</dfn>;   <i>/* pointer to pass to the ioctl callback */</i></td></tr>
<tr><th id="1547">1547</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::timeout" title='UserDefined::timeout' data-ref="UserDefined::timeout">timeout</dfn>;         <i>/* in milliseconds, 0 means no timeout */</i></td></tr>
<tr><th id="1548">1548</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::connecttimeout" title='UserDefined::connecttimeout' data-ref="UserDefined::connecttimeout">connecttimeout</dfn>;  <i>/* in milliseconds, 0 means no timeout */</i></td></tr>
<tr><th id="1549">1549</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::accepttimeout" title='UserDefined::accepttimeout' data-ref="UserDefined::accepttimeout">accepttimeout</dfn>;   <i>/* in milliseconds, 0 means no timeout */</i></td></tr>
<tr><th id="1550">1550</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::server_response_timeout" title='UserDefined::server_response_timeout' data-ref="UserDefined::server_response_timeout">server_response_timeout</dfn>; <i>/* in milliseconds, 0 means no timeout */</i></td></tr>
<tr><th id="1551">1551</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::tftp_blksize" title='UserDefined::tftp_blksize' data-ref="UserDefined::tftp_blksize">tftp_blksize</dfn>;    <i>/* in bytes, 0 means use default */</i></td></tr>
<tr><th id="1552">1552</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::tftp_no_options" title='UserDefined::tftp_no_options' data-ref="UserDefined::tftp_no_options">tftp_no_options</dfn>; <i>/* do not send TFTP options requests */</i></td></tr>
<tr><th id="1553">1553</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::filesize" title='UserDefined::filesize' data-ref="UserDefined::filesize">filesize</dfn>;  <i>/* size of file to upload, -1 means unknown */</i></td></tr>
<tr><th id="1554">1554</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::low_speed_limit" title='UserDefined::low_speed_limit' data-ref="UserDefined::low_speed_limit">low_speed_limit</dfn>; <i>/* bytes/second */</i></td></tr>
<tr><th id="1555">1555</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::low_speed_time" title='UserDefined::low_speed_time' data-ref="UserDefined::low_speed_time">low_speed_time</dfn>;  <i>/* number of seconds */</i></td></tr>
<tr><th id="1556">1556</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::max_send_speed" title='UserDefined::max_send_speed' data-ref="UserDefined::max_send_speed">max_send_speed</dfn>; <i>/* high speed limit in bytes/second for upload */</i></td></tr>
<tr><th id="1557">1557</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::max_recv_speed" title='UserDefined::max_recv_speed' data-ref="UserDefined::max_recv_speed">max_recv_speed</dfn>; <i>/* high speed limit in bytes/second for</i></td></tr>
<tr><th id="1558">1558</th><td><i>                                download */</i></td></tr>
<tr><th id="1559">1559</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::set_resume_from" title='UserDefined::set_resume_from' data-ref="UserDefined::set_resume_from">set_resume_from</dfn>;  <i>/* continue [ftp] transfer from here */</i></td></tr>
<tr><th id="1560">1560</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::headers" title='UserDefined::headers' data-ref="UserDefined::headers">headers</dfn>; <i>/* linked list of extra headers */</i></td></tr>
<tr><th id="1561">1561</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::proxyheaders" title='UserDefined::proxyheaders' data-ref="UserDefined::proxyheaders">proxyheaders</dfn>; <i>/* linked list of extra CONNECT headers */</i></td></tr>
<tr><th id="1562">1562</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_httppost" title='curl_httppost' data-ref="curl_httppost">curl_httppost</a> *<dfn class="decl" id="UserDefined::httppost" title='UserDefined::httppost' data-ref="UserDefined::httppost">httppost</dfn>;  <i>/* linked list of old POST data */</i></td></tr>
<tr><th id="1563">1563</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_mimepart" title='curl_mimepart' data-type='struct curl_mimepart_s' data-ref="curl_mimepart">curl_mimepart</a> <dfn class="decl" id="UserDefined::mimepost" title='UserDefined::mimepost' data-ref="UserDefined::mimepost">mimepost</dfn>;  <i>/* MIME/POST data. */</i></td></tr>
<tr><th id="1564">1564</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::sep_headers" title='UserDefined::sep_headers' data-ref="UserDefined::sep_headers">sep_headers</dfn>;     <i>/* handle host and proxy headers separately */</i></td></tr>
<tr><th id="1565">1565</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::cookiesession" title='UserDefined::cookiesession' data-ref="UserDefined::cookiesession">cookiesession</dfn>;   <i>/* new cookie session? */</i></td></tr>
<tr><th id="1566">1566</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::crlf" title='UserDefined::crlf' data-ref="UserDefined::crlf">crlf</dfn>;            <i>/* convert crlf on ftp upload(?) */</i></td></tr>
<tr><th id="1567">1567</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::quote" title='UserDefined::quote' data-ref="UserDefined::quote">quote</dfn>;     <i>/* after connection is established */</i></td></tr>
<tr><th id="1568">1568</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::postquote" title='UserDefined::postquote' data-ref="UserDefined::postquote">postquote</dfn>; <i>/* after the transfer */</i></td></tr>
<tr><th id="1569">1569</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::prequote" title='UserDefined::prequote' data-ref="UserDefined::prequote">prequote</dfn>; <i>/* before the transfer, after type */</i></td></tr>
<tr><th id="1570">1570</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::source_quote" title='UserDefined::source_quote' data-ref="UserDefined::source_quote">source_quote</dfn>;  <i>/* 3rd party quote */</i></td></tr>
<tr><th id="1571">1571</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::source_prequote" title='UserDefined::source_prequote' data-ref="UserDefined::source_prequote">source_prequote</dfn>;  <i>/* in 3rd party transfer mode - before</i></td></tr>
<tr><th id="1572">1572</th><td><i>                                          the transfer on source host */</i></td></tr>
<tr><th id="1573">1573</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::source_postquote" title='UserDefined::source_postquote' data-ref="UserDefined::source_postquote">source_postquote</dfn>; <i>/* in 3rd party transfer mode - after</i></td></tr>
<tr><th id="1574">1574</th><td><i>                                          the transfer on source host */</i></td></tr>
<tr><th id="1575">1575</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::telnet_options" title='UserDefined::telnet_options' data-ref="UserDefined::telnet_options">telnet_options</dfn>; <i>/* linked list of telnet options */</i></td></tr>
<tr><th id="1576">1576</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::resolve" title='UserDefined::resolve' data-ref="UserDefined::resolve">resolve</dfn>;     <i>/* list of names to add/remove from</i></td></tr>
<tr><th id="1577">1577</th><td><i>                                     DNS cache */</i></td></tr>
<tr><th id="1578">1578</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::connect_to" title='UserDefined::connect_to' data-ref="UserDefined::connect_to">connect_to</dfn>; <i>/* list of host:port mappings to override</i></td></tr>
<tr><th id="1579">1579</th><td><i>                                    the hostname and port to connect to */</i></td></tr>
<tr><th id="1580">1580</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_TimeCond" title='curl_TimeCond' data-type='enum curl_TimeCond' data-ref="curl_TimeCond">curl_TimeCond</a> <dfn class="decl" id="UserDefined::timecondition" title='UserDefined::timecondition' data-ref="UserDefined::timecondition">timecondition</dfn>; <i>/* kind of time/date comparison */</i></td></tr>
<tr><th id="1581">1581</th><td>  <a class="typedef" href="../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="UserDefined::timevalue" title='UserDefined::timevalue' data-ref="UserDefined::timevalue">timevalue</dfn>;       <i>/* what time to compare with */</i></td></tr>
<tr><th id="1582">1582</th><td>  <a class="typedef" href="#Curl_HttpReq" title='Curl_HttpReq' data-type='enum Curl_HttpReq' data-ref="Curl_HttpReq">Curl_HttpReq</a> <dfn class="decl" id="UserDefined::httpreq" title='UserDefined::httpreq' data-ref="UserDefined::httpreq">httpreq</dfn>;   <i>/* what kind of HTTP request (if any) is this */</i></td></tr>
<tr><th id="1583">1583</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::httpversion" title='UserDefined::httpversion' data-ref="UserDefined::httpversion">httpversion</dfn>; <i>/* when non-zero, a specific HTTP version requested to</i></td></tr>
<tr><th id="1584">1584</th><td><i>                       be used in the library's request(s) */</i></td></tr>
<tr><th id="1585">1585</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::strip_path_slash" title='UserDefined::strip_path_slash' data-ref="UserDefined::strip_path_slash">strip_path_slash</dfn>; <i>/* strip off initial slash from path */</i></td></tr>
<tr><th id="1586">1586</th><td>  <b>struct</b> <a class="type" href="#ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</a> <dfn class="decl" id="UserDefined::ssl" title='UserDefined::ssl' data-ref="UserDefined::ssl">ssl</dfn>;  <i>/* user defined SSL stuff */</i></td></tr>
<tr><th id="1587">1587</th><td>  <b>struct</b> <a class="type" href="#ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</a> <dfn class="decl" id="UserDefined::proxy_ssl" title='UserDefined::proxy_ssl' data-ref="UserDefined::proxy_ssl">proxy_ssl</dfn>;  <i>/* user defined SSL stuff for proxy */</i></td></tr>
<tr><th id="1588">1588</th><td>  <b>struct</b> <a class="type" href="#ssl_general_config" title='ssl_general_config' data-ref="ssl_general_config">ssl_general_config</a> <dfn class="decl" id="UserDefined::general_ssl" title='UserDefined::general_ssl' data-ref="UserDefined::general_ssl">general_ssl</dfn>; <i>/* general user defined SSL stuff */</i></td></tr>
<tr><th id="1589">1589</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_proxytype" title='curl_proxytype' data-type='enum curl_proxytype' data-ref="curl_proxytype">curl_proxytype</a> <dfn class="decl" id="UserDefined::proxytype" title='UserDefined::proxytype' data-ref="UserDefined::proxytype">proxytype</dfn>; <i>/* what kind of proxy that is in use */</i></td></tr>
<tr><th id="1590">1590</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::dns_cache_timeout" title='UserDefined::dns_cache_timeout' data-ref="UserDefined::dns_cache_timeout">dns_cache_timeout</dfn>; <i>/* DNS cache timeout */</i></td></tr>
<tr><th id="1591">1591</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::buffer_size" title='UserDefined::buffer_size' data-ref="UserDefined::buffer_size">buffer_size</dfn>;      <i>/* size of receive buffer to use */</i></td></tr>
<tr><th id="1592">1592</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::private_data" title='UserDefined::private_data' data-ref="UserDefined::private_data">private_data</dfn>; <i>/* application-private data */</i></td></tr>
<tr><th id="1593">1593</th><td></td></tr>
<tr><th id="1594">1594</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::http200aliases" title='UserDefined::http200aliases' data-ref="UserDefined::http200aliases">http200aliases</dfn>; <i>/* linked list of aliases for http200 */</i></td></tr>
<tr><th id="1595">1595</th><td></td></tr>
<tr><th id="1596">1596</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::ipver" title='UserDefined::ipver' data-ref="UserDefined::ipver">ipver</dfn>; <i>/* the CURL_IPRESOLVE_* defines in the public header file</i></td></tr>
<tr><th id="1597">1597</th><td><i>                 0 - whatever, 1 - v2, 2 - v6 */</i></td></tr>
<tr><th id="1598">1598</th><td></td></tr>
<tr><th id="1599">1599</th><td>  <a class="typedef" href="../include/curl/system.h.html#curl_off_t" title='curl_off_t' data-type='long' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::max_filesize" title='UserDefined::max_filesize' data-ref="UserDefined::max_filesize">max_filesize</dfn>; <i>/* Maximum file size to download */</i></td></tr>
<tr><th id="1600">1600</th><td></td></tr>
<tr><th id="1601">1601</th><td>  <a class="typedef" href="ftp.h.html#curl_ftpfile" title='curl_ftpfile' data-type='enum curl_ftpfile' data-ref="curl_ftpfile">curl_ftpfile</a> <dfn class="decl" id="UserDefined::ftp_filemethod" title='UserDefined::ftp_filemethod' data-ref="UserDefined::ftp_filemethod">ftp_filemethod</dfn>; <i>/* how to get to a file when FTP is used  */</i></td></tr>
<tr><th id="1602">1602</th><td></td></tr>
<tr><th id="1603">1603</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::ftp_create_missing_dirs" title='UserDefined::ftp_create_missing_dirs' data-ref="UserDefined::ftp_create_missing_dirs">ftp_create_missing_dirs</dfn>; <i>/* 1 - create directories that don't exist</i></td></tr>
<tr><th id="1604">1604</th><td><i>                                  2 - the same but also allow MKD to fail once</i></td></tr>
<tr><th id="1605">1605</th><td><i>                               */</i></td></tr>
<tr><th id="1606">1606</th><td></td></tr>
<tr><th id="1607">1607</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_sshkeycallback" title='curl_sshkeycallback' data-type='int (*)(CURL *, const struct curl_khkey *, const struct curl_khkey *, enum curl_khmatch, void *)' data-ref="curl_sshkeycallback">curl_sshkeycallback</a> <dfn class="decl" id="UserDefined::ssh_keyfunc" title='UserDefined::ssh_keyfunc' data-ref="UserDefined::ssh_keyfunc">ssh_keyfunc</dfn>; <i>/* key matching callback */</i></td></tr>
<tr><th id="1608">1608</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::ssh_keyfunc_userp" title='UserDefined::ssh_keyfunc_userp' data-ref="UserDefined::ssh_keyfunc_userp">ssh_keyfunc_userp</dfn>;         <i>/* custom pointer to callback */</i></td></tr>
<tr><th id="1609">1609</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ssh_compression" title='UserDefined::ssh_compression' data-ref="UserDefined::ssh_compression">ssh_compression</dfn>;            <i>/* enable SSH compression */</i></td></tr>
<tr><th id="1610">1610</th><td></td></tr>
<tr><th id="1611">1611</th><td><i>/* Here follows boolean settings that define how to behave during</i></td></tr>
<tr><th id="1612">1612</th><td><i>   this session. They are STATIC, set by libcurl users or at least initially</i></td></tr>
<tr><th id="1613">1613</th><td><i>   and they don't change during operations. */</i></td></tr>
<tr><th id="1614">1614</th><td></td></tr>
<tr><th id="1615">1615</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::printhost" title='UserDefined::printhost' data-ref="UserDefined::printhost">printhost</dfn>;        <i>/* printing host name in debug info */</i></td></tr>
<tr><th id="1616">1616</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::get_filetime" title='UserDefined::get_filetime' data-ref="UserDefined::get_filetime">get_filetime</dfn>;     <i>/* get the time and get of the remote file */</i></td></tr>
<tr><th id="1617">1617</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::tunnel_thru_httpproxy" title='UserDefined::tunnel_thru_httpproxy' data-ref="UserDefined::tunnel_thru_httpproxy">tunnel_thru_httpproxy</dfn>; <i>/* use CONNECT through a HTTP proxy */</i></td></tr>
<tr><th id="1618">1618</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::prefer_ascii" title='UserDefined::prefer_ascii' data-ref="UserDefined::prefer_ascii">prefer_ascii</dfn>;     <i>/* ASCII rather than binary */</i></td></tr>
<tr><th id="1619">1619</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_append" title='UserDefined::ftp_append' data-ref="UserDefined::ftp_append">ftp_append</dfn>;       <i>/* append, not overwrite, on upload */</i></td></tr>
<tr><th id="1620">1620</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_list_only" title='UserDefined::ftp_list_only' data-ref="UserDefined::ftp_list_only">ftp_list_only</dfn>;    <i>/* switch FTP command for listing directories */</i></td></tr>
<tr><th id="1621">1621</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_use_port" title='UserDefined::ftp_use_port' data-ref="UserDefined::ftp_use_port">ftp_use_port</dfn>;     <i>/* use the FTP PORT command */</i></td></tr>
<tr><th id="1622">1622</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::hide_progress" title='UserDefined::hide_progress' data-ref="UserDefined::hide_progress">hide_progress</dfn>;    <i>/* don't use the progress meter */</i></td></tr>
<tr><th id="1623">1623</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_fail_on_error" title='UserDefined::http_fail_on_error' data-ref="UserDefined::http_fail_on_error">http_fail_on_error</dfn>;  <i>/* fail on HTTP error codes &gt;= 400 */</i></td></tr>
<tr><th id="1624">1624</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_keep_sending_on_error" title='UserDefined::http_keep_sending_on_error' data-ref="UserDefined::http_keep_sending_on_error">http_keep_sending_on_error</dfn>; <i>/* for HTTP status codes &gt;= 300 */</i></td></tr>
<tr><th id="1625">1625</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_follow_location" title='UserDefined::http_follow_location' data-ref="UserDefined::http_follow_location">http_follow_location</dfn>; <i>/* follow HTTP redirects */</i></td></tr>
<tr><th id="1626">1626</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_transfer_encoding" title='UserDefined::http_transfer_encoding' data-ref="UserDefined::http_transfer_encoding">http_transfer_encoding</dfn>; <i>/* request compressed HTTP transfer-encoding */</i></td></tr>
<tr><th id="1627">1627</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_disable_hostname_check_before_authentication" title='UserDefined::http_disable_hostname_check_before_authentication' data-ref="UserDefined::http_disable_hostname_check_before_authentication">http_disable_hostname_check_before_authentication</dfn>;</td></tr>
<tr><th id="1628">1628</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::include_header" title='UserDefined::include_header' data-ref="UserDefined::include_header">include_header</dfn>;   <i>/* include received protocol headers in data output */</i></td></tr>
<tr><th id="1629">1629</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_set_referer" title='UserDefined::http_set_referer' data-ref="UserDefined::http_set_referer">http_set_referer</dfn>; <i>/* is a custom referer used */</i></td></tr>
<tr><th id="1630">1630</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_auto_referer" title='UserDefined::http_auto_referer' data-ref="UserDefined::http_auto_referer">http_auto_referer</dfn>; <i>/* set "correct" referer when following location: */</i></td></tr>
<tr><th id="1631">1631</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::opt_no_body" title='UserDefined::opt_no_body' data-ref="UserDefined::opt_no_body">opt_no_body</dfn>;      <i>/* as set with CURLOPT_NOBODY */</i></td></tr>
<tr><th id="1632">1632</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::upload" title='UserDefined::upload' data-ref="UserDefined::upload">upload</dfn>;           <i>/* upload request */</i></td></tr>
<tr><th id="1633">1633</th><td>  <b>enum</b> <a class="type" href="../include/curl/curl.h.html#CURL_NETRC_OPTION" title='CURL_NETRC_OPTION' data-ref="CURL_NETRC_OPTION">CURL_NETRC_OPTION</a></td></tr>
<tr><th id="1634">1634</th><td>       <dfn class="decl" id="UserDefined::use_netrc" title='UserDefined::use_netrc' data-ref="UserDefined::use_netrc">use_netrc</dfn>;        <i>/* defined in include/curl.h */</i></td></tr>
<tr><th id="1635">1635</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::verbose" title='UserDefined::verbose' data-ref="UserDefined::verbose">verbose</dfn>;          <i>/* output verbosity */</i></td></tr>
<tr><th id="1636">1636</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::krb" title='UserDefined::krb' data-ref="UserDefined::krb">krb</dfn>;              <i>/* Kerberos connection requested */</i></td></tr>
<tr><th id="1637">1637</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::reuse_forbid" title='UserDefined::reuse_forbid' data-ref="UserDefined::reuse_forbid">reuse_forbid</dfn>;     <i>/* forbidden to be reused, close after use */</i></td></tr>
<tr><th id="1638">1638</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::reuse_fresh" title='UserDefined::reuse_fresh' data-ref="UserDefined::reuse_fresh">reuse_fresh</dfn>;      <i>/* do not re-use an existing connection  */</i></td></tr>
<tr><th id="1639">1639</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_use_epsv" title='UserDefined::ftp_use_epsv' data-ref="UserDefined::ftp_use_epsv">ftp_use_epsv</dfn>;     <i>/* if EPSV is to be attempted or not */</i></td></tr>
<tr><th id="1640">1640</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_use_eprt" title='UserDefined::ftp_use_eprt' data-ref="UserDefined::ftp_use_eprt">ftp_use_eprt</dfn>;     <i>/* if EPRT is to be attempted or not */</i></td></tr>
<tr><th id="1641">1641</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_use_pret" title='UserDefined::ftp_use_pret' data-ref="UserDefined::ftp_use_pret">ftp_use_pret</dfn>;     <i>/* if PRET is to be used before PASV or not */</i></td></tr>
<tr><th id="1642">1642</th><td></td></tr>
<tr><th id="1643">1643</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_usessl" title='curl_usessl' data-type='enum curl_usessl' data-ref="curl_usessl">curl_usessl</a> <dfn class="decl" id="UserDefined::use_ssl" title='UserDefined::use_ssl' data-ref="UserDefined::use_ssl">use_ssl</dfn>;   <i>/* if AUTH TLS is to be attempted etc, for FTP or</i></td></tr>
<tr><th id="1644">1644</th><td><i>                            IMAP or POP3 or others! */</i></td></tr>
<tr><th id="1645">1645</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_ftpauth" title='curl_ftpauth' data-type='enum curl_ftpauth' data-ref="curl_ftpauth">curl_ftpauth</a> <dfn class="decl" id="UserDefined::ftpsslauth" title='UserDefined::ftpsslauth' data-ref="UserDefined::ftpsslauth">ftpsslauth</dfn>; <i>/* what AUTH XXX to be attempted */</i></td></tr>
<tr><th id="1646">1646</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_ftpccc" title='curl_ftpccc' data-type='enum curl_ftpccc' data-ref="curl_ftpccc">curl_ftpccc</a> <dfn class="decl" id="UserDefined::ftp_ccc" title='UserDefined::ftp_ccc' data-ref="UserDefined::ftp_ccc">ftp_ccc</dfn>;   <i>/* FTP CCC options */</i></td></tr>
<tr><th id="1647">1647</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::no_signal" title='UserDefined::no_signal' data-ref="UserDefined::no_signal">no_signal</dfn>;        <i>/* do not use any signal/alarm handler */</i></td></tr>
<tr><th id="1648">1648</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::global_dns_cache" title='UserDefined::global_dns_cache' data-ref="UserDefined::global_dns_cache">global_dns_cache</dfn>; <i>/* subject for future removal */</i></td></tr>
<tr><th id="1649">1649</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::tcp_nodelay" title='UserDefined::tcp_nodelay' data-ref="UserDefined::tcp_nodelay">tcp_nodelay</dfn>;      <i>/* whether to enable TCP_NODELAY or not */</i></td></tr>
<tr><th id="1650">1650</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ignorecl" title='UserDefined::ignorecl' data-ref="UserDefined::ignorecl">ignorecl</dfn>;         <i>/* ignore content length */</i></td></tr>
<tr><th id="1651">1651</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ftp_skip_ip" title='UserDefined::ftp_skip_ip' data-ref="UserDefined::ftp_skip_ip">ftp_skip_ip</dfn>;      <i>/* skip the IP address the FTP server passes on to</i></td></tr>
<tr><th id="1652">1652</th><td><i>                            us */</i></td></tr>
<tr><th id="1653">1653</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::connect_only" title='UserDefined::connect_only' data-ref="UserDefined::connect_only">connect_only</dfn>;     <i>/* make connection, let application use the socket */</i></td></tr>
<tr><th id="1654">1654</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::ssh_auth_types" title='UserDefined::ssh_auth_types' data-ref="UserDefined::ssh_auth_types">ssh_auth_types</dfn>;   <i>/* allowed SSH auth types */</i></td></tr>
<tr><th id="1655">1655</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_te_skip" title='UserDefined::http_te_skip' data-ref="UserDefined::http_te_skip">http_te_skip</dfn>;     <i>/* pass the raw body data to the user, even when</i></td></tr>
<tr><th id="1656">1656</th><td><i>                            transfer-encoded (chunked, compressed) */</i></td></tr>
<tr><th id="1657">1657</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::http_ce_skip" title='UserDefined::http_ce_skip' data-ref="UserDefined::http_ce_skip">http_ce_skip</dfn>;     <i>/* pass the raw body data to the user, even when</i></td></tr>
<tr><th id="1658">1658</th><td><i>                            content-encoded (chunked, compressed) */</i></td></tr>
<tr><th id="1659">1659</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::new_file_perms" title='UserDefined::new_file_perms' data-ref="UserDefined::new_file_perms">new_file_perms</dfn>;    <i>/* Permissions to use when creating remote files */</i></td></tr>
<tr><th id="1660">1660</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::new_directory_perms" title='UserDefined::new_directory_perms' data-ref="UserDefined::new_directory_perms">new_directory_perms</dfn>; <i>/* Permissions to use when creating remote dirs */</i></td></tr>
<tr><th id="1661">1661</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::proxy_transfer_mode" title='UserDefined::proxy_transfer_mode' data-ref="UserDefined::proxy_transfer_mode">proxy_transfer_mode</dfn>; <i>/* set transfer mode (;type=&lt;a|i&gt;) when doing FTP</i></td></tr>
<tr><th id="1662">1662</th><td><i>                               via an HTTP proxy */</i></td></tr>
<tr><th id="1663">1663</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::str" title='UserDefined::str' data-ref="UserDefined::str">str</dfn>[<a class="enum" href="#dupstring::STRING_LAST" title='dupstring::STRING_LAST' data-ref="dupstring::STRING_LAST">STRING_LAST</a>]; <i>/* array of strings, pointing to allocated memory */</i></td></tr>
<tr><th id="1664">1664</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="UserDefined::scope_id" title='UserDefined::scope_id' data-ref="UserDefined::scope_id">scope_id</dfn>;  <i>/* Scope id for IPv6 */</i></td></tr>
<tr><th id="1665">1665</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::allowed_protocols" title='UserDefined::allowed_protocols' data-ref="UserDefined::allowed_protocols">allowed_protocols</dfn>;</td></tr>
<tr><th id="1666">1666</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::redir_protocols" title='UserDefined::redir_protocols' data-ref="UserDefined::redir_protocols">redir_protocols</dfn>;</td></tr>
<tr><th id="1667">1667</th><td><u>#<span data-ppcond="1667">if</span> defined(<span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span>) || defined(<span class="macro" data-ref="_M/USE_WINDOWS_SSPI">USE_WINDOWS_SSPI</span>)</u></td></tr>
<tr><th id="1668">1668</th><td>  bool socks5_gssapi_nec; <i>/* Flag to support NEC SOCKS5 server */</i></td></tr>
<tr><th id="1669">1669</th><td><u>#<span data-ppcond="1667">endif</span></u></td></tr>
<tr><th id="1670">1670</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::mail_rcpt" title='UserDefined::mail_rcpt' data-ref="UserDefined::mail_rcpt">mail_rcpt</dfn>; <i>/* linked list of mail recipients */</i></td></tr>
<tr><th id="1671">1671</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::sasl_ir" title='UserDefined::sasl_ir' data-ref="UserDefined::sasl_ir">sasl_ir</dfn>;         <i>/* Enable/disable SASL initial response */</i></td></tr>
<tr><th id="1672">1672</th><td>  <i>/* Common RTSP header options */</i></td></tr>
<tr><th id="1673">1673</th><td>  <a class="typedef" href="#Curl_RtspReq" title='Curl_RtspReq' data-type='enum Curl_RtspReq' data-ref="Curl_RtspReq">Curl_RtspReq</a> <dfn class="decl" id="UserDefined::rtspreq" title='UserDefined::rtspreq' data-ref="UserDefined::rtspreq">rtspreq</dfn>; <i>/* RTSP request type */</i></td></tr>
<tr><th id="1674">1674</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::rtspversion" title='UserDefined::rtspversion' data-ref="UserDefined::rtspversion">rtspversion</dfn>; <i>/* like httpversion, for RTSP */</i></td></tr>
<tr><th id="1675">1675</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::wildcardmatch" title='UserDefined::wildcardmatch' data-ref="UserDefined::wildcardmatch">wildcardmatch</dfn>; <i>/* enable wildcard matching */</i></td></tr>
<tr><th id="1676">1676</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_chunk_bgn_callback" title='curl_chunk_bgn_callback' data-type='long (*)(const void *, void *, int)' data-ref="curl_chunk_bgn_callback">curl_chunk_bgn_callback</a> <dfn class="decl" id="UserDefined::chunk_bgn" title='UserDefined::chunk_bgn' data-ref="UserDefined::chunk_bgn">chunk_bgn</dfn>; <i>/* called before part of transfer</i></td></tr>
<tr><th id="1677">1677</th><td><i>                                        starts */</i></td></tr>
<tr><th id="1678">1678</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_chunk_end_callback" title='curl_chunk_end_callback' data-type='long (*)(void *)' data-ref="curl_chunk_end_callback">curl_chunk_end_callback</a> <dfn class="decl" id="UserDefined::chunk_end" title='UserDefined::chunk_end' data-ref="UserDefined::chunk_end">chunk_end</dfn>; <i>/* called after part transferring</i></td></tr>
<tr><th id="1679">1679</th><td><i>                                        stopped */</i></td></tr>
<tr><th id="1680">1680</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_fnmatch_callback" title='curl_fnmatch_callback' data-type='int (*)(void *, const char *, const char *)' data-ref="curl_fnmatch_callback">curl_fnmatch_callback</a> <dfn class="decl" id="UserDefined::fnmatch" title='UserDefined::fnmatch' data-ref="UserDefined::fnmatch">fnmatch</dfn>; <i>/* callback to decide which file corresponds</i></td></tr>
<tr><th id="1681">1681</th><td><i>                                    to pattern (e.g. if WILDCARDMATCH is on) */</i></td></tr>
<tr><th id="1682">1682</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::fnmatch_data" title='UserDefined::fnmatch_data' data-ref="UserDefined::fnmatch_data">fnmatch_data</dfn>;</td></tr>
<tr><th id="1683">1683</th><td></td></tr>
<tr><th id="1684">1684</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::gssapi_delegation" title='UserDefined::gssapi_delegation' data-ref="UserDefined::gssapi_delegation">gssapi_delegation</dfn>; <i>/* GSS-API credential delegation, see the</i></td></tr>
<tr><th id="1685">1685</th><td><i>                             documentation of CURLOPT_GSSAPI_DELEGATION */</i></td></tr>
<tr><th id="1686">1686</th><td></td></tr>
<tr><th id="1687">1687</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::tcp_keepalive" title='UserDefined::tcp_keepalive' data-ref="UserDefined::tcp_keepalive">tcp_keepalive</dfn>;    <i>/* use TCP keepalives */</i></td></tr>
<tr><th id="1688">1688</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::tcp_keepidle" title='UserDefined::tcp_keepidle' data-ref="UserDefined::tcp_keepidle">tcp_keepidle</dfn>;     <i>/* seconds in idle before sending keepalive probe */</i></td></tr>
<tr><th id="1689">1689</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::tcp_keepintvl" title='UserDefined::tcp_keepintvl' data-ref="UserDefined::tcp_keepintvl">tcp_keepintvl</dfn>;    <i>/* seconds between TCP keepalive probes */</i></td></tr>
<tr><th id="1690">1690</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::tcp_fastopen" title='UserDefined::tcp_fastopen' data-ref="UserDefined::tcp_fastopen">tcp_fastopen</dfn>;     <i>/* use TCP Fast Open */</i></td></tr>
<tr><th id="1691">1691</th><td></td></tr>
<tr><th id="1692">1692</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="UserDefined::maxconnects" title='UserDefined::maxconnects' data-ref="UserDefined::maxconnects">maxconnects</dfn>;  <i>/* Max idle connections in the connection cache */</i></td></tr>
<tr><th id="1693">1693</th><td></td></tr>
<tr><th id="1694">1694</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ssl_enable_npn" title='UserDefined::ssl_enable_npn' data-ref="UserDefined::ssl_enable_npn">ssl_enable_npn</dfn>;      <i>/* TLS NPN extension? */</i></td></tr>
<tr><th id="1695">1695</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::ssl_enable_alpn" title='UserDefined::ssl_enable_alpn' data-ref="UserDefined::ssl_enable_alpn">ssl_enable_alpn</dfn>;     <i>/* TLS ALPN extension? */</i></td></tr>
<tr><th id="1696">1696</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::path_as_is" title='UserDefined::path_as_is' data-ref="UserDefined::path_as_is">path_as_is</dfn>;      <i>/* allow dotdots? */</i></td></tr>
<tr><th id="1697">1697</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::pipewait" title='UserDefined::pipewait' data-ref="UserDefined::pipewait">pipewait</dfn>;        <i>/* wait for pipe/multiplex status before starting a</i></td></tr>
<tr><th id="1698">1698</th><td><i>                           new connection */</i></td></tr>
<tr><th id="1699">1699</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::expect_100_timeout" title='UserDefined::expect_100_timeout' data-ref="UserDefined::expect_100_timeout">expect_100_timeout</dfn>; <i>/* in milliseconds */</i></td></tr>
<tr><th id="1700">1700</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::suppress_connect_headers" title='UserDefined::suppress_connect_headers' data-ref="UserDefined::suppress_connect_headers">suppress_connect_headers</dfn>;  <i>/* suppress proxy CONNECT response headers</i></td></tr>
<tr><th id="1701">1701</th><td><i>                                     from user callbacks */</i></td></tr>
<tr><th id="1702">1702</th><td></td></tr>
<tr><th id="1703">1703</th><td>  <b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="decl" id="UserDefined::stream_depends_on" title='UserDefined::stream_depends_on' data-ref="UserDefined::stream_depends_on">stream_depends_on</dfn>;</td></tr>
<tr><th id="1704">1704</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::stream_depends_e" title='UserDefined::stream_depends_e' data-ref="UserDefined::stream_depends_e">stream_depends_e</dfn>; <i>/* set or don't set the Exclusive bit */</i></td></tr>
<tr><th id="1705">1705</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::stream_weight" title='UserDefined::stream_weight' data-ref="UserDefined::stream_weight">stream_weight</dfn>;</td></tr>
<tr><th id="1706">1706</th><td></td></tr>
<tr><th id="1707">1707</th><td>  <b>struct</b> <a class="type" href="#Curl_http2_dep" title='Curl_http2_dep' data-ref="Curl_http2_dep">Curl_http2_dep</a> *<dfn class="decl" id="UserDefined::stream_dependents" title='UserDefined::stream_dependents' data-ref="UserDefined::stream_dependents">stream_dependents</dfn>;</td></tr>
<tr><th id="1708">1708</th><td></td></tr>
<tr><th id="1709">1709</th><td>  <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="UserDefined::abstract_unix_socket" title='UserDefined::abstract_unix_socket' data-ref="UserDefined::abstract_unix_socket">abstract_unix_socket</dfn>;</td></tr>
<tr><th id="1710">1710</th><td>};</td></tr>
<tr><th id="1711">1711</th><td></td></tr>
<tr><th id="1712">1712</th><td><b>struct</b> <dfn class="type def" id="Names" title='Names' data-ref="Names">Names</dfn> {</td></tr>
<tr><th id="1713">1713</th><td>  <b>struct</b> <a class="type" href="hash.h.html#curl_hash" title='curl_hash' data-ref="curl_hash">curl_hash</a> *<dfn class="decl" id="Names::hostcache" title='Names::hostcache' data-ref="Names::hostcache">hostcache</dfn>;</td></tr>
<tr><th id="1714">1714</th><td>  <b>enum</b> {</td></tr>
<tr><th id="1715">1715</th><td>    <dfn class="enum" id="Names::HCACHE_NONE" title='Names::HCACHE_NONE' data-ref="Names::HCACHE_NONE">HCACHE_NONE</dfn>,    <i>/* not pointing to anything */</i></td></tr>
<tr><th id="1716">1716</th><td>    <dfn class="enum" id="Names::HCACHE_GLOBAL" title='Names::HCACHE_GLOBAL' data-ref="Names::HCACHE_GLOBAL">HCACHE_GLOBAL</dfn>,  <i>/* points to the (shrug) global one */</i></td></tr>
<tr><th id="1717">1717</th><td>    <dfn class="enum" id="Names::HCACHE_MULTI" title='Names::HCACHE_MULTI' data-ref="Names::HCACHE_MULTI">HCACHE_MULTI</dfn>,   <i>/* points to a shared one in the multi handle */</i></td></tr>
<tr><th id="1718">1718</th><td>    <dfn class="enum" id="Names::HCACHE_SHARED" title='Names::HCACHE_SHARED' data-ref="Names::HCACHE_SHARED">HCACHE_SHARED</dfn>   <i>/* points to a shared one in a shared object */</i></td></tr>
<tr><th id="1719">1719</th><td>  } <dfn class="decl" id="Names::hostcachetype" title='Names::hostcachetype' data-ref="Names::hostcachetype">hostcachetype</dfn>;</td></tr>
<tr><th id="1720">1720</th><td>};</td></tr>
<tr><th id="1721">1721</th><td></td></tr>
<tr><th id="1722">1722</th><td><i>/*</i></td></tr>
<tr><th id="1723">1723</th><td><i> * The 'connectdata' struct MUST have all the connection oriented stuff as we</i></td></tr>
<tr><th id="1724">1724</th><td><i> * may have several simultaneous connections and connection structs in memory.</i></td></tr>
<tr><th id="1725">1725</th><td><i> *</i></td></tr>
<tr><th id="1726">1726</th><td><i> * The 'struct UserDefined' must only contain data that is set once to go for</i></td></tr>
<tr><th id="1727">1727</th><td><i> * many (perhaps) independent connections. Values that are generated or</i></td></tr>
<tr><th id="1728">1728</th><td><i> * calculated internally for the "session handle" must be defined within the</i></td></tr>
<tr><th id="1729">1729</th><td><i> * 'struct UrlState' instead.</i></td></tr>
<tr><th id="1730">1730</th><td><i> */</i></td></tr>
<tr><th id="1731">1731</th><td></td></tr>
<tr><th id="1732">1732</th><td><b>struct</b> <dfn class="type def" id="Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</dfn> {</td></tr>
<tr><th id="1733">1733</th><td>  <i>/* first, two fields for the linked list of these */</i></td></tr>
<tr><th id="1734">1734</th><td>  <b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="decl" id="Curl_easy::next" title='Curl_easy::next' data-ref="Curl_easy::next">next</dfn>;</td></tr>
<tr><th id="1735">1735</th><td>  <b>struct</b> <a class="type" href="#Curl_easy" title='Curl_easy' data-ref="Curl_easy">Curl_easy</a> *<dfn class="decl" id="Curl_easy::prev" title='Curl_easy::prev' data-ref="Curl_easy::prev">prev</dfn>;</td></tr>
<tr><th id="1736">1736</th><td></td></tr>
<tr><th id="1737">1737</th><td>  <b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *<dfn class="decl" id="Curl_easy::easy_conn" title='Curl_easy::easy_conn' data-ref="Curl_easy::easy_conn">easy_conn</dfn>;     <i>/* the "unit's" connection */</i></td></tr>
<tr><th id="1738">1738</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist_element" title='curl_llist_element' data-ref="curl_llist_element">curl_llist_element</a> <dfn class="decl" id="Curl_easy::connect_queue" title='Curl_easy::connect_queue' data-ref="Curl_easy::connect_queue">connect_queue</dfn>;</td></tr>
<tr><th id="1739">1739</th><td>  <b>struct</b> <a class="type" href="llist.h.html#curl_llist_element" title='curl_llist_element' data-ref="curl_llist_element">curl_llist_element</a> <dfn class="decl" id="Curl_easy::pipeline_queue" title='Curl_easy::pipeline_queue' data-ref="Curl_easy::pipeline_queue">pipeline_queue</dfn>;</td></tr>
<tr><th id="1740">1740</th><td></td></tr>
<tr><th id="1741">1741</th><td>  <a class="typedef" href="multihandle.h.html#CURLMstate" title='CURLMstate' data-type='enum CURLMstate' data-ref="CURLMstate">CURLMstate</a> <dfn class="decl" id="Curl_easy::mstate" title='Curl_easy::mstate' data-ref="Curl_easy::mstate">mstate</dfn>;  <i>/* the handle's state */</i></td></tr>
<tr><th id="1742">1742</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> <dfn class="decl" id="Curl_easy::result" title='Curl_easy::result' data-ref="Curl_easy::result">result</dfn>;   <i>/* previous result */</i></td></tr>
<tr><th id="1743">1743</th><td></td></tr>
<tr><th id="1744">1744</th><td>  <b>struct</b> <a class="type" href="multihandle.h.html#Curl_message" title='Curl_message' data-ref="Curl_message">Curl_message</a> <dfn class="decl" id="Curl_easy::msg" title='Curl_easy::msg' data-ref="Curl_easy::msg">msg</dfn>; <i>/* A single posted message. */</i></td></tr>
<tr><th id="1745">1745</th><td></td></tr>
<tr><th id="1746">1746</th><td>  <i>/* Array with the plain socket numbers this handle takes care of, in no</i></td></tr>
<tr><th id="1747">1747</th><td><i>     particular order. Note that all sockets are added to the sockhash, where</i></td></tr>
<tr><th id="1748">1748</th><td><i>     the state etc are also kept. This array is mostly used to detect when a</i></td></tr>
<tr><th id="1749">1749</th><td><i>     socket is to be removed from the hash. See singlesocket(). */</i></td></tr>
<tr><th id="1750">1750</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="Curl_easy::sockets" title='Curl_easy::sockets' data-ref="Curl_easy::sockets">sockets</dfn>[<a class="macro" href="multihandle.h.html#64" title="5" data-ref="_M/MAX_SOCKSPEREASYHANDLE">MAX_SOCKSPEREASYHANDLE</a>];</td></tr>
<tr><th id="1751">1751</th><td>  <em>int</em> <dfn class="decl" id="Curl_easy::numsocks" title='Curl_easy::numsocks' data-ref="Curl_easy::numsocks">numsocks</dfn>;</td></tr>
<tr><th id="1752">1752</th><td></td></tr>
<tr><th id="1753">1753</th><td>  <b>struct</b> <a class="type" href="#Names" title='Names' data-ref="Names">Names</a> <dfn class="decl" id="Curl_easy::dns" title='Curl_easy::dns' data-ref="Curl_easy::dns">dns</dfn>;</td></tr>
<tr><th id="1754">1754</th><td>  <b>struct</b> <a class="type" href="multihandle.h.html#Curl_multi" title='Curl_multi' data-ref="Curl_multi">Curl_multi</a> *<dfn class="decl" id="Curl_easy::multi" title='Curl_easy::multi' data-ref="Curl_easy::multi">multi</dfn>;    <i>/* if non-NULL, points to the multi handle</i></td></tr>
<tr><th id="1755">1755</th><td><i>                                  struct to which this "belongs" when used by</i></td></tr>
<tr><th id="1756">1756</th><td><i>                                  the multi interface */</i></td></tr>
<tr><th id="1757">1757</th><td>  <b>struct</b> <a class="type" href="multihandle.h.html#Curl_multi" title='Curl_multi' data-ref="Curl_multi">Curl_multi</a> *<dfn class="decl" id="Curl_easy::multi_easy" title='Curl_easy::multi_easy' data-ref="Curl_easy::multi_easy">multi_easy</dfn>; <i>/* if non-NULL, points to the multi handle</i></td></tr>
<tr><th id="1758">1758</th><td><i>                                    struct to which this "belongs" when used</i></td></tr>
<tr><th id="1759">1759</th><td><i>                                    by the easy interface */</i></td></tr>
<tr><th id="1760">1760</th><td>  <b>struct</b> <a class="type" href="share.h.html#Curl_share" title='Curl_share' data-ref="Curl_share">Curl_share</a> *<dfn class="decl" id="Curl_easy::share" title='Curl_easy::share' data-ref="Curl_easy::share">share</dfn>;    <i>/* Share, handles global variable mutexing */</i></td></tr>
<tr><th id="1761">1761</th><td>  <b>struct</b> <a class="type" href="#SingleRequest" title='SingleRequest' data-ref="SingleRequest">SingleRequest</a> <dfn class="decl" id="Curl_easy::req" title='Curl_easy::req' data-ref="Curl_easy::req">req</dfn>;    <i>/* Request-specific data */</i></td></tr>
<tr><th id="1762">1762</th><td>  <b>struct</b> <a class="type" href="#UserDefined" title='UserDefined' data-ref="UserDefined">UserDefined</a> <dfn class="decl" id="Curl_easy::set" title='Curl_easy::set' data-ref="Curl_easy::set">set</dfn>;      <i>/* values set by the libcurl user */</i></td></tr>
<tr><th id="1763">1763</th><td>  <b>struct</b> <a class="type" href="#DynamicStatic" title='DynamicStatic' data-ref="DynamicStatic">DynamicStatic</a> <dfn class="decl" id="Curl_easy::change" title='Curl_easy::change' data-ref="Curl_easy::change">change</dfn>; <i>/* possibly modified userdefined data */</i></td></tr>
<tr><th id="1764">1764</th><td>  <b>struct</b> <a class="type" href="cookie.h.html#CookieInfo" title='CookieInfo' data-ref="CookieInfo">CookieInfo</a> *<dfn class="decl" id="Curl_easy::cookies" title='Curl_easy::cookies' data-ref="Curl_easy::cookies">cookies</dfn>;  <i>/* the cookies, read from files and servers.</i></td></tr>
<tr><th id="1765">1765</th><td><i>                                  NOTE that the 'cookie' field in the</i></td></tr>
<tr><th id="1766">1766</th><td><i>                                  UserDefined struct defines if the "engine"</i></td></tr>
<tr><th id="1767">1767</th><td><i>                                  is to be used or not. */</i></td></tr>
<tr><th id="1768">1768</th><td>  <b>struct</b> <a class="type" href="#Progress" title='Progress' data-ref="Progress">Progress</a> <dfn class="decl" id="Curl_easy::progress" title='Curl_easy::progress' data-ref="Curl_easy::progress">progress</dfn>;    <i>/* for all the progress meter data */</i></td></tr>
<tr><th id="1769">1769</th><td>  <b>struct</b> <a class="type" href="#UrlState" title='UrlState' data-ref="UrlState">UrlState</a> <dfn class="decl" id="Curl_easy::state" title='Curl_easy::state' data-ref="Curl_easy::state">state</dfn>;       <i>/* struct for fields used for state info and</i></td></tr>
<tr><th id="1770">1770</th><td><i>                                  other dynamic purposes */</i></td></tr>
<tr><th id="1771">1771</th><td>  <b>struct</b> <a class="type" href="wildcard.h.html#WildcardData" title='WildcardData' data-ref="WildcardData">WildcardData</a> <dfn class="decl" id="Curl_easy::wildcard" title='Curl_easy::wildcard' data-ref="Curl_easy::wildcard">wildcard</dfn>; <i>/* wildcard download state info */</i></td></tr>
<tr><th id="1772">1772</th><td>  <b>struct</b> <a class="type" href="#PureInfo" title='PureInfo' data-ref="PureInfo">PureInfo</a> <dfn class="decl" id="Curl_easy::info" title='Curl_easy::info' data-ref="Curl_easy::info">info</dfn>;        <i>/* stats, reports and info data */</i></td></tr>
<tr><th id="1773">1773</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_tlssessioninfo" title='curl_tlssessioninfo' data-ref="curl_tlssessioninfo">curl_tlssessioninfo</a> <dfn class="decl" id="Curl_easy::tsi" title='Curl_easy::tsi' data-ref="Curl_easy::tsi">tsi</dfn>; <i>/* Information about the TLS session, only</i></td></tr>
<tr><th id="1774">1774</th><td><i>                                     valid after a client has asked for it */</i></td></tr>
<tr><th id="1775">1775</th><td><u>#<span data-ppcond="1775">if</span> defined(<span class="macro" data-ref="_M/CURL_DOES_CONVERSIONS">CURL_DOES_CONVERSIONS</span>) &amp;&amp; defined(<span class="macro" data-ref="_M/HAVE_ICONV">HAVE_ICONV</span>)</u></td></tr>
<tr><th id="1776">1776</th><td>  iconv_t outbound_cd;         <i>/* for translating to the network encoding */</i></td></tr>
<tr><th id="1777">1777</th><td>  iconv_t inbound_cd;          <i>/* for translating from the network encoding */</i></td></tr>
<tr><th id="1778">1778</th><td>  iconv_t utf8_cd;             <i>/* for translating to UTF8 */</i></td></tr>
<tr><th id="1779">1779</th><td><u>#<span data-ppcond="1775">endif</span> /* CURL_DOES_CONVERSIONS &amp;&amp; HAVE_ICONV */</u></td></tr>
<tr><th id="1780">1780</th><td>  <em>unsigned</em> <em>int</em> <dfn class="decl" id="Curl_easy::magic" title='Curl_easy::magic' data-ref="Curl_easy::magic">magic</dfn>;          <i>/* set to a CURLEASY_MAGIC_NUMBER */</i></td></tr>
<tr><th id="1781">1781</th><td>};</td></tr>
<tr><th id="1782">1782</th><td></td></tr>
<tr><th id="1783">1783</th><td><u>#define <dfn class="macro" id="_M/LIBCURL_NAME" data-ref="_M/LIBCURL_NAME">LIBCURL_NAME</dfn> "libcurl"</u></td></tr>
<tr><th id="1784">1784</th><td></td></tr>
<tr><th id="1785">1785</th><td><u>#<span data-ppcond="1">endif</span> /* HEADER_CURL_URLDATA_H */</u></td></tr>
<tr><th id="1786">1786</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='asyn-thread.c.html'>codebrowser/lib/asyn-thread.c</a><br/>Generated on <em>2017-Oct-09</em> from project codebrowser revision <em>curl-7_56_0-29-g06cb8ad</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
